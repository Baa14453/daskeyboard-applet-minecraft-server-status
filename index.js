var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../node_modules/protodef/src/utils.js
var require_utils = __commonJS({
  "../node_modules/protodef/src/utils.js"(exports2, module2) {
    function getField(countField, context) {
      const countFieldArr = countField.split("/");
      let i = 0;
      if (countFieldArr[i] === "") {
        while (context[".."] !== void 0) {
          context = context[".."];
        }
        i++;
      }
      for (; i < countFieldArr.length; i++) {
        context = context[countFieldArr[i]];
      }
      return context;
    }
    function getFieldInfo(fieldInfo) {
      if (typeof fieldInfo === "string") {
        return { type: fieldInfo };
      } else if (Array.isArray(fieldInfo)) {
        return { type: fieldInfo[0], typeArgs: fieldInfo[1] };
      } else if (typeof fieldInfo.type === "string") {
        return fieldInfo;
      } else {
        throw new Error("Not a fieldinfo");
      }
    }
    function getCount(buffer, offset, { count, countType }, rootNode) {
      let c = 0;
      let size = 0;
      if (typeof count === "number") {
        c = count;
      } else if (typeof count !== "undefined") {
        c = getField(count, rootNode);
      } else if (typeof countType !== "undefined") {
        ({ size, value: c } = tryDoc(() => this.read(buffer, offset, getFieldInfo(countType), rootNode), "$count"));
      } else {
        c = 0;
      }
      return { count: c, size };
    }
    function sendCount(len, buffer, offset, { count, countType }, rootNode) {
      if (typeof count !== "undefined" && len !== count) {
      } else if (typeof countType !== "undefined") {
        offset = this.write(len, buffer, offset, getFieldInfo(countType), rootNode);
      } else {
      }
      return offset;
    }
    function calcCount(len, { count, countType }, rootNode) {
      if (typeof count === "undefined" && typeof countType !== "undefined") {
        return tryDoc(() => this.sizeOf(len, getFieldInfo(countType), rootNode), "$count");
      } else {
        return 0;
      }
    }
    function addErrorField(e, field) {
      e.field = e.field ? field + "." + e.field : field;
      throw e;
    }
    function tryCatch2(tryfn, catchfn) {
      try {
        return tryfn();
      } catch (e) {
        catchfn(e);
      }
    }
    function tryDoc(tryfn, field) {
      return tryCatch2(tryfn, (e) => addErrorField(e, field));
    }
    var ExtendableError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        this.message = message;
        if (Error.captureStackTrace != null) {
          Error.captureStackTrace(this, this.constructor.name);
        }
      }
    };
    var PartialReadError2 = class extends ExtendableError {
      constructor(message) {
        super(message);
        this.partialReadError = true;
      }
    };
    module2.exports = {
      getField,
      getFieldInfo,
      addErrorField,
      getCount,
      sendCount,
      calcCount,
      tryCatch: tryCatch2,
      tryDoc,
      PartialReadError: PartialReadError2
    };
  }
});

// ../node_modules/lodash.reduce/index.js
var require_lodash = __commonJS({
  "../node_modules/lodash.reduce/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = reduce;
  }
});

// ../node_modules/lodash.get/index.js
var require_lodash2 = __commonJS({
  "../node_modules/lodash.get/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// ../node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "../node_modules/uri-js/dist/es5/uri.all.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports2, function(exports3) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (var w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q2 = delta;
                for (var k = base; ; k += base) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q2 < t) {
                    break;
                  }
                  var qMinusT = q2 - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q2 = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q2, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        "version": "2.1.0",
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol2) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol2.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol2.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol2.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol2.PCT_ENCODED, decodeUnreserved2).replace(protocol2.NOT_USERINFO, pctEncChar).replace(protocol2.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol2.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol2.NOT_HOST, pctEncChar).replace(protocol2.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol2.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol2.NOT_PATH : protocol2.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol2.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol2.PCT_ENCODED, decodeUnreserved2).replace(protocol2.NOT_QUERY, pctEncChar).replace(protocol2.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol2.PCT_ENCODED, decodeUnreserved2).replace(protocol2.NOT_FRAGMENT, pctEncChar).replace(protocol2.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol2) {
        var matches = host.match(protocol2.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol2) {
        var matches = host.match(protocol2.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol2.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol2);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol2 = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol2), protocol2);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol2.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol2);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol2 = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol2), protocol2).replace(protocol2.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol2 = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol2.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol2.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol2);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports3.SCHEMES = SCHEMES;
      exports3.pctEncChar = pctEncChar;
      exports3.pctDecChars = pctDecChars;
      exports3.parse = parse;
      exports3.removeDotSegments = removeDotSegments;
      exports3.serialize = serialize;
      exports3.resolveComponents = resolveComponents;
      exports3.resolve = resolve;
      exports3.normalize = normalize;
      exports3.equal = equal;
      exports3.escapeComponent = escapeComponent;
      exports3.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "../node_modules/ajv/lib/compile/ucs2length.js"(exports2, module2) {
    "use strict";
    module2.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320)
            pos++;
        }
      }
      return length;
    };
  }
});

// ../node_modules/ajv/lib/compile/util.js
var require_util = __commonJS({
  "../node_modules/ajv/lib/compile/util.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o)
        to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
          return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code2 = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code2 = types.null ? "(" : "(!" + data + " || ";
            code2 += "typeof " + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number)
            delete types.integer;
          for (var t in types)
            code2 += (code2 ? " && " : "") + checkDataType(t, data, strictNumbers, true);
          return code2;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t])
            types[types.length] = t;
          else if (optionCoerceTypes === "array" && t === "array")
            types[types.length] = t;
        }
        if (types.length)
          return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++)
        hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches = str.match(new RegExp(dataVar, "g"));
      return matches ? matches.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (var key in schema)
        if (rules[key])
          return true;
    }
    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == "boolean")
        return !schema && exceptKeyword != "not";
      for (var key in schema)
        if (key != exceptKeyword && rules[key])
          return true;
    }
    function schemaUnknownRules(schema, rules) {
      if (typeof schema == "boolean")
        return;
      for (var key in schema)
        if (!rules[key])
          return key;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path);
    }
    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === "")
        return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data))
          throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches)
          throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
          if (up >= lvl)
            throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl)
          throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer)
          return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""')
        return b;
      return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// ../node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "../node_modules/ajv/lib/compile/schema_obj.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    module2.exports = SchemaObject;
    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }
});

// ../node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "../node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// ../node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS({
  "../node_modules/ajv/lib/compile/resolve.js"(exports2, module2) {
    "use strict";
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util = require_util();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module2.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal])
          refVal = this._refs[refVal];
        else
          return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
      } else if (schema !== void 0) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate)
              this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema)
          return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }
    var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema, root) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/")
        return;
      var parts = parsedRef.fragment.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === void 0)
            break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id)
              baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== void 0 && schema !== root.schema)
        return { schema, root, baseId };
    }
    var SIMPLE_INLINED = util.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema, limit) {
      if (limit === false)
        return false;
      if (limit === void 0 || limit === true)
        return checkNoRef(schema);
      else if (limit)
        return countKeys(schema) <= limit;
    }
    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return false;
          item = schema[key];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      }
      return true;
    }
    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object")
            count += countKeys(item);
          if (count == Infinity)
            return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == "object")
              count += countKeys(item) + 1;
            if (count == Infinity)
              return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "")
          return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string")
            refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// ../node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "../node_modules/ajv/lib/compile/error_classes.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve();
    module2.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// ../node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "../node_modules/fast-json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// ../node_modules/ajv/lib/dotjs/validate.js
var require_validate = __commonJS({
  "../node_modules/ajv/lib/dotjs/validate.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it.opts.strictKeywords === "log")
            it.logger.warn($keywordsMsg);
          else
            throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += " var validate = ";
        if ($async) {
          it.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it.opts.strictDefaults === "log")
            it.logger.warn($defaultMsg);
          else
            throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id)
          it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async)
          throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1)
            $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += " " + it.RULES.all.$comment.code(it, "$comment");
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i]))
            return true;
      }
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== void 0)
            return true;
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "../node_modules/ajv/lib/compile/index.js"(exports2, module2) {
    "use strict";
    var resolve = require_resolve();
    var util = require_util();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate();
    var ucs2length = util.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module2.exports = compile;
    function compile(schema, root, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema, refVal, refs };
      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling)
        return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode)
            cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }
      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode)
          sourceCode = opts.processCode(sourceCode, _schema);
        var validate;
        try {
          var makeValidate = new Function(
            "self",
            "RULES",
            "formats",
            "root",
            "refVal",
            "defaults",
            "customRules",
            "equal",
            "ucs2length",
            "ValidationError",
            sourceCode
          );
          validate = makeValidate(
            self2,
            RULES,
            formats,
            root,
            refVal,
            defaults,
            customRules,
            equal,
            ucs2length,
            ValidationError
          );
          refVal[0] = validate;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async)
          validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code2) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code: code2, schema: refVal2, inline: true } : { code: code2, $async: refVal2 && !!refVal2.$async };
      }
      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === void 0) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return "pattern" + index;
      }
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util.toQuotedString(value);
          case "object":
            if (value === null)
              return "null";
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === void 0) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return "default" + index;
        }
      }
      function useCustomRule(rule, schema2, parentSchema, it) {
        if (self2._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema2);
            if (!valid) {
              var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
              if (self2._opts.validateSchema == "log")
                self2.logger.error(message);
              else
                throw new Error(message);
            }
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile2) {
          validate = compile2.call(self2, schema2, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self2, schema2, parentSchema, it);
          if (opts.validateSchema !== false)
            self2.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate)
            return;
        }
        if (validate === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate;
        return {
          code: "customRule" + index,
          validate
        };
      }
    }
    function checkCompiling(schema, root, baseId) {
      var index = compIndex.call(this, schema, root, baseId);
      if (index >= 0)
        return { index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema,
        root,
        baseId
      };
      return { index, compiling: false };
    }
    function endCompiling(schema, root, baseId) {
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0)
        this._compilations.splice(i, 1);
    }
    function compIndex(schema, root, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId)
          return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length)
        return "";
      var code2 = "";
      for (var i = 0; i < arr.length; i++)
        code2 += statement(i, arr);
      return code2;
    }
  }
});

// ../node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "../node_modules/ajv/lib/cache.js"(exports2, module2) {
    "use strict";
    var Cache = module2.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// ../node_modules/ajv/lib/compile/formats.js
var require_formats = __commonJS({
  "../node_modules/ajv/lib/compile/formats.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module2.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util.copy(formats[mode]);
    }
    formats.fast = {
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL2,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      var matches = str.match(DATE);
      if (!matches)
        return false;
      var year = +matches[1];
      var month = +matches[2];
      var day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches)
        return false;
      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// ../node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "../node_modules/ajv/lib/dotjs/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async)
            throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "../node_modules/ajv/lib/dotjs/allOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "../node_modules/ajv/lib/dotjs/anyOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "../node_modules/ajv/lib/dotjs/comment.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_comment(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "../node_modules/ajv/lib/dotjs/const.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "../node_modules/ajv/lib/dotjs/contains.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "../node_modules/ajv/lib/dotjs/dependencies.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__")
          continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "../node_modules/ajv/lib/dotjs/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS({
  "../node_modules/ajv/lib/dotjs/format.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async)
            throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject)
            $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "../node_modules/ajv/lib/dotjs/if.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_if(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it.schema["then"];
          $it.schemaPath = it.schemaPath + ".then";
          $it.errSchemaPath = it.errSchemaPath + "/then";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it.schema["else"];
          $it.schemaPath = it.schemaPath + ".else";
          $it.errSchemaPath = it.errSchemaPath + "/else";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "../node_modules/ajv/lib/dotjs/items.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "../node_modules/ajv/lib/dotjs/_limit.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber)
              $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "../node_modules/ajv/lib/dotjs/_limitItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "../node_modules/ajv/lib/dotjs/_limitLength.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "../node_modules/ajv/lib/dotjs/_limitProperties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "../node_modules/ajv/lib/dotjs/multipleOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "../node_modules/ajv/lib/dotjs/not.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption)
          $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "../node_modules/ajv/lib/dotjs/oneOf.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "../node_modules/ajv/lib/dotjs/pattern.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "../node_modules/ajv/lib/dotjs/properties.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "../node_modules/ajv/lib/dotjs/propertyNames.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "../node_modules/ajv/lib/dotjs/required.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "../node_modules/ajv/lib/dotjs/uniqueItems.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "../node_modules/ajv/lib/dotjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate()
    };
  }
});

// ../node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS({
  "../node_modules/ajv/lib/compile/rules.js"(exports2, module2) {
    "use strict";
    var ruleModules = require_dotjs();
    var toHash = require_util().toHash;
    module2.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group.type)
          RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// ../node_modules/ajv/lib/data.js
var require_data = __commonJS({
  "../node_modules/ajv/lib/data.js"(exports2, module2) {
    "use strict";
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module2.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// ../node_modules/ajv/lib/compile/async.js
var require_async = __commonJS({
  "../node_modules/ajv/lib/compile/async.js"(exports2, module2) {
    "use strict";
    var MissingRefError = require_error_classes().MissingRef;
    module2.exports = compileAsync;
    function compileAsync(schema, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self2._addSchema(schema, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(
          function(v) {
            callback(null, v);
          },
          callback
        );
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError)
            return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref))
            throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref))
                  self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
        }
      }
    }
  }
});

// ../node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "../node_modules/ajv/lib/dotjs/custom.js"(exports2, module2) {
    "use strict";
    module2.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate)
          return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async)
        throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// ../node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "../node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// ../node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "../node_modules/ajv/lib/definition_schema.js"(exports2, module2) {
    "use strict";
    var metaSchema = require_json_schema_draft_07();
    module2.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// ../node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "../node_modules/ajv/lib/keyword.js"(exports2, module2) {
    "use strict";
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    var definitionSchema = require_definition_schema();
    module2.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition))
        return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
  }
});

// ../node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS({
  "../node_modules/ajv/lib/refs/data.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// ../node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "../node_modules/ajv/lib/ajv.js"(exports2, module2) {
    "use strict";
    var compileSchema = require_compile();
    var resolve = require_resolve();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats();
    var rules = require_rules();
    var $dataMetaSchema = require_data();
    var util = require_util();
    module2.exports = Ajv;
    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv))
        return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property")
        opts._errorDataPathProperty = true;
      if (opts.serialize === void 0)
        opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats)
        addInitialFormats(this);
      if (opts.keywords)
        addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      if (opts.nullable)
        this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async !== true)
        this.errors = v.errors;
      return valid;
    }
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++)
          this.addSchema(schema[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema, root, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj)
            this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != "object" && typeof schema != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached)
        return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema)
        checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);
      var localRefs = resolve.ids.call(this, schema);
      var schemaObj = new SchemaObject({
        id,
        schema,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema)
        this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta)
        this.validateSchema(schema, true);
      return schemaObj;
    }
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta)
          this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    function _getId(schema) {
      if (schema.$id)
        this.logger.warn("schema $id ignored", schema.$id);
      return schema.id;
    }
    function _get$Id(schema) {
      if (schema.id)
        this.logger.warn("schema id ignored", schema.id);
      return schema.$id;
    }
    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error("schema $id is different from id");
      return schema.$id || schema.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors)
        return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e)
          text += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDefaultMetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data2();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false)
        return;
      var metaSchema = require_json_schema_draft_07();
      if (self2._opts.$data)
        metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        self2.addSchema(optsSchemas);
      else
        for (var key in optsSchemas)
          self2.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self2) {
      for (var name in self2._opts.formats) {
        var format = self2._opts.formats[name];
        self2.addFormat(name, format);
      }
    }
    function addInitialKeywords(self2) {
      for (var name in self2._opts.keywords) {
        var keyword = self2._opts.keywords[name];
        self2.addKeyword(name, keyword);
      }
    }
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self2) {
      var metaOpts = util.copy(self2._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self2) {
      var logger2 = self2._opts.logger;
      if (logger2 === false) {
        self2.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger2 === void 0)
          logger2 = console;
        if (!(typeof logger2 == "object" && logger2.log && logger2.warn && logger2.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger2;
      }
    }
    function noop() {
    }
  }
});

// ../node_modules/protodef-validator/ProtoDef/schemas/definitions.json
var require_definitions = __commonJS({
  "../node_modules/protodef-validator/ProtoDef/schemas/definitions.json"(exports2, module2) {
    module2.exports = {
      title: "definitions",
      definitions: {
        contextualizedFieldName: {
          type: "string",
          pattern: "^(this\\.)?.+$"
        },
        dataTypeArgsCount: {
          oneOf: [
            {
              $ref: "#/definitions/contextualizedFieldName"
            },
            {
              type: "number"
            }
          ]
        },
        fieldName: {
          type: "string",
          pattern: "^[a-zA-Z0-9_]+$"
        }
      },
      type: "object"
    };
  }
});

// ../node_modules/protodef-validator/ProtoDef/schemas/protocol_schema.json
var require_protocol_schema = __commonJS({
  "../node_modules/protodef-validator/ProtoDef/schemas/protocol_schema.json"(exports2, module2) {
    module2.exports = {
      title: "protocol",
      type: "object",
      properties: {
        types: {
          type: "object",
          patternProperties: {
            "^[0-9a-zA-Z_]+$": {
              oneOf: [
                {
                  type: "string"
                },
                {
                  type: "array",
                  items: [
                    {
                      type: "string"
                    },
                    {
                      oneOf: [
                        {
                          type: "object"
                        },
                        {
                          type: "array"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          },
          additionalProperties: false
        }
      },
      patternProperties: {
        "^(?!types)[a-zA-Z_]+$": {
          $ref: "#"
        }
      },
      additionalProperties: false
    };
  }
});

// ../node_modules/protodef-validator/ProtoDef/schemas/numeric.json
var require_numeric = __commonJS({
  "../node_modules/protodef-validator/ProtoDef/schemas/numeric.json"(exports2, module2) {
    module2.exports = {
      i8: {
        enum: ["i8"]
      },
      u8: {
        enum: ["u8"]
      },
      i16: {
        enum: ["i16"]
      },
      u16: {
        enum: ["u16"]
      },
      i32: {
        enum: ["i32"]
      },
      u32: {
        enum: ["u32"]
      },
      f32: {
        enum: ["f32"]
      },
      f64: {
        enum: ["f64"]
      },
      li8: {
        enum: ["li8"]
      },
      lu8: {
        enum: ["lu8"]
      },
      li16: {
        enum: ["li16"]
      },
      lu16: {
        enum: ["lu16"]
      },
      li32: {
        enum: ["li32"]
      },
      lu32: {
        enum: ["lu32"]
      },
      lf32: {
        enum: ["lf32"]
      },
      lf64: {
        enum: ["lf64"]
      },
      i64: {
        enum: ["i64"]
      },
      li64: {
        enum: ["li64"]
      },
      u64: {
        enum: ["u64"]
      },
      lu64: {
        enum: ["lu64"]
      },
      varint: {
        enum: ["varint"]
      },
      int: {
        title: "int",
        type: "array",
        items: [
          {
            enum: ["int"]
          },
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                size: {
                  type: "number"
                }
              },
              required: ["size"],
              additionalProperties: false
            },
            additionalItems: false
          }
        ],
        additionalItems: false
      },
      lint: {
        title: "lint",
        type: "array",
        items: [
          {
            enum: ["lint"]
          },
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                size: {
                  type: "number"
                }
              },
              required: ["size"],
              additionalProperties: false
            },
            additionalItems: false
          }
        ],
        additionalItems: false
      }
    };
  }
});

// ../node_modules/protodef-validator/ProtoDef/schemas/utils.json
var require_utils2 = __commonJS({
  "../node_modules/protodef-validator/ProtoDef/schemas/utils.json"(exports2, module2) {
    module2.exports = {
      pstring: {
        title: "pstring",
        type: "array",
        items: [
          {
            enum: ["pstring"]
          },
          {
            oneOf: [
              {
                type: "object",
                properties: {
                  countType: {
                    $ref: "dataType"
                  }
                },
                additionalProperties: false,
                required: ["countType"]
              },
              {
                type: "object",
                properties: {
                  count: {
                    $ref: "definitions#/definitions/dataTypeArgsCount"
                  }
                },
                additionalProperties: false,
                required: ["count"]
              }
            ]
          }
        ],
        additionalItems: false
      },
      buffer: {
        title: "buffer",
        type: "array",
        items: [
          {
            enum: ["buffer"]
          },
          {
            oneOf: [
              {
                type: "object",
                properties: {
                  countType: {
                    $ref: "dataType"
                  }
                },
                additionalProperties: false,
                required: ["countType"]
              },
              {
                type: "object",
                properties: {
                  count: {
                    $ref: "definitions#/definitions/dataTypeArgsCount"
                  }
                },
                additionalProperties: false,
                required: ["count"]
              }
            ]
          }
        ]
      },
      bitfield: {
        title: "bitfield",
        type: "array",
        items: [
          {
            enum: ["bitfield"]
          },
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: {
                  $ref: "definitions#/definitions/fieldName"
                },
                size: {
                  type: "number"
                },
                signed: {
                  type: "boolean"
                }
              },
              required: ["name", "size", "signed"],
              additionalProperties: false
            },
            additionalItems: false
          }
        ],
        additionalItems: false
      },
      mapper: {
        title: "mapper",
        type: "array",
        items: [
          {
            enum: ["mapper"]
          },
          {
            type: "object",
            properties: {
              type: {
                $ref: "dataType"
              },
              mappings: {
                type: "object",
                patternProperties: {
                  "^[-a-zA-Z0-9 _]+$": {
                    type: "string"
                  }
                },
                additionalProperties: false
              }
            },
            required: ["type", "mappings"],
            additionalProperties: false
          }
        ],
        additionalItems: false
      }
    };
  }
});

// ../node_modules/protodef-validator/ProtoDef/schemas/structures.json
var require_structures = __commonJS({
  "../node_modules/protodef-validator/ProtoDef/schemas/structures.json"(exports2, module2) {
    module2.exports = {
      array: {
        title: "array",
        type: "array",
        items: [
          {
            enum: ["array"]
          },
          {
            oneOf: [
              {
                type: "object",
                properties: {
                  type: {
                    $ref: "dataType"
                  },
                  countType: {
                    $ref: "dataType"
                  }
                },
                additionalProperties: false,
                required: ["type", "countType"]
              },
              {
                type: "object",
                properties: {
                  type: {
                    $ref: "dataType"
                  },
                  count: {
                    $ref: "definitions#/definitions/dataTypeArgsCount"
                  }
                },
                additionalProperties: false,
                required: ["type", "count"]
              }
            ]
          }
        ],
        additionalItems: false
      },
      count: {
        title: "count",
        type: "array",
        items: [
          {
            enum: ["count"]
          },
          {
            type: "object",
            properties: {
              countFor: {
                $ref: "definitions#/definitions/contextualizedFieldName"
              },
              type: {
                $ref: "dataType"
              }
            },
            required: ["countFor", "type"],
            additionalProperties: false
          }
        ],
        additionalItems: false
      },
      container: {
        title: "container",
        type: "array",
        items: [
          {
            enum: ["container"]
          },
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                anon: {
                  type: "boolean"
                },
                name: {
                  $ref: "definitions#/definitions/fieldName"
                },
                type: {
                  $ref: "dataType"
                }
              },
              oneOf: [
                {
                  required: ["anon"]
                },
                {
                  required: ["name"]
                }
              ],
              required: ["type"],
              additionalProperties: false
            },
            additionalItems: false
          }
        ],
        additionalItems: false
      }
    };
  }
});

// ../node_modules/protodef-validator/ProtoDef/schemas/conditional.json
var require_conditional = __commonJS({
  "../node_modules/protodef-validator/ProtoDef/schemas/conditional.json"(exports2, module2) {
    module2.exports = {
      switch: {
        title: "switch",
        type: "array",
        items: [
          {
            enum: ["switch"]
          },
          {
            type: "object",
            properties: {
              compareTo: {
                $ref: "definitions#/definitions/contextualizedFieldName"
              },
              compareToValue: {
                type: "string"
              },
              fields: {
                type: "object",
                patternProperties: {
                  "^[-a-zA-Z0-9 _:/]+$": {
                    $ref: "dataType"
                  }
                },
                additionalProperties: false
              },
              default: {
                $ref: "dataType"
              }
            },
            oneOf: [
              {
                required: ["compareTo", "fields"]
              },
              {
                required: ["compareToValue", "fields"]
              }
            ],
            additionalProperties: false
          }
        ],
        additionalItems: false
      },
      option: {
        title: "option",
        type: "array",
        items: [
          {
            enum: ["option"]
          },
          {
            $ref: "dataType"
          }
        ],
        additionalItems: false
      }
    };
  }
});

// ../node_modules/protodef-validator/ProtoDef/schemas/primitives.json
var require_primitives = __commonJS({
  "../node_modules/protodef-validator/ProtoDef/schemas/primitives.json"(exports2, module2) {
    module2.exports = {
      bool: {
        enum: ["bool"]
      },
      cstring: {
        enum: ["cstring"]
      },
      void: {
        enum: ["void"]
      }
    };
  }
});

// ../node_modules/protodef-validator/index.js
var require_protodef_validator = __commonJS({
  "../node_modules/protodef-validator/index.js"(exports2, module2) {
    var Ajv = require_ajv();
    var assert = require("assert");
    var Validator = class {
      constructor(typesSchemas) {
        this.createAjvInstance(typesSchemas);
        this.addDefaultTypes();
      }
      createAjvInstance(typesSchemas) {
        this.typesSchemas = {};
        this.compiled = false;
        this.ajv = new Ajv({ verbose: true });
        this.ajv.addSchema(require_definitions(), "definitions");
        this.ajv.addSchema(require_protocol_schema(), "protocol");
        if (typesSchemas) {
          Object.keys(typesSchemas).forEach((s) => this.addType(s, typesSchemas[s]));
        }
      }
      addDefaultTypes() {
        this.addTypes(require_numeric());
        this.addTypes(require_utils2());
        this.addTypes(require_structures());
        this.addTypes(require_conditional());
        this.addTypes(require_primitives());
      }
      addTypes(schemas) {
        Object.keys(schemas).forEach((name) => this.addType(name, schemas[name]));
      }
      typeToSchemaName(name) {
        return name.replace("|", "_");
      }
      addType(name, schema) {
        const schemaName = this.typeToSchemaName(name);
        if (this.typesSchemas[schemaName] != void 0)
          return;
        if (!schema) {
          schema = {
            "oneOf": [
              { "enum": [name] },
              {
                "type": "array",
                "items": [
                  { "enum": [name] },
                  { "oneOf": [{ "type": "object" }, { "type": "array" }] }
                ]
              }
            ]
          };
        }
        this.typesSchemas[schemaName] = schema;
        if (this.compiled)
          this.createAjvInstance(this.typesSchemas);
        else {
          this.ajv.addSchema(schema, schemaName);
        }
        this.ajv.removeSchema("dataType");
        this.ajv.addSchema({
          "title": "dataType",
          "oneOf": [{ "enum": ["native"] }].concat(Object.keys(this.typesSchemas).map((name2) => ({ "$ref": this.typeToSchemaName(name2) })))
        }, "dataType");
      }
      validateType(type) {
        let valid = this.ajv.validate("dataType", type);
        this.compiled = true;
        if (!valid) {
          console.log(JSON.stringify(this.ajv.errors[0], null, 2));
          if (this.ajv.errors[0]["parentSchema"]["title"] == "dataType") {
            this.validateTypeGoingInside(this.ajv.errors[0]["data"]);
          }
          throw new Error("validation error");
        }
      }
      validateTypeGoingInside(type) {
        if (Array.isArray(type)) {
          assert.ok(this.typesSchemas[this.typeToSchemaName(type[0])] != void 0, type + " is an undefined type");
          let valid = this.ajv.validate(type[0], type);
          this.compiled = true;
          if (!valid) {
            console.log(JSON.stringify(this.ajv.errors[0], null, 2));
            if (this.ajv.errors[0]["parentSchema"]["title"] == "dataType") {
              this.validateTypeGoingInside(this.ajv.errors[0]["data"]);
            }
            throw new Error("validation error");
          }
        } else {
          if (type == "native")
            return;
          assert.ok(this.typesSchemas[this.typeToSchemaName(type)] != void 0, type + " is an undefined type");
        }
      }
      validateProtocol(protocol2) {
        let valid = this.ajv.validate("protocol", protocol2);
        assert.ok(valid, JSON.stringify(this.ajv.errors, null, 2));
        function validateTypes(p, originalValidator, path) {
          const v = new Validator(originalValidator.typesSchemas);
          Object.keys(p).forEach((k) => {
            if (k == "types") {
              Object.keys(p[k]).forEach((typeName) => v.addType(typeName));
              Object.keys(p[k]).forEach((typeName) => {
                try {
                  v.validateType(p[k][typeName], path + "." + k + "." + typeName);
                } catch (e) {
                  throw new Error("Error at " + path + "." + k + "." + typeName);
                }
              });
            } else {
              validateTypes(p[k], v, path + "." + k);
            }
          });
        }
        validateTypes(protocol2, this, "root");
      }
    };
    module2.exports = Validator;
  }
});

// ../node_modules/protodef/ProtoDef/schemas/numeric.json
var require_numeric2 = __commonJS({
  "../node_modules/protodef/ProtoDef/schemas/numeric.json"(exports2, module2) {
    module2.exports = {
      i8: {
        enum: ["i8"]
      },
      u8: {
        enum: ["u8"]
      },
      i16: {
        enum: ["i16"]
      },
      u16: {
        enum: ["u16"]
      },
      i32: {
        enum: ["i32"]
      },
      u32: {
        enum: ["u32"]
      },
      f32: {
        enum: ["f32"]
      },
      f64: {
        enum: ["f64"]
      },
      li8: {
        enum: ["li8"]
      },
      lu8: {
        enum: ["lu8"]
      },
      li16: {
        enum: ["li16"]
      },
      lu16: {
        enum: ["lu16"]
      },
      li32: {
        enum: ["li32"]
      },
      lu32: {
        enum: ["lu32"]
      },
      lf32: {
        enum: ["lf32"]
      },
      lf64: {
        enum: ["lf64"]
      },
      i64: {
        enum: ["i64"]
      },
      li64: {
        enum: ["li64"]
      },
      u64: {
        enum: ["u64"]
      },
      lu64: {
        enum: ["lu64"]
      },
      varint: {
        enum: ["varint"]
      },
      int: {
        title: "int",
        type: "array",
        items: [
          {
            enum: ["int"]
          },
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                size: {
                  type: "number"
                }
              },
              required: ["size"],
              additionalProperties: false
            },
            additionalItems: false
          }
        ],
        additionalItems: false
      },
      lint: {
        title: "lint",
        type: "array",
        items: [
          {
            enum: ["lint"]
          },
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                size: {
                  type: "number"
                }
              },
              required: ["size"],
              additionalProperties: false
            },
            additionalItems: false
          }
        ],
        additionalItems: false
      }
    };
  }
});

// ../node_modules/protodef/src/datatypes/numeric.js
var require_numeric3 = __commonJS({
  "../node_modules/protodef/src/datatypes/numeric.js"(exports2, module2) {
    var { PartialReadError: PartialReadError2 } = require_utils();
    var SignedBigInt = class extends Array {
      valueOf() {
        return BigInt.asIntN(64, BigInt(this[0]) << 32n) | BigInt.asUintN(32, BigInt(this[1]));
      }
      toString() {
        return this.valueOf().toString();
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.valueOf();
      }
    };
    var UnsignedBigInt = class extends Array {
      valueOf() {
        return BigInt.asUintN(64, BigInt(this[0]) << 32n) | BigInt.asUintN(32, BigInt(this[1]));
      }
      toString() {
        return this.valueOf().toString();
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.valueOf();
      }
    };
    function readI64(buffer, offset) {
      if (offset + 8 > buffer.length) {
        throw new PartialReadError2();
      }
      return {
        value: new SignedBigInt(buffer.readInt32BE(offset), buffer.readInt32BE(offset + 4)),
        size: 8
      };
    }
    function writeI64(value, buffer, offset) {
      if (typeof value === "bigint") {
        buffer.writeBigInt64BE(value, offset);
      } else {
        buffer.writeInt32BE(value[0], offset);
        buffer.writeInt32BE(value[1], offset + 4);
      }
      return offset + 8;
    }
    function readLI64(buffer, offset) {
      if (offset + 8 > buffer.length) {
        throw new PartialReadError2();
      }
      return {
        value: new SignedBigInt(buffer.readInt32LE(offset + 4), buffer.readInt32LE(offset)),
        size: 8
      };
    }
    function writeLI64(value, buffer, offset) {
      if (typeof value === "bigint") {
        buffer.writeBigInt64LE(value, offset);
      } else {
        buffer.writeInt32LE(value[0], offset + 4);
        buffer.writeInt32LE(value[1], offset);
      }
      return offset + 8;
    }
    function readU64(buffer, offset) {
      if (offset + 8 > buffer.length) {
        throw new PartialReadError2();
      }
      return {
        value: new UnsignedBigInt(buffer.readUInt32BE(offset), buffer.readUInt32BE(offset + 4)),
        size: 8
      };
    }
    function writeU64(value, buffer, offset) {
      if (typeof value === "bigint") {
        buffer.writeBigUInt64BE(value, offset);
      } else {
        buffer.writeUInt32BE(value[0], offset);
        buffer.writeUInt32BE(value[1], offset + 4);
      }
      return offset + 8;
    }
    function readLU64(buffer, offset) {
      if (offset + 8 > buffer.length) {
        throw new PartialReadError2();
      }
      return {
        value: new UnsignedBigInt(buffer.readUInt32LE(offset + 4), buffer.readUInt32LE(offset)),
        size: 8
      };
    }
    function writeLU64(value, buffer, offset) {
      if (typeof value === "bigint") {
        buffer.writeBigUInt64LE(value, offset);
      } else {
        buffer.writeUInt32LE(value[0], offset + 4);
        buffer.writeUInt32LE(value[1], offset);
      }
      return offset + 8;
    }
    function generateFunctions(bufferReader, bufferWriter, size, schema) {
      const reader = (buffer, offset) => {
        if (offset + size > buffer.length) {
          throw new PartialReadError2();
        }
        const value = buffer[bufferReader](offset);
        return {
          value,
          size
        };
      };
      const writer = (value, buffer, offset) => {
        buffer[bufferWriter](value, offset);
        return offset + size;
      };
      return [reader, writer, size, schema];
    }
    var nums = {
      i8: ["readInt8", "writeInt8", 1],
      u8: ["readUInt8", "writeUInt8", 1],
      i16: ["readInt16BE", "writeInt16BE", 2],
      u16: ["readUInt16BE", "writeUInt16BE", 2],
      i32: ["readInt32BE", "writeInt32BE", 4],
      u32: ["readUInt32BE", "writeUInt32BE", 4],
      f32: ["readFloatBE", "writeFloatBE", 4],
      f64: ["readDoubleBE", "writeDoubleBE", 8],
      li8: ["readInt8", "writeInt8", 1],
      lu8: ["readUInt8", "writeUInt8", 1],
      li16: ["readInt16LE", "writeInt16LE", 2],
      lu16: ["readUInt16LE", "writeUInt16LE", 2],
      li32: ["readInt32LE", "writeInt32LE", 4],
      lu32: ["readUInt32LE", "writeUInt32LE", 4],
      lf32: ["readFloatLE", "writeFloatLE", 4],
      lf64: ["readDoubleLE", "writeDoubleLE", 8]
    };
    var types = Object.keys(nums).reduce((types2, num) => {
      types2[num] = generateFunctions(nums[num][0], nums[num][1], nums[num][2], require_numeric2()[num]);
      return types2;
    }, {});
    types.i64 = [readI64, writeI64, 8, require_numeric2().i64];
    types.li64 = [readLI64, writeLI64, 8, require_numeric2().li64];
    types.u64 = [readU64, writeU64, 8, require_numeric2().u64];
    types.lu64 = [readLU64, writeLU64, 8, require_numeric2().lu64];
    module2.exports = types;
  }
});

// ../node_modules/protodef/ProtoDef/schemas/utils.json
var require_utils3 = __commonJS({
  "../node_modules/protodef/ProtoDef/schemas/utils.json"(exports2, module2) {
    module2.exports = {
      pstring: {
        title: "pstring",
        type: "array",
        items: [
          {
            enum: ["pstring"]
          },
          {
            oneOf: [
              {
                type: "object",
                properties: {
                  countType: {
                    $ref: "dataType"
                  },
                  encoding: {
                    type: "string"
                  }
                },
                additionalProperties: false,
                required: ["countType"]
              },
              {
                type: "object",
                properties: {
                  count: {
                    $ref: "definitions#/definitions/dataTypeArgsCount"
                  },
                  encoding: {
                    type: "string"
                  }
                },
                additionalProperties: false,
                required: ["count"]
              }
            ]
          }
        ],
        additionalItems: false
      },
      buffer: {
        title: "buffer",
        type: "array",
        items: [
          {
            enum: ["buffer"]
          },
          {
            oneOf: [
              {
                type: "object",
                properties: {
                  countType: {
                    $ref: "dataType"
                  }
                },
                additionalProperties: false,
                required: ["countType"]
              },
              {
                type: "object",
                properties: {
                  count: {
                    $ref: "definitions#/definitions/dataTypeArgsCount"
                  }
                },
                additionalProperties: false,
                required: ["count"]
              }
            ]
          }
        ]
      },
      bitfield: {
        title: "bitfield",
        type: "array",
        items: [
          {
            enum: ["bitfield"]
          },
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: {
                  $ref: "definitions#/definitions/fieldName"
                },
                size: {
                  type: "number"
                },
                signed: {
                  type: "boolean"
                }
              },
              required: ["name", "size", "signed"],
              additionalProperties: false
            },
            additionalItems: false
          }
        ],
        additionalItems: false
      },
      mapper: {
        title: "mapper",
        type: "array",
        items: [
          {
            enum: ["mapper"]
          },
          {
            type: "object",
            properties: {
              type: {
                $ref: "dataType"
              },
              mappings: {
                type: "object",
                patternProperties: {
                  "^[-a-zA-Z0-9 _]+$": {
                    type: "string"
                  }
                },
                additionalProperties: false
              }
            },
            required: ["type", "mappings"],
            additionalProperties: false
          }
        ],
        additionalItems: false
      }
    };
  }
});

// ../node_modules/protodef/src/datatypes/utils.js
var require_utils4 = __commonJS({
  "../node_modules/protodef/src/datatypes/utils.js"(exports2, module2) {
    var assert = require("assert");
    var { getCount, sendCount, calcCount, PartialReadError: PartialReadError2 } = require_utils();
    module2.exports = {
      varint: [readVarInt, writeVarInt, sizeOfVarInt, require_utils3().varint],
      bool: [readBool, writeBool, 1, require_utils3().bool],
      pstring: [readPString, writePString, sizeOfPString, require_utils3().pstring],
      buffer: [readBuffer, writeBuffer, sizeOfBuffer, require_utils3().buffer],
      void: [readVoid, writeVoid, 0, require_utils3().void],
      bitfield: [readBitField, writeBitField, sizeOfBitField, require_utils3().bitfield],
      cstring: [readCString, writeCString, sizeOfCString, require_utils3().cstring],
      mapper: [readMapper, writeMapper, sizeOfMapper, require_utils3().mapper]
    };
    function mapperEquality(a, b) {
      return a === b || parseInt(a) === parseInt(b);
    }
    function readMapper(buffer, offset, { type, mappings }, rootNode) {
      const { size, value } = this.read(buffer, offset, type, rootNode);
      let mappedValue = null;
      const keys = Object.keys(mappings);
      for (let i = 0; i < keys.length; i++) {
        if (mapperEquality(keys[i], value)) {
          mappedValue = mappings[keys[i]];
          break;
        }
      }
      if (mappedValue == null)
        throw new Error(value + " is not in the mappings value");
      return {
        size,
        value: mappedValue
      };
    }
    function writeMapper(value, buffer, offset, { type, mappings }, rootNode) {
      const keys = Object.keys(mappings);
      let mappedValue = null;
      for (let i = 0; i < keys.length; i++) {
        if (mapperEquality(mappings[keys[i]], value)) {
          mappedValue = keys[i];
          break;
        }
      }
      if (mappedValue == null)
        throw new Error(value + " is not in the mappings value");
      return this.write(mappedValue, buffer, offset, type, rootNode);
    }
    function sizeOfMapper(value, { type, mappings }, rootNode) {
      const keys = Object.keys(mappings);
      let mappedValue = null;
      for (let i = 0; i < keys.length; i++) {
        if (mapperEquality(mappings[keys[i]], value)) {
          mappedValue = keys[i];
          break;
        }
      }
      if (mappedValue == null)
        throw new Error(value + " is not in the mappings value");
      return this.sizeOf(mappedValue, type, rootNode);
    }
    function readVarInt(buffer, offset) {
      let result = 0;
      let shift = 0;
      let cursor = offset;
      while (true) {
        if (cursor + 1 > buffer.length) {
          throw new PartialReadError2();
        }
        const b = buffer.readUInt8(cursor);
        result |= (b & 127) << shift;
        cursor++;
        if (!(b & 128)) {
          return {
            value: result,
            size: cursor - offset
          };
        }
        shift += 7;
        assert.ok(shift < 64, "varint is too big");
      }
    }
    function sizeOfVarInt(value) {
      let cursor = 0;
      while (value & ~127) {
        value >>>= 7;
        cursor++;
      }
      return cursor + 1;
    }
    function writeVarInt(value, buffer, offset) {
      let cursor = 0;
      while (value & ~127) {
        buffer.writeUInt8(value & 255 | 128, offset + cursor);
        cursor++;
        value >>>= 7;
      }
      buffer.writeUInt8(value, offset + cursor);
      return offset + cursor + 1;
    }
    function readPString(buffer, offset, typeArgs, rootNode) {
      const { size, count } = getCount.call(this, buffer, offset, typeArgs, rootNode);
      const cursor = offset + size;
      const strEnd = cursor + count;
      if (strEnd > buffer.length) {
        throw new PartialReadError2("Missing characters in string, found size is " + buffer.length + " expected size was " + strEnd);
      }
      return {
        value: buffer.toString(typeArgs.encoding || "utf8", cursor, strEnd),
        size: strEnd - offset
      };
    }
    function writePString(value, buffer, offset, typeArgs, rootNode) {
      const length = Buffer.byteLength(value, "utf8");
      offset = sendCount.call(this, length, buffer, offset, typeArgs, rootNode);
      buffer.write(value, offset, length, typeArgs.encoding || "utf8");
      return offset + length;
    }
    function sizeOfPString(value, typeArgs, rootNode) {
      const length = Buffer.byteLength(value, typeArgs.encoding || "utf8");
      const size = calcCount.call(this, length, typeArgs, rootNode);
      return size + length;
    }
    function readBool(buffer, offset) {
      if (offset + 1 > buffer.length)
        throw new PartialReadError2();
      const value = buffer.readInt8(offset);
      return {
        value: !!value,
        size: 1
      };
    }
    function writeBool(value, buffer, offset) {
      buffer.writeInt8(+value, offset);
      return offset + 1;
    }
    function readBuffer(buffer, offset, typeArgs, rootNode) {
      const { size, count } = getCount.call(this, buffer, offset, typeArgs, rootNode);
      offset += size;
      if (offset + count > buffer.length)
        throw new PartialReadError2();
      return {
        value: buffer.slice(offset, offset + count),
        size: size + count
      };
    }
    function writeBuffer(value, buffer, offset, typeArgs, rootNode) {
      if (!(value instanceof Buffer))
        value = Buffer.from(value);
      offset = sendCount.call(this, value.length, buffer, offset, typeArgs, rootNode);
      value.copy(buffer, offset);
      return offset + value.length;
    }
    function sizeOfBuffer(value, typeArgs, rootNode) {
      if (!(value instanceof Buffer))
        value = Buffer.from(value);
      const size = calcCount.call(this, value.length, typeArgs, rootNode);
      return size + value.length;
    }
    function readVoid() {
      return {
        value: void 0,
        size: 0
      };
    }
    function writeVoid(value, buffer, offset) {
      return offset;
    }
    function generateBitMask(n) {
      return (1 << n) - 1;
    }
    function readBitField(buffer, offset, typeArgs) {
      const beginOffset = offset;
      let curVal = null;
      let bits = 0;
      const results = {};
      results.value = typeArgs.reduce((acc, { size, signed, name }) => {
        let currentSize = size;
        let val = 0;
        while (currentSize > 0) {
          if (bits === 0) {
            if (buffer.length < offset + 1) {
              throw new PartialReadError2();
            }
            curVal = buffer[offset++];
            bits = 8;
          }
          const bitsToRead = Math.min(currentSize, bits);
          val = val << bitsToRead | (curVal & generateBitMask(bits)) >> bits - bitsToRead;
          bits -= bitsToRead;
          currentSize -= bitsToRead;
        }
        if (signed && val >= 1 << size - 1) {
          val -= 1 << size;
        }
        acc[name] = val;
        return acc;
      }, {});
      results.size = offset - beginOffset;
      return results;
    }
    function writeBitField(value, buffer, offset, typeArgs) {
      let toWrite = 0;
      let bits = 0;
      typeArgs.forEach(({ size, signed, name }) => {
        const val = value[name];
        if (!signed && val < 0 || signed && val < -(1 << size - 1)) {
          throw new Error(value + " < " + signed ? -(1 << size - 1) : 0);
        } else if (!signed && val >= 1 << size || signed && val >= (1 << size - 1) - 1) {
          throw new Error(value + " >= " + signed ? 1 << size : (1 << size - 1) - 1);
        }
        while (size > 0) {
          const writeBits = Math.min(8 - bits, size);
          toWrite = toWrite << writeBits | val >> size - writeBits & generateBitMask(writeBits);
          size -= writeBits;
          bits += writeBits;
          if (bits === 8) {
            buffer[offset++] = toWrite;
            bits = 0;
            toWrite = 0;
          }
        }
      });
      if (bits !== 0) {
        buffer[offset++] = toWrite << 8 - bits;
      }
      return offset;
    }
    function sizeOfBitField(value, typeArgs) {
      return Math.ceil(typeArgs.reduce((acc, { size }) => {
        return acc + size;
      }, 0) / 8);
    }
    function readCString(buffer, offset, typeArgs) {
      let size = 0;
      while (offset + size < buffer.length && buffer[offset + size] !== 0) {
        size++;
      }
      if (buffer.length < offset + size + 1) {
        throw new PartialReadError2();
      }
      return {
        value: buffer.toString(typeArgs?.encoding || "utf8", offset, offset + size),
        size: size + 1
      };
    }
    function writeCString(value, buffer, offset, typeArgs) {
      const length = Buffer.byteLength(value, typeArgs?.encoding || "utf8");
      buffer.write(value, offset, length, typeArgs?.encoding || "utf8");
      offset += length;
      buffer.writeInt8(0, offset);
      return offset + 1;
    }
    function sizeOfCString(value) {
      const length = Buffer.byteLength(value, "utf8");
      return length + 1;
    }
  }
});

// ../node_modules/protodef/ProtoDef/schemas/structures.json
var require_structures2 = __commonJS({
  "../node_modules/protodef/ProtoDef/schemas/structures.json"(exports2, module2) {
    module2.exports = {
      array: {
        title: "array",
        type: "array",
        items: [
          {
            enum: ["array"]
          },
          {
            oneOf: [
              {
                type: "object",
                properties: {
                  type: {
                    $ref: "dataType"
                  },
                  countType: {
                    $ref: "dataType"
                  }
                },
                additionalProperties: false,
                required: ["type", "countType"]
              },
              {
                type: "object",
                properties: {
                  type: {
                    $ref: "dataType"
                  },
                  count: {
                    $ref: "definitions#/definitions/dataTypeArgsCount"
                  }
                },
                additionalProperties: false,
                required: ["type", "count"]
              }
            ]
          }
        ],
        additionalItems: false
      },
      count: {
        title: "count",
        type: "array",
        items: [
          {
            enum: ["count"]
          },
          {
            type: "object",
            properties: {
              countFor: {
                $ref: "definitions#/definitions/contextualizedFieldName"
              },
              type: {
                $ref: "dataType"
              }
            },
            required: ["countFor", "type"],
            additionalProperties: false
          }
        ],
        additionalItems: false
      },
      container: {
        title: "container",
        type: "array",
        items: [
          {
            enum: ["container"]
          },
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                anon: {
                  type: "boolean"
                },
                name: {
                  $ref: "definitions#/definitions/fieldName"
                },
                type: {
                  $ref: "dataType"
                }
              },
              oneOf: [
                {
                  required: ["anon"]
                },
                {
                  required: ["name"]
                }
              ],
              required: ["type"],
              additionalProperties: false
            },
            additionalItems: false
          }
        ],
        additionalItems: false
      }
    };
  }
});

// ../node_modules/protodef/src/datatypes/structures.js
var require_structures3 = __commonJS({
  "../node_modules/protodef/src/datatypes/structures.js"(exports2, module2) {
    var { getField, getCount, sendCount, calcCount, tryDoc } = require_utils();
    module2.exports = {
      array: [readArray, writeArray, sizeOfArray, require_structures2().array],
      count: [readCount, writeCount, sizeOfCount, require_structures2().count],
      container: [readContainer, writeContainer, sizeOfContainer, require_structures2().container]
    };
    function readArray(buffer, offset, typeArgs, rootNode) {
      const results = {
        value: [],
        size: 0
      };
      let value;
      let { count, size } = getCount.call(this, buffer, offset, typeArgs, rootNode);
      offset += size;
      results.size += size;
      for (let i = 0; i < count; i++) {
        ({ size, value } = tryDoc(() => this.read(buffer, offset, typeArgs.type, rootNode), i));
        results.size += size;
        offset += size;
        results.value.push(value);
      }
      return results;
    }
    function writeArray(value, buffer, offset, typeArgs, rootNode) {
      offset = sendCount.call(this, value.length, buffer, offset, typeArgs, rootNode);
      return value.reduce((offset2, v, index) => tryDoc(() => this.write(v, buffer, offset2, typeArgs.type, rootNode), index), offset);
    }
    function sizeOfArray(value, typeArgs, rootNode) {
      let size = calcCount.call(this, value.length, typeArgs, rootNode);
      size = value.reduce((size2, v, index) => tryDoc(() => size2 + this.sizeOf(v, typeArgs.type, rootNode), index), size);
      return size;
    }
    function readContainer(buffer, offset, typeArgs, context) {
      const results = {
        value: { "..": context },
        size: 0
      };
      typeArgs.forEach(({ type, name, anon }) => {
        tryDoc(() => {
          const readResults = this.read(buffer, offset, type, results.value);
          results.size += readResults.size;
          offset += readResults.size;
          if (anon) {
            if (readResults.value !== void 0) {
              Object.keys(readResults.value).forEach((key) => {
                results.value[key] = readResults.value[key];
              });
            }
          } else {
            results.value[name] = readResults.value;
          }
        }, name || "unknown");
      });
      delete results.value[".."];
      return results;
    }
    function writeContainer(value, buffer, offset, typeArgs, context) {
      value[".."] = context;
      offset = typeArgs.reduce((offset2, { type, name, anon }) => tryDoc(() => this.write(anon ? value : value[name], buffer, offset2, type, value), name || "unknown"), offset);
      delete value[".."];
      return offset;
    }
    function sizeOfContainer(value, typeArgs, context) {
      value[".."] = context;
      const size = typeArgs.reduce((size2, { type, name, anon }) => size2 + tryDoc(() => this.sizeOf(anon ? value : value[name], type, value), name || "unknown"), 0);
      delete value[".."];
      return size;
    }
    function readCount(buffer, offset, { type }, rootNode) {
      return this.read(buffer, offset, type, rootNode);
    }
    function writeCount(value, buffer, offset, { countFor, type }, rootNode) {
      return this.write(getField(countFor, rootNode).length, buffer, offset, type, rootNode);
    }
    function sizeOfCount(value, { countFor, type }, rootNode) {
      return this.sizeOf(getField(countFor, rootNode).length, type, rootNode);
    }
  }
});

// ../node_modules/protodef/ProtoDef/schemas/conditional.json
var require_conditional2 = __commonJS({
  "../node_modules/protodef/ProtoDef/schemas/conditional.json"(exports2, module2) {
    module2.exports = {
      switch: {
        title: "switch",
        type: "array",
        items: [
          {
            enum: ["switch"]
          },
          {
            type: "object",
            properties: {
              compareTo: {
                $ref: "definitions#/definitions/contextualizedFieldName"
              },
              compareToValue: {
                type: "string"
              },
              fields: {
                type: "object",
                patternProperties: {
                  "^[-a-zA-Z0-9 _:/]+$": {
                    $ref: "dataType"
                  }
                },
                additionalProperties: false
              },
              default: {
                $ref: "dataType"
              }
            },
            oneOf: [
              {
                required: ["compareTo", "fields"]
              },
              {
                required: ["compareToValue", "fields"]
              }
            ],
            additionalProperties: false
          }
        ],
        additionalItems: false
      },
      option: {
        title: "option",
        type: "array",
        items: [
          {
            enum: ["option"]
          },
          {
            $ref: "dataType"
          }
        ],
        additionalItems: false
      }
    };
  }
});

// ../node_modules/protodef/src/datatypes/conditional.js
var require_conditional3 = __commonJS({
  "../node_modules/protodef/src/datatypes/conditional.js"(exports2, module2) {
    var { getField, getFieldInfo, tryDoc, PartialReadError: PartialReadError2 } = require_utils();
    module2.exports = {
      switch: [readSwitch, writeSwitch, sizeOfSwitch, require_conditional2().switch],
      option: [readOption, writeOption, sizeOfOption, require_conditional2().option]
    };
    function readSwitch(buffer, offset, { compareTo, fields, compareToValue, default: defVal }, rootNode) {
      compareTo = compareToValue !== void 0 ? compareToValue : getField(compareTo, rootNode);
      if (typeof fields[compareTo] === "undefined" && typeof defVal === "undefined") {
        throw new Error(compareTo + " has no associated fieldInfo in switch");
      }
      for (const field in fields) {
        if (field.startsWith("/")) {
          fields[this.types[field.slice(1)]] = fields[field];
          delete fields[field];
        }
      }
      const caseDefault = typeof fields[compareTo] === "undefined";
      const resultingType = caseDefault ? defVal : fields[compareTo];
      const fieldInfo = getFieldInfo(resultingType);
      return tryDoc(() => this.read(buffer, offset, fieldInfo, rootNode), caseDefault ? "default" : compareTo);
    }
    function writeSwitch(value, buffer, offset, { compareTo, fields, compareToValue, default: defVal }, rootNode) {
      compareTo = compareToValue !== void 0 ? compareToValue : getField(compareTo, rootNode);
      if (typeof fields[compareTo] === "undefined" && typeof defVal === "undefined") {
        throw new Error(compareTo + " has no associated fieldInfo in switch");
      }
      for (const field in fields) {
        if (field.startsWith("/")) {
          fields[this.types[field.slice(1)]] = fields[field];
          delete fields[field];
        }
      }
      const caseDefault = typeof fields[compareTo] === "undefined";
      const fieldInfo = getFieldInfo(caseDefault ? defVal : fields[compareTo]);
      return tryDoc(() => this.write(value, buffer, offset, fieldInfo, rootNode), caseDefault ? "default" : compareTo);
    }
    function sizeOfSwitch(value, { compareTo, fields, compareToValue, default: defVal }, rootNode) {
      compareTo = compareToValue !== void 0 ? compareToValue : getField(compareTo, rootNode);
      if (typeof fields[compareTo] === "undefined" && typeof defVal === "undefined") {
        throw new Error(compareTo + " has no associated fieldInfo in switch");
      }
      for (const field in fields) {
        if (field.startsWith("/")) {
          fields[this.types[field.slice(1)]] = fields[field];
          delete fields[field];
        }
      }
      const caseDefault = typeof fields[compareTo] === "undefined";
      const fieldInfo = getFieldInfo(caseDefault ? defVal : fields[compareTo]);
      return tryDoc(() => this.sizeOf(value, fieldInfo, rootNode), caseDefault ? "default" : compareTo);
    }
    function readOption(buffer, offset, typeArgs, context) {
      if (buffer.length < offset + 1) {
        throw new PartialReadError2();
      }
      const val = buffer.readUInt8(offset++);
      if (val !== 0) {
        const retval = this.read(buffer, offset, typeArgs, context);
        retval.size++;
        return retval;
      } else {
        return { size: 1 };
      }
    }
    function writeOption(value, buffer, offset, typeArgs, context) {
      if (value != null) {
        buffer.writeUInt8(1, offset++);
        offset = this.write(value, buffer, offset, typeArgs, context);
      } else {
        buffer.writeUInt8(0, offset++);
      }
      return offset;
    }
    function sizeOfOption(value, typeArgs, context) {
      return value == null ? 1 : this.sizeOf(value, typeArgs, context) + 1;
    }
  }
});

// ../node_modules/protodef/src/protodef.js
var require_protodef = __commonJS({
  "../node_modules/protodef/src/protodef.js"(exports2, module2) {
    var { getFieldInfo, tryCatch: tryCatch2 } = require_utils();
    var reduce = require_lodash();
    var get = require_lodash2();
    var Validator = require_protodef_validator();
    function isFieldInfo(type) {
      return typeof type === "string" || Array.isArray(type) && typeof type[0] === "string" || type.type;
    }
    function findArgs(acc, v, k) {
      if (typeof v === "string" && v.charAt(0) === "$") {
        acc.push({ path: k, val: v.substr(1) });
      } else if (Array.isArray(v) || typeof v === "object") {
        acc = acc.concat(reduce(v, findArgs, []).map((v2) => ({ path: k + "." + v2.path, val: v2.val })));
      }
      return acc;
    }
    function setField(path, val, into) {
      const c = path.split(".").reverse();
      while (c.length > 1) {
        into = into[c.pop()];
      }
      into[c.pop()] = val;
    }
    function extendType(functions, defaultTypeArgs) {
      const json = JSON.stringify(defaultTypeArgs);
      const argPos = reduce(defaultTypeArgs, findArgs, []);
      function produceArgs(typeArgs) {
        const args = JSON.parse(json);
        argPos.forEach((v) => {
          setField(v.path, typeArgs[v.val], args);
        });
        return args;
      }
      return [function read(buffer, offset, typeArgs, context) {
        return functions[0].call(this, buffer, offset, produceArgs(typeArgs), context);
      }, function write(value, buffer, offset, typeArgs, context) {
        return functions[1].call(this, value, buffer, offset, produceArgs(typeArgs), context);
      }, function sizeOf(value, typeArgs, context) {
        if (typeof functions[2] === "function") {
          return functions[2].call(this, value, produceArgs(typeArgs), context);
        } else {
          return functions[2];
        }
      }];
    }
    var ProtoDef = class {
      constructor(validation = true) {
        this.types = {};
        this.validator = validation ? new Validator() : null;
        this.addDefaultTypes();
      }
      addDefaultTypes() {
        this.addTypes(require_numeric3());
        this.addTypes(require_utils4());
        this.addTypes(require_structures3());
        this.addTypes(require_conditional3());
      }
      addProtocol(protocolData, path) {
        const self2 = this;
        function recursiveAddTypes(protocolData2, path2) {
          if (protocolData2 === void 0) {
            return;
          }
          if (protocolData2.types) {
            self2.addTypes(protocolData2.types);
          }
          recursiveAddTypes(get(protocolData2, path2.shift()), path2);
        }
        if (this.validator) {
          this.validator.validateProtocol(protocolData);
        }
        recursiveAddTypes(protocolData, path);
      }
      addType(name, functions, validate = true) {
        if (functions === "native") {
          if (this.validator) {
            this.validator.addType(name);
          }
          return;
        }
        if (isFieldInfo(functions)) {
          if (this.validator) {
            if (validate) {
              this.validator.validateType(functions);
            }
            this.validator.addType(name);
          }
          const { type, typeArgs } = getFieldInfo(functions);
          this.types[name] = typeArgs ? extendType(this.types[type], typeArgs) : this.types[type];
        } else {
          if (this.validator) {
            if (functions[3]) {
              this.validator.addType(name, functions[3]);
            } else {
              this.validator.addType(name);
            }
          }
          this.types[name] = functions;
        }
      }
      addTypes(types) {
        Object.keys(types).forEach((name) => this.addType(name, types[name], false));
        if (this.validator) {
          Object.keys(types).forEach((name) => {
            if (isFieldInfo(types[name])) {
              this.validator.validateType(types[name]);
            }
          });
        }
      }
      setVariable(key, val) {
        this.types[key] = val;
      }
      read(buffer, cursor, _fieldInfo, rootNodes) {
        const { type, typeArgs } = getFieldInfo(_fieldInfo);
        const typeFunctions = this.types[type];
        if (!typeFunctions) {
          throw new Error("missing data type: " + type);
        }
        return typeFunctions[0].call(this, buffer, cursor, typeArgs, rootNodes);
      }
      write(value, buffer, offset, _fieldInfo, rootNode) {
        const { type, typeArgs } = getFieldInfo(_fieldInfo);
        const typeFunctions = this.types[type];
        if (!typeFunctions) {
          throw new Error("missing data type: " + type);
        }
        return typeFunctions[1].call(this, value, buffer, offset, typeArgs, rootNode);
      }
      sizeOf(value, _fieldInfo, rootNode) {
        const { type, typeArgs } = getFieldInfo(_fieldInfo);
        const typeFunctions = this.types[type];
        if (!typeFunctions) {
          throw new Error("missing data type: " + type);
        }
        if (typeof typeFunctions[2] === "function") {
          return typeFunctions[2].call(this, value, typeArgs, rootNode);
        } else {
          return typeFunctions[2];
        }
      }
      createPacketBuffer(type, packet) {
        const length = tryCatch2(
          () => this.sizeOf(packet, type, {}),
          (e) => {
            e.message = `SizeOf error for ${e.field} : ${e.message}`;
            throw e;
          }
        );
        const buffer = Buffer.allocUnsafe(length);
        tryCatch2(
          () => this.write(packet, buffer, 0, type, {}),
          (e) => {
            e.message = `Write error for ${e.field} : ${e.message}`;
            throw e;
          }
        );
        return buffer;
      }
      parsePacketBuffer(type, buffer, offset = 0) {
        const { value, size } = tryCatch2(
          () => this.read(buffer, offset, type, {}),
          (e) => {
            e.message = `Read error for ${e.field} : ${e.message}`;
            throw e;
          }
        );
        return {
          data: value,
          metadata: {
            size
          },
          buffer: buffer.slice(0, size),
          fullBuffer: buffer
        };
      }
    };
    module2.exports = ProtoDef;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../node_modules/readable-stream/errors.js
var require_errors = __commonJS({
  "../node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code2, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code2;
      codes[code2] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../node_modules/util-deprecate/node.js
var require_node2 = __commonJS({
  "../node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// ../node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node2()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "../node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// ../node_modules/protodef/src/serializer.js
var require_serializer = __commonJS({
  "../node_modules/protodef/src/serializer.js"(exports2, module2) {
    var Transform = require_readable().Transform;
    var Serializer = class extends Transform {
      constructor(proto, mainType) {
        super({ writableObjectMode: true });
        this.proto = proto;
        this.mainType = mainType;
        this.queue = Buffer.alloc(0);
      }
      createPacketBuffer(packet) {
        return this.proto.createPacketBuffer(this.mainType, packet);
      }
      _transform(chunk, enc, cb) {
        let buf;
        try {
          buf = this.createPacketBuffer(chunk);
        } catch (e) {
          return cb(e);
        }
        this.push(buf);
        return cb();
      }
    };
    var Parser = class extends Transform {
      constructor(proto, mainType) {
        super({ readableObjectMode: true });
        this.proto = proto;
        this.mainType = mainType;
        this.queue = Buffer.alloc(0);
      }
      parsePacketBuffer(buffer) {
        return this.proto.parsePacketBuffer(this.mainType, buffer);
      }
      _transform(chunk, enc, cb) {
        this.queue = Buffer.concat([this.queue, chunk]);
        while (true) {
          let packet;
          try {
            packet = this.parsePacketBuffer(this.queue);
          } catch (e) {
            if (e.partialReadError) {
              return cb();
            } else {
              e.buffer = this.queue;
              this.queue = Buffer.alloc(0);
              return cb(e);
            }
          }
          this.push(packet);
          this.queue = this.queue.slice(packet.metadata.size);
        }
      }
    };
    var FullPacketParser = class extends Transform {
      constructor(proto, mainType, noErrorLogging = false) {
        super({ readableObjectMode: true });
        this.proto = proto;
        this.mainType = mainType;
        this.noErrorLogging = noErrorLogging;
      }
      parsePacketBuffer(buffer) {
        return this.proto.parsePacketBuffer(this.mainType, buffer);
      }
      _transform(chunk, enc, cb) {
        let packet;
        try {
          packet = this.parsePacketBuffer(chunk);
          if (packet.metadata.size !== chunk.length && !this.noErrorLogging) {
            console.log("Chunk size is " + chunk.length + " but only " + packet.metadata.size + " was read ; partial packet : " + JSON.stringify(packet.data) + "; buffer :" + chunk.toString("hex"));
          }
        } catch (e) {
          if (e.partialReadError) {
            if (!this.noErrorLogging) {
              console.log(e.stack);
            }
            return cb();
          } else {
            return cb(e);
          }
        }
        this.push(packet);
        cb();
      }
    };
    module2.exports = {
      Serializer,
      Parser,
      FullPacketParser
    };
  }
});

// ../node_modules/protodef/src/datatypes/compiler-conditional.js
var require_compiler_conditional = __commonJS({
  "../node_modules/protodef/src/datatypes/compiler-conditional.js"(exports2, module2) {
    module2.exports = {
      Read: {
        switch: ["parametrizable", (compiler, struct) => {
          let compare = struct.compareTo ? struct.compareTo : struct.compareToValue;
          const args = [];
          if (compare.startsWith("$"))
            args.push(compare);
          else if (struct.compareTo) {
            compare = compiler.getField(compare);
          }
          let code2 = `switch (${compare}) {
`;
          for (const key in struct.fields) {
            let val = key;
            if (val.startsWith("/"))
              val = "ctx." + val.slice(1);
            else if (isNaN(val) && val !== "true" && val !== "false")
              val = `"${val}"`;
            code2 += compiler.indent(`case ${val}: return ` + compiler.callType(struct.fields[key])) + "\n";
          }
          code2 += compiler.indent("default: return " + compiler.callType(struct.default ? struct.default : "void")) + "\n";
          code2 += "}";
          return compiler.wrapCode(code2, args);
        }],
        option: ["parametrizable", (compiler, type) => {
          let code2 = "const {value} = ctx.bool(buffer, offset)\n";
          code2 += "if (value) {\n";
          code2 += "  const { value, size } = " + compiler.callType(type, "offset + 1") + "\n";
          code2 += "  return { value, size: size + 1 }\n";
          code2 += "}\n";
          code2 += "return { value: undefined, size: 1}";
          return compiler.wrapCode(code2);
        }]
      },
      Write: {
        switch: ["parametrizable", (compiler, struct) => {
          let compare = struct.compareTo ? struct.compareTo : struct.compareToValue;
          const args = [];
          if (compare.startsWith("$"))
            args.push(compare);
          else if (struct.compareTo) {
            compare = compiler.getField(compare);
          }
          let code2 = `switch (${compare}) {
`;
          for (const key in struct.fields) {
            let val = key;
            if (val.startsWith("/"))
              val = "ctx." + val.slice(1);
            else if (isNaN(val) && val !== "true" && val !== "false")
              val = `"${val}"`;
            code2 += compiler.indent(`case ${val}: return ` + compiler.callType("value", struct.fields[key])) + "\n";
          }
          code2 += compiler.indent("default: return " + compiler.callType("value", struct.default ? struct.default : "void")) + "\n";
          code2 += "}";
          return compiler.wrapCode(code2, args);
        }],
        option: ["parametrizable", (compiler, type) => {
          let code2 = "if (value != null) {\n";
          code2 += "  offset = ctx.bool(1, buffer, offset)\n";
          code2 += "  offset = " + compiler.callType("value", type) + "\n";
          code2 += "} else {\n";
          code2 += "  offset = ctx.bool(0, buffer, offset)\n";
          code2 += "}\n";
          code2 += "return offset";
          return compiler.wrapCode(code2);
        }]
      },
      SizeOf: {
        switch: ["parametrizable", (compiler, struct) => {
          let compare = struct.compareTo ? struct.compareTo : struct.compareToValue;
          const args = [];
          if (compare.startsWith("$"))
            args.push(compare);
          else if (struct.compareTo) {
            compare = compiler.getField(compare);
          }
          let code2 = `switch (${compare}) {
`;
          for (const key in struct.fields) {
            let val = key;
            if (val.startsWith("/"))
              val = "ctx." + val.slice(1);
            else if (isNaN(val) && val !== "true" && val !== "false")
              val = `"${val}"`;
            code2 += compiler.indent(`case ${val}: return ` + compiler.callType("value", struct.fields[key])) + "\n";
          }
          code2 += compiler.indent("default: return " + compiler.callType("value", struct.default ? struct.default : "void")) + "\n";
          code2 += "}";
          return compiler.wrapCode(code2, args);
        }],
        option: ["parametrizable", (compiler, type) => {
          let code2 = "if (value != null) {\n";
          code2 += "  return 1 + " + compiler.callType("value", type) + "\n";
          code2 += "}\n";
          code2 += "return 1";
          return compiler.wrapCode(code2);
        }]
      }
    };
  }
});

// ../node_modules/protodef/src/datatypes/compiler-structures.js
var require_compiler_structures = __commonJS({
  "../node_modules/protodef/src/datatypes/compiler-structures.js"(exports2, module2) {
    module2.exports = {
      Read: {
        array: ["parametrizable", (compiler, array) => {
          let code2 = "";
          if (array.countType) {
            code2 += "const { value: count, size: countSize } = " + compiler.callType(array.countType) + "\n";
          } else if (array.count) {
            code2 += "const count = " + array.count + "\n";
            code2 += "const countSize = 0\n";
          } else {
            throw new Error("Array must contain either count or countType");
          }
          code2 += 'if (count > 0xffffff) throw new Error("array size is abnormally large, not reading: " + count)\n';
          code2 += "const data = []\n";
          code2 += "let size = countSize\n";
          code2 += "for (let i = 0; i < count; i++) {\n";
          code2 += "  const elem = " + compiler.callType(array.type, "offset + size") + "\n";
          code2 += "  data.push(elem.value)\n";
          code2 += "  size += elem.size\n";
          code2 += "}\n";
          code2 += "return { value: data, size }";
          return compiler.wrapCode(code2);
        }],
        count: ["parametrizable", (compiler, type) => {
          const code2 = "return " + compiler.callType(type.type);
          return compiler.wrapCode(code2);
        }],
        container: ["parametrizable", (compiler, values) => {
          values = containerInlining(values);
          let code2 = "";
          let offsetExpr = "offset";
          const names = [];
          for (const i in values) {
            const { type, name, anon } = values[i];
            let trueName;
            let sizeName;
            if (type instanceof Array && type[0] === "bitfield" && anon) {
              const subnames = [];
              for (const { name: name2 } of type[1]) {
                const trueName2 = compiler.getField(name2);
                if (name2 === trueName2) {
                  names.push(name2);
                  subnames.push(name2);
                } else {
                  names.push(`${name2}: ${trueName2}`);
                  subnames.push(`${name2}: ${trueName2}`);
                }
              }
              trueName = "{" + subnames.join(", ") + "}";
              sizeName = `anon${i}Size`;
            } else {
              trueName = compiler.getField(name);
              sizeName = `${trueName}Size`;
              if (name === trueName)
                names.push(name);
              else
                names.push(`${name}: ${trueName}`);
            }
            code2 += `let { value: ${trueName}, size: ${sizeName} } = ` + compiler.callType(type, offsetExpr) + "\n";
            offsetExpr += ` + ${sizeName}`;
          }
          const sizes = offsetExpr.split(" + ");
          sizes.shift();
          if (sizes.length === 0)
            sizes.push("0");
          code2 += "return { value: { " + names.join(", ") + " }, size: " + sizes.join(" + ") + "}";
          return compiler.wrapCode(code2);
        }]
      },
      Write: {
        array: ["parametrizable", (compiler, array) => {
          let code2 = "";
          if (array.countType) {
            code2 += "offset = " + compiler.callType("value.length", array.countType) + "\n";
          } else if (array.count === null) {
            throw new Error("Array must contain either count or countType");
          }
          code2 += "for (let i = 0; i < value.length; i++) {\n";
          code2 += "  offset = " + compiler.callType("value[i]", array.type) + "\n";
          code2 += "}\n";
          code2 += "return offset";
          return compiler.wrapCode(code2);
        }],
        count: ["parametrizable", (compiler, type) => {
          const code2 = "return " + compiler.callType("value", type.type);
          return compiler.wrapCode(code2);
        }],
        container: ["parametrizable", (compiler, values) => {
          values = containerInlining(values);
          let code2 = "";
          for (const i in values) {
            const { type, name, anon } = values[i];
            let trueName;
            if (type instanceof Array && type[0] === "bitfield" && anon) {
              const names = [];
              for (const { name: name2 } of type[1]) {
                const trueName2 = compiler.getField(name2);
                code2 += `const ${trueName2} = value.${name2}
`;
                if (name2 === trueName2)
                  names.push(name2);
                else
                  names.push(`${name2}: ${trueName2}`);
              }
              trueName = "{" + names.join(", ") + "}";
            } else {
              trueName = compiler.getField(name);
              code2 += `let ${trueName} = value.${name}
`;
            }
            code2 += "offset = " + compiler.callType(trueName, type) + "\n";
          }
          code2 += "return offset";
          return compiler.wrapCode(code2);
        }]
      },
      SizeOf: {
        array: ["parametrizable", (compiler, array) => {
          let code2 = "";
          if (array.countType) {
            code2 += "let size = " + compiler.callType("value.length", array.countType) + "\n";
          } else if (array.count) {
            code2 += "let size = 0\n";
          } else {
            throw new Error("Array must contain either count or countType");
          }
          if (!isNaN(compiler.callType("value[i]", array.type))) {
            code2 += "size += value.length * " + compiler.callType("value[i]", array.type) + "\n";
          } else {
            code2 += "for (let i = 0; i < value.length; i++) {\n";
            code2 += "  size += " + compiler.callType("value[i]", array.type) + "\n";
            code2 += "}\n";
          }
          code2 += "return size";
          return compiler.wrapCode(code2);
        }],
        count: ["parametrizable", (compiler, type) => {
          const code2 = "return " + compiler.callType("value", type.type);
          return compiler.wrapCode(code2);
        }],
        container: ["parametrizable", (compiler, values) => {
          values = containerInlining(values);
          let code2 = "let size = 0\n";
          for (const i in values) {
            const { type, name, anon } = values[i];
            let trueName;
            if (type instanceof Array && type[0] === "bitfield" && anon) {
              const names = [];
              for (const { name: name2 } of type[1]) {
                const trueName2 = compiler.getField(name2);
                code2 += `const ${trueName2} = value.${name2}
`;
                if (name2 === trueName2)
                  names.push(name2);
                else
                  names.push(`${name2}: ${trueName2}`);
              }
              trueName = "{" + names.join(", ") + "}";
            } else {
              trueName = compiler.getField(name);
              code2 += `let ${trueName} = value.${name}
`;
            }
            code2 += "size += " + compiler.callType(trueName, type) + "\n";
          }
          code2 += "return size";
          return compiler.wrapCode(code2);
        }]
      }
    };
    function containerInlining(values) {
      const newValues = [];
      for (const i in values) {
        const { type, anon } = values[i];
        if (anon && !(type instanceof Array && type[0] === "bitfield")) {
          if (type instanceof Array && type[0] === "container") {
            for (const j in type[1])
              newValues.push(type[1][j]);
          } else if (type instanceof Array && type[0] === "switch") {
            const theSwitch = type[1];
            const valueSet = /* @__PURE__ */ new Set();
            for (const field in theSwitch.fields) {
              if (theSwitch.fields[field] instanceof Array && theSwitch.fields[field][0] === "container") {
                for (const j in theSwitch.fields[field][1]) {
                  const item = theSwitch.fields[field][1][j];
                  valueSet.add(item.name);
                }
              }
            }
            if (theSwitch.default instanceof Array && theSwitch.default[0] === "container") {
              for (const j in theSwitch.default[1]) {
                const item = theSwitch.default[1][j];
                valueSet.add(item.name);
              }
            }
            for (const name of valueSet.keys()) {
              const fields = {};
              let theDefault = theSwitch.default;
              if (theDefault instanceof Array && theDefault[0] === "container") {
                for (const j in theDefault[1]) {
                  const item = theDefault[1][j];
                  if (item.name === name) {
                    theDefault = item.type;
                    break;
                  }
                }
              }
              for (const field in theSwitch.fields) {
                if (theSwitch.fields[field] instanceof Array && theSwitch.fields[field][0] === "container") {
                  for (const j in theSwitch.fields[field][1]) {
                    const item = theSwitch.fields[field][1][j];
                    if (item.name === name) {
                      fields[field] = theSwitch.fields[field][1][j].type;
                      break;
                    }
                  }
                } else {
                  fields[field] = theSwitch.fields[field];
                }
              }
              if (!theDefault) {
                theDefault = "void";
              }
              newValues.push({
                name,
                type: ["switch", {
                  compareTo: theSwitch.compareTo,
                  compareToValue: theSwitch.compareToValue,
                  default: theDefault,
                  fields
                }]
              });
            }
          } else {
            throw new Error("Cannot inline anonymous type: " + type);
          }
        } else {
          newValues.push(values[i]);
        }
      }
      return newValues;
    }
  }
});

// ../node_modules/protodef/src/datatypes/compiler-utils.js
var require_compiler_utils = __commonJS({
  "../node_modules/protodef/src/datatypes/compiler-utils.js"(exports2, module2) {
    module2.exports = {
      Read: {
        pstring: ["parametrizable", (compiler, string) => {
          let code2 = "";
          if (string.countType) {
            code2 += "const { value: count, size: countSize } = " + compiler.callType(string.countType) + "\n";
          } else if (string.count) {
            code2 += "const count = " + string.count + "\n";
            code2 += "const countSize = 0\n";
          } else {
            throw new Error("pstring must contain either count or countType");
          }
          code2 += "offset += countSize\n";
          code2 += "if (offset + count > buffer.length) {\n";
          code2 += '  throw new PartialReadError("Missing characters in string, found size is " + buffer.length + " expected size was " + (offset + count))\n';
          code2 += "}\n";
          code2 += `return { value: buffer.toString("${string.encoding || "utf8"}", offset, offset + count), size: count + countSize }`;
          return compiler.wrapCode(code2);
        }],
        buffer: ["parametrizable", (compiler, buffer) => {
          let code2 = "";
          if (buffer.countType) {
            code2 += "const { value: count, size: countSize } = " + compiler.callType(buffer.countType) + "\n";
          } else if (buffer.count) {
            code2 += "const count = " + buffer.count + "\n";
            code2 += "const countSize = 0\n";
          } else {
            throw new Error("buffer must contain either count or countType");
          }
          code2 += "offset += countSize\n";
          code2 += "if (offset + count > buffer.length) {\n";
          code2 += "  throw new PartialReadError()\n";
          code2 += "}\n";
          code2 += "return { value: buffer.slice(offset, offset + count), size: count + countSize }";
          return compiler.wrapCode(code2);
        }],
        bitfield: ["parametrizable", (compiler, values) => {
          let code2 = "";
          const totalBytes = Math.ceil(values.reduce((acc, { size }) => acc + size, 0) / 8);
          code2 += `if ( offset + ${totalBytes} > buffer.length) { throw new PartialReadError() }
`;
          const names = [];
          let totalSize = 8;
          code2 += "let bits = buffer[offset++]\n";
          for (const i in values) {
            const { name, size, signed } = values[i];
            const trueName = compiler.getField(name);
            while (totalSize < size) {
              totalSize += 8;
              code2 += "bits = (bits << 8) | buffer[offset++]\n";
            }
            code2 += `let ${trueName} = (bits >> ` + (totalSize - size) + ") & 0x" + ((1 << size) - 1).toString(16) + "\n";
            if (signed)
              code2 += `${trueName} -= (${trueName} & 0x` + (1 << size - 1).toString(16) + ") << 1\n";
            totalSize -= size;
            if (name === trueName)
              names.push(name);
            else
              names.push(`${name}: ${trueName}`);
          }
          code2 += "return { value: { " + names.join(", ") + ` }, size: ${totalBytes} }`;
          return compiler.wrapCode(code2);
        }],
        mapper: ["parametrizable", (compiler, mapper) => {
          let code2 = "const { value, size } = " + compiler.callType(mapper.type) + "\n";
          code2 += "return { value: " + JSON.stringify(sanitizeMappings(mapper.mappings)) + "[value] || value, size }";
          return compiler.wrapCode(code2);
        }]
      },
      Write: {
        pstring: ["parametrizable", (compiler, string) => {
          let code2 = `const length = Buffer.byteLength(value, "${string.encoding || "utf8"}")
`;
          if (string.countType) {
            code2 += "offset = " + compiler.callType("length", string.countType) + "\n";
          } else if (string.count === null) {
            throw new Error("pstring must contain either count or countType");
          }
          code2 += `buffer.write(value, offset, length, "${string.encoding || "utf8"}")
`;
          code2 += "return offset + length";
          return compiler.wrapCode(code2);
        }],
        buffer: ["parametrizable", (compiler, buffer) => {
          let code2 = "if (!(value instanceof Buffer)) value = Buffer.from(value)\n";
          if (buffer.countType) {
            code2 += "offset = " + compiler.callType("value.length", buffer.countType) + "\n";
          } else if (buffer.count === null) {
            throw new Error("buffer must contain either count or countType");
          }
          code2 += "value.copy(buffer, offset)\n";
          code2 += "return offset + value.length";
          return compiler.wrapCode(code2);
        }],
        bitfield: ["parametrizable", (compiler, values) => {
          let toWrite = "";
          let bits = 0;
          let code2 = "";
          for (const i in values) {
            let { name, size } = values[i];
            const trueName = compiler.getField(name);
            code2 += `let ${trueName} = value.${name}
`;
            while (size > 0) {
              const writeBits = Math.min(8 - bits, size);
              const mask = (1 << writeBits) - 1;
              if (toWrite !== "")
                toWrite = `((${toWrite}) << ${writeBits}) | `;
              toWrite += `((${trueName} >> ` + (size - writeBits) + ") & 0x" + mask.toString(16) + ")";
              size -= writeBits;
              bits += writeBits;
              if (bits === 8) {
                code2 += "buffer[offset++] = " + toWrite + "\n";
                bits = 0;
                toWrite = "";
              }
            }
          }
          if (bits !== 0) {
            code2 += "buffer[offset++] = (" + toWrite + ") << " + (8 - bits) + "\n";
          }
          code2 += "return offset";
          return compiler.wrapCode(code2);
        }],
        mapper: ["parametrizable", (compiler, mapper) => {
          const mappings = JSON.stringify(swapMappings(mapper.mappings));
          const code2 = "return " + compiler.callType(`${mappings}[value] || value`, mapper.type);
          return compiler.wrapCode(code2);
        }]
      },
      SizeOf: {
        pstring: ["parametrizable", (compiler, string) => {
          let code2 = `let size = Buffer.byteLength(value, "${string.encoding || "utf8"}")
`;
          if (string.countType) {
            code2 += "size += " + compiler.callType("size", string.countType) + "\n";
          } else if (string.count === null) {
            throw new Error("pstring must contain either count or countType");
          }
          code2 += "return size";
          return compiler.wrapCode(code2);
        }],
        buffer: ["parametrizable", (compiler, buffer) => {
          let code2 = "let size = value instanceof Buffer ? value.length : Buffer.from(value).length\n";
          if (buffer.countType) {
            code2 += "size += " + compiler.callType("size", buffer.countType) + "\n";
          } else if (buffer.count === null) {
            throw new Error("buffer must contain either count or countType");
          }
          code2 += "return size";
          return compiler.wrapCode(code2);
        }],
        bitfield: ["parametrizable", (compiler, values) => {
          const totalBytes = Math.ceil(values.reduce((acc, { size }) => acc + size, 0) / 8);
          return `${totalBytes}`;
        }],
        mapper: ["parametrizable", (compiler, mapper) => {
          const mappings = JSON.stringify(swapMappings(mapper.mappings));
          const code2 = "return " + compiler.callType(`${mappings}[value] || value`, mapper.type);
          return compiler.wrapCode(code2);
        }]
      }
    };
    function sanitizeMappings(json) {
      const ret = {};
      for (let key in json) {
        let val = json[key];
        key = hex2dec(key);
        if (!isNaN(val))
          val = Number(val);
        if (val === "true")
          val = true;
        if (val === "false")
          val = false;
        ret[key] = val;
      }
      return ret;
    }
    function swapMappings(json) {
      const ret = {};
      for (let key in json) {
        const val = json[key];
        key = hex2dec(key);
        ret[val] = isNaN(key) ? key : parseInt(key, 10);
      }
      return ret;
    }
    function hex2dec(num) {
      if (num.match(/^0x[0-9a-f]+$/i)) {
        return parseInt(num.substring(2), 16);
      }
      return num;
    }
  }
});

// ../node_modules/protodef/src/compiler.js
var require_compiler = __commonJS({
  "../node_modules/protodef/src/compiler.js"(exports, module) {
    var numeric = require_numeric3();
    var utils = require_utils4();
    var conditionalDatatypes = require_compiler_conditional();
    var structuresDatatypes = require_compiler_structures();
    var utilsDatatypes = require_compiler_utils();
    var { tryCatch } = require_utils();
    var ProtoDefCompiler = class {
      constructor() {
        this.readCompiler = new ReadCompiler();
        this.writeCompiler = new WriteCompiler();
        this.sizeOfCompiler = new SizeOfCompiler();
      }
      addTypes(types) {
        this.readCompiler.addTypes(types.Read);
        this.writeCompiler.addTypes(types.Write);
        this.sizeOfCompiler.addTypes(types.SizeOf);
      }
      addTypesToCompile(types) {
        this.readCompiler.addTypesToCompile(types);
        this.writeCompiler.addTypesToCompile(types);
        this.sizeOfCompiler.addTypesToCompile(types);
      }
      addProtocol(protocolData, path) {
        this.readCompiler.addProtocol(protocolData, path);
        this.writeCompiler.addProtocol(protocolData, path);
        this.sizeOfCompiler.addProtocol(protocolData, path);
      }
      addVariable(key, val) {
        this.readCompiler.addContextType(key, val);
        this.writeCompiler.addContextType(key, val);
        this.sizeOfCompiler.addContextType(key, val);
      }
      compileProtoDefSync(options = { printCode: false }) {
        const sizeOfCode = this.sizeOfCompiler.generate();
        const writeCode = this.writeCompiler.generate();
        const readCode = this.readCompiler.generate();
        if (options.printCode) {
          console.log("// SizeOf:");
          console.log(sizeOfCode);
          console.log("// Write:");
          console.log(writeCode);
          console.log("// Read:");
          console.log(readCode);
        }
        const sizeOfCtx = this.sizeOfCompiler.compile(sizeOfCode);
        const writeCtx = this.writeCompiler.compile(writeCode);
        const readCtx = this.readCompiler.compile(readCode);
        return new CompiledProtodef(sizeOfCtx, writeCtx, readCtx);
      }
    };
    var CompiledProtodef = class {
      constructor(sizeOfCtx, writeCtx, readCtx) {
        this.sizeOfCtx = sizeOfCtx;
        this.writeCtx = writeCtx;
        this.readCtx = readCtx;
      }
      read(buffer, cursor, type) {
        const readFn = this.readCtx[type];
        if (!readFn) {
          throw new Error("missing data type: " + type);
        }
        return readFn(buffer, cursor);
      }
      write(value, buffer, cursor, type) {
        const writeFn = this.writeCtx[type];
        if (!writeFn) {
          throw new Error("missing data type: " + type);
        }
        return writeFn(value, buffer, cursor);
      }
      setVariable(key, val) {
        this.sizeOfCtx[key] = val;
        this.readCtx[key] = val;
        this.writeCtx[key] = val;
      }
      sizeOf(value, type) {
        const sizeFn = this.sizeOfCtx[type];
        if (!sizeFn) {
          throw new Error("missing data type: " + type);
        }
        if (typeof sizeFn === "function") {
          return sizeFn(value);
        } else {
          return sizeFn;
        }
      }
      createPacketBuffer(type, packet) {
        const length = tryCatch(
          () => this.sizeOf(packet, type),
          (e) => {
            e.message = `SizeOf error for ${e.field} : ${e.message}`;
            throw e;
          }
        );
        const buffer = Buffer.allocUnsafe(length);
        tryCatch(
          () => this.write(packet, buffer, 0, type),
          (e) => {
            e.message = `Write error for ${e.field} : ${e.message}`;
            throw e;
          }
        );
        return buffer;
      }
      parsePacketBuffer(type, buffer, offset = 0) {
        const { value, size } = tryCatch(
          () => this.read(buffer, offset, type),
          (e) => {
            e.message = `Read error for ${e.field} : ${e.message}`;
            throw e;
          }
        );
        return {
          data: value,
          metadata: { size },
          buffer: buffer.slice(0, size),
          fullBuffer: buffer
        };
      }
    };
    var Compiler = class {
      constructor() {
        this.primitiveTypes = {};
        this.native = {};
        this.context = {};
        this.types = {};
        this.scopeStack = [];
        this.parameterizableTypes = {};
      }
      addNativeType(type, fn) {
        this.primitiveTypes[type] = `native.${type}`;
        this.native[type] = fn;
        this.types[type] = "native";
      }
      addContextType(type, fn) {
        this.primitiveTypes[type] = `ctx.${type}`;
        this.context[type] = fn.toString();
      }
      addParametrizableType(type, maker) {
        this.parameterizableTypes[type] = maker;
      }
      addTypes(types) {
        for (const [type, [kind, fn]] of Object.entries(types)) {
          if (kind === "native")
            this.addNativeType(type, fn);
          else if (kind === "context")
            this.addContextType(type, fn);
          else if (kind === "parametrizable")
            this.addParametrizableType(type, fn);
        }
      }
      addTypesToCompile(types) {
        for (const [type, json] of Object.entries(types)) {
          if (!this.types[type] || this.types[type] === "native")
            this.types[type] = json;
        }
      }
      addProtocol(protocolData, path) {
        const self2 = this;
        function recursiveAddTypes(protocolData2, path2) {
          if (protocolData2 === void 0) {
            return;
          }
          if (protocolData2.types) {
            self2.addTypesToCompile(protocolData2.types);
          }
          recursiveAddTypes(protocolData2[path2.shift()], path2);
        }
        recursiveAddTypes(protocolData, path.slice(0));
      }
      indent(code2, indent = "  ") {
        return code2.split("\n").map((line) => indent + line).join("\n");
      }
      getField(name) {
        const path = name.split("/");
        let i = this.scopeStack.length - 1;
        const reserved = ["value", "enum", "default", "size", "offset"];
        while (path.length) {
          const scope = this.scopeStack[i];
          const field = path.shift();
          if (field === "..") {
            i--;
            continue;
          }
          if (scope[field])
            return scope[field] + (path.length ? "." + path.join(".") : "");
          if (path.length !== 0) {
            throw new Error("Cannot access properties of undefined field");
          }
          let count = 0;
          if (reserved.includes(field))
            count++;
          for (let j = 0; j < i; j++) {
            if (this.scopeStack[j][field])
              count++;
          }
          scope[field] = field + (count || "");
          return scope[field];
        }
        throw new Error("Unknown field " + path);
      }
      generate() {
        this.scopeStack = [{}];
        const functions = [];
        for (const type in this.context) {
          functions[type] = this.context[type];
        }
        for (const type in this.types) {
          if (!functions[type]) {
            if (this.types[type] !== "native") {
              functions[type] = this.compileType(this.types[type]);
              if (functions[type].startsWith("ctx")) {
                functions[type] = "function () { return " + functions[type] + "(...arguments) }";
              }
              if (!isNaN(functions[type])) {
                functions[type] = this.wrapCode("  return " + functions[type]);
              }
            } else {
              functions[type] = `native.${type}`;
            }
          }
        }
        return "() => {\n" + this.indent("const ctx = {\n" + this.indent(Object.keys(functions).map((type) => {
          return type + ": " + functions[type];
        }).join(",\n")) + "\n}\nreturn ctx") + "\n}";
      }
      compile(code) {
        const native = this.native;
        const { PartialReadError } = require_utils();
        return eval(code)();
      }
    };
    var ReadCompiler = class extends Compiler {
      constructor() {
        super();
        this.addTypes(conditionalDatatypes.Read);
        this.addTypes(structuresDatatypes.Read);
        this.addTypes(utilsDatatypes.Read);
        for (const key in numeric) {
          this.addNativeType(key, numeric[key][0]);
        }
        for (const key in utils) {
          this.addNativeType(key, utils[key][0]);
        }
      }
      compileType(type) {
        if (type instanceof Array) {
          if (this.parameterizableTypes[type[0]]) {
            return this.parameterizableTypes[type[0]](this, type[1]);
          }
          if (this.types[type[0]] && this.types[type[0]] !== "native") {
            return this.wrapCode("return " + this.callType(type[0], "offset", Object.values(type[1])));
          }
          throw new Error("Unknown parametrizable type: " + JSON.stringify(type[0]));
        } else {
          if (type === "native")
            return "null";
          if (this.types[type]) {
            return "ctx." + type;
          }
          return this.primitiveTypes[type];
        }
      }
      wrapCode(code2, args = []) {
        if (args.length > 0)
          return "(buffer, offset, " + args.join(", ") + ") => {\n" + this.indent(code2) + "\n}";
        return "(buffer, offset) => {\n" + this.indent(code2) + "\n}";
      }
      callType(type, offsetExpr = "offset", args = []) {
        if (type instanceof Array) {
          if (this.types[type[0]] && this.types[type[0]] !== "native") {
            return this.callType(type[0], offsetExpr, Object.values(type[1]));
          }
        }
        if (type instanceof Array && type[0] === "container")
          this.scopeStack.push({});
        const code2 = this.compileType(type);
        if (type instanceof Array && type[0] === "container")
          this.scopeStack.pop();
        if (args.length > 0)
          return "(" + code2 + `)(buffer, ${offsetExpr}, ` + args.map((name) => this.getField(name)).join(", ") + ")";
        return "(" + code2 + `)(buffer, ${offsetExpr})`;
      }
    };
    var WriteCompiler = class extends Compiler {
      constructor() {
        super();
        this.addTypes(conditionalDatatypes.Write);
        this.addTypes(structuresDatatypes.Write);
        this.addTypes(utilsDatatypes.Write);
        for (const key in numeric) {
          this.addNativeType(key, numeric[key][1]);
        }
        for (const key in utils) {
          this.addNativeType(key, utils[key][1]);
        }
      }
      compileType(type) {
        if (type instanceof Array) {
          if (this.parameterizableTypes[type[0]]) {
            return this.parameterizableTypes[type[0]](this, type[1]);
          }
          if (this.types[type[0]] && this.types[type[0]] !== "native") {
            return this.wrapCode("return " + this.callType("value", type[0], "offset", Object.values(type[1])));
          }
          throw new Error("Unknown parametrizable type: " + type[0]);
        } else {
          if (type === "native")
            return "null";
          if (this.types[type]) {
            return "ctx." + type;
          }
          return this.primitiveTypes[type];
        }
      }
      wrapCode(code2, args = []) {
        if (args.length > 0)
          return "(value, buffer, offset, " + args.join(", ") + ") => {\n" + this.indent(code2) + "\n}";
        return "(value, buffer, offset) => {\n" + this.indent(code2) + "\n}";
      }
      callType(value, type, offsetExpr = "offset", args = []) {
        if (type instanceof Array) {
          if (this.types[type[0]] && this.types[type[0]] !== "native") {
            return this.callType(value, type[0], offsetExpr, Object.values(type[1]));
          }
        }
        if (type instanceof Array && type[0] === "container")
          this.scopeStack.push({});
        const code2 = this.compileType(type);
        if (type instanceof Array && type[0] === "container")
          this.scopeStack.pop();
        if (args.length > 0)
          return "(" + code2 + `)(${value}, buffer, ${offsetExpr}, ` + args.map((name) => this.getField(name)).join(", ") + ")";
        return "(" + code2 + `)(${value}, buffer, ${offsetExpr})`;
      }
    };
    var SizeOfCompiler = class extends Compiler {
      constructor() {
        super();
        this.addTypes(conditionalDatatypes.SizeOf);
        this.addTypes(structuresDatatypes.SizeOf);
        this.addTypes(utilsDatatypes.SizeOf);
        for (const key in numeric) {
          this.addNativeType(key, numeric[key][2]);
        }
        for (const key in utils) {
          this.addNativeType(key, utils[key][2]);
        }
      }
      addNativeType(type, fn) {
        this.primitiveTypes[type] = `native.${type}`;
        if (!isNaN(fn)) {
          this.native[type] = (value) => {
            return fn;
          };
        } else {
          this.native[type] = fn;
        }
        this.types[type] = "native";
      }
      compileType(type) {
        if (type instanceof Array) {
          if (this.parameterizableTypes[type[0]]) {
            return this.parameterizableTypes[type[0]](this, type[1]);
          }
          if (this.types[type[0]] && this.types[type[0]] !== "native") {
            return this.wrapCode("return " + this.callType("value", type[0], Object.values(type[1])));
          }
          throw new Error("Unknown parametrizable type: " + type[0]);
        } else {
          if (type === "native")
            return "null";
          if (!isNaN(this.primitiveTypes[type]))
            return this.primitiveTypes[type];
          if (this.types[type]) {
            return "ctx." + type;
          }
          return this.primitiveTypes[type];
        }
      }
      wrapCode(code2, args = []) {
        if (args.length > 0)
          return "(value, " + args.join(", ") + ") => {\n" + this.indent(code2) + "\n}";
        return "(value) => {\n" + this.indent(code2) + "\n}";
      }
      callType(value, type, args = []) {
        if (type instanceof Array) {
          if (this.types[type[0]] && this.types[type[0]] !== "native") {
            return this.callType(value, type[0], Object.values(type[1]));
          }
        }
        if (type instanceof Array && type[0] === "container")
          this.scopeStack.push({});
        const code2 = this.compileType(type);
        if (type instanceof Array && type[0] === "container")
          this.scopeStack.pop();
        if (!isNaN(code2))
          return code2;
        if (args.length > 0)
          return "(" + code2 + `)(${value}, ` + args.map((name) => this.getField(name)).join(", ") + ")";
        return "(" + code2 + `)(${value})`;
      }
    };
    module.exports = {
      ReadCompiler,
      WriteCompiler,
      SizeOfCompiler,
      ProtoDefCompiler,
      CompiledProtodef
    };
  }
});

// ../node_modules/protodef/src/index.js
var require_src2 = __commonJS({
  "../node_modules/protodef/src/index.js"(exports2, module2) {
    var ProtoDef = require_protodef();
    var proto = new ProtoDef();
    module2.exports = {
      ProtoDef,
      Serializer: require_serializer().Serializer,
      Parser: require_serializer().Parser,
      FullPacketParser: require_serializer().FullPacketParser,
      Compiler: require_compiler(),
      types: proto.types,
      utils: require_utils()
    };
  }
});

// ../node_modules/protodef/index.js
var require_protodef2 = __commonJS({
  "../node_modules/protodef/index.js"(exports2, module2) {
    module2.exports = require_src2();
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/ours/primordials.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Uint8Array
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/ours/util.js
var require_util2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/ours/util.js"(exports2, module2) {
    "use strict";
    var bufferModule = require("buffer");
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob;
    } : function isBlob2(b) {
      return false;
    };
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module2.exports = {
      AggregateError,
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob
    };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// ../node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "../node_modules/event-target-shim/dist/event-target-shim.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      const retv = privateData.get(event);
      console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      );
      return retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        if (typeof console !== "undefined" && typeof console.error === "function") {
          console.error(
            "Unable to preventDefault inside passive event listener invocation.",
            data.passiveListener
          );
        }
        return;
      }
      if (!data.event.cancelable) {
        return;
      }
      data.canceled = true;
      if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
      }
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      });
      Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
          Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
    }
    Event.prototype = {
      get type() {
        return pd(this).event.type;
      },
      get target() {
        return pd(this).eventTarget;
      },
      get currentTarget() {
        return pd(this).currentTarget;
      },
      composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
          return [];
        }
        return [currentTarget];
      },
      get NONE() {
        return 0;
      },
      get CAPTURING_PHASE() {
        return 1;
      },
      get AT_TARGET() {
        return 2;
      },
      get BUBBLING_PHASE() {
        return 3;
      },
      get eventPhase() {
        return pd(this).eventPhase;
      },
      stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
          data.event.stopPropagation();
        }
      },
      stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
          data.event.stopImmediatePropagation();
        }
      },
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      preventDefault() {
        setCancelFlag(pd(this));
      },
      get defaultPrevented() {
        return pd(this).canceled;
      },
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      get timeStamp() {
        return pd(this).timeStamp;
      },
      get srcElement() {
        return pd(this).eventTarget;
      },
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value) {
          return;
        }
        const data = pd(this);
        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
          data.event.cancelBubble = true;
        }
      },
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        if (!value) {
          setCancelFlag(pd(this));
        }
      },
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
      Object.setPrototypeOf(Event.prototype, window.Event.prototype);
      wrappers.set(window.Event.prototype, Event);
    }
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          const event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineWrapper(BaseEvent, proto) {
      const keys = Object.keys(proto);
      if (keys.length === 0) {
        return BaseEvent;
      }
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true }
      });
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          const descriptor = Object.getOwnPropertyDescriptor(proto, key);
          const isFunc = typeof descriptor.value === "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype) {
        return Event;
      }
      let wrapper = wrappers.get(proto);
      if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
      }
      return wrapper;
    }
    function wrapEvent(eventTarget, event) {
      const Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(x) {
      return x !== null && typeof x === "object";
    }
    function getListeners(eventTarget) {
      const listeners = listenersMap.get(eventTarget);
      if (listeners == null) {
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      }
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          const listeners = getListeners(this);
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              return node.listener;
            }
            node = node.next;
          }
          return null;
        },
        set(listener) {
          if (typeof listener !== "function" && !isObject(listener)) {
            listener = null;
          }
          const listeners = getListeners(this);
          let prev = null;
          let node = listeners.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE) {
              if (prev !== null) {
                prev.next = node.next;
              } else if (node.next !== null) {
                listeners.set(eventName, node.next);
              } else {
                listeners.delete(eventName);
              }
            } else {
              prev = node;
            }
            node = node.next;
          }
          if (listener !== null) {
            const newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: false,
              once: false,
              next: null
            };
            if (prev === null) {
              listeners.set(eventName, newNode);
            } else {
              prev.next = newNode;
            }
          }
        },
        configurable: true,
        enumerable: true
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: true,
          writable: true
        }
      });
      for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      }
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
      }
      if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
          types[i] = arguments[i];
        }
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      addEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        if (typeof listener !== "function" && !isObject(listener)) {
          throw new TypeError("'listener' should be a function or an object.");
        }
        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        };
        let node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            return;
          }
          prev = node;
          node = node.next;
        }
        prev.next = newNode;
      },
      removeEventListener(eventName, listener, options) {
        if (listener == null) {
          return;
        }
        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
            return;
          }
          prev = node;
          node = node.next;
        }
      },
      dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
          throw new TypeError('"event.type" should be a string.');
        }
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
          return true;
        }
        const wrappedEvent = wrapEvent(this, event);
        let prev = null;
        while (node != null) {
          if (node.once) {
            if (prev !== null) {
              prev.next = node.next;
            } else if (node.next !== null) {
              listeners.set(eventName, node.next);
            } else {
              listeners.delete(eventName);
            }
          } else {
            prev = node;
          }
          setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          );
          if (typeof node.listener === "function") {
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(err);
              }
            }
          } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
            node.listener.handleEvent(wrappedEvent);
          }
          if (isStopped(wrappedEvent)) {
            break;
          }
          node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);
        return !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: true,
      writable: true
    });
    if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
      Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    }
    exports2.defineEventAttribute = defineEventAttribute;
    exports2.EventTarget = EventTarget;
    exports2.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports["default"] = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// ../node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "../node_modules/abort-controller/dist/abort-controller.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var eventTargetShim = require_event_target_shim();
    var AbortSignal = class extends eventTargetShim.EventTarget {
      constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      const signal = Object.create(AbortSignal.prototype);
      eventTargetShim.EventTarget.call(signal);
      abortedFlags.set(signal, false);
      return signal;
    }
    function abortSignal(signal) {
      if (abortedFlags.get(signal) !== false) {
        return;
      }
      abortedFlags.set(signal, true);
      signal.dispatchEvent({ type: "abort" });
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal"
      });
    }
    var AbortController = class {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    };
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      const signal = signals.get(controller);
      if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      }
      return signal;
    }
    Object.defineProperties(AbortController.prototype, {
      signal: { enumerable: true },
      abort: { enumerable: true }
    });
    if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController"
      });
    }
    exports2.AbortController = AbortController;
    exports2.AbortSignal = AbortSignal;
    exports2.default = AbortController;
    module2.exports = AbortController;
    module2.exports.AbortController = module2.exports["default"] = AbortController;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/ours/errors.js
var require_errors2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/ours/errors.js"(exports2, module2) {
    "use strict";
    var { format, inspect, AggregateError: CustomAggregateError } = require_util2();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code2, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code2, message, args));
        }
        toString() {
          return `${this.name} [${code2}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code2}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code2;
      NodeError.prototype[kIsNodeError] = true;
      codes[code2] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/validators.js"(exports2, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      RegExpPrototypeTest,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors2();
    var { normalizeEncoding } = require_util2();
    var { isAsyncFunction, isArrayBufferView } = require_util2().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (!RegExpPrototypeTest(octalReg, value)) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateInt32(value, name, 0, 2 ** 32 - 1);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!isInt32(value)) {
        if (!NumberIsInteger(value)) {
          throw new ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!isUint32(value)) {
        if (!NumberIsInteger(value)) {
          throw new ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
      }
      if (positive && value === 0) {
        throw new ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    var validateObject = hideStackFrames((value, name, options) => {
      const useDefaultOptions = options == null;
      const allowArray = useDefaultOptions ? false : options.allowArray;
      const allowFunction = useDefaultOptions ? false : options.allowFunction;
      const nullable = useDefaultOptions ? false : options.nullable;
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    module2.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateBoolean,
      validateBuffer,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateAbortSignal
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils5 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/utils.js"(exports2, module2) {
    "use strict";
    var { Symbol: Symbol2, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var kDestroyed = Symbol2("kDestroyed");
    var kIsErrored = Symbol2("kIsErrored");
    var kIsReadable = Symbol2("kIsReadable");
    var kIsDisturbed = Symbol2("kIsDisturbed");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module2.exports = {
      kDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      isClosed,
      isDestroyed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWritable,
      isWritableNodeStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var { AbortError, codes } = require_errors2();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { once } = require_util2();
    var { validateAbortSignal, validateFunction, validateObject } = require_validators();
    var { Promise: Promise2 } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose
    } = require_utils5();
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = {};
      } else if (options == null) {
        options = {};
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "Stream", stream);
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process.nextTick(onclose);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process.nextTick(onclose);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process.nextTick(onclose);
      } else if (rState && stream.req && stream.aborted) {
        process.nextTick(onclose);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          const originalCallback = callback;
          callback = once((...args) => {
            options.signal.removeEventListener("abort", abort);
            originalCallback.apply(stream, args);
          });
          options.signal.addEventListener("abort", abort);
        }
      }
      return cleanup;
    }
    function finished(stream, opts) {
      return new Promise2((resolve, reject) => {
        eos(stream, opts, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/operators.js"(exports2, module2) {
    "use strict";
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var {
      codes: { ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors2();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var { finished } = require_end_of_stream2();
    var {
      ArrayPrototypePush,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromisePrototypeCatch,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      validateInteger(concurrency, "concurrency", 1);
      return async function* map2() {
        var _options$signal, _options$signal2;
        const ac = new AbortController();
        const stream = this;
        const queue = [];
        const signal = ac.signal;
        const signalOpt = {
          signal
        };
        const abort = () => ac.abort();
        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
          abort();
        }
        options === null || options === void 0 ? void 0 : (_options$signal2 = options.signal) === null || _options$signal2 === void 0 ? void 0 : _options$signal2.addEventListener("abort", abort);
        let next;
        let resume;
        let done = false;
        function onDone() {
          done = true;
        }
        async function pump() {
          try {
            for await (let val of stream) {
              var _val;
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
              } catch (err) {
                val = PromiseReject(err);
              }
              if (val === kEmpty) {
                continue;
              }
              if (typeof ((_val = val) === null || _val === void 0 ? void 0 : _val.catch) === "function") {
                val.catch(onDone);
              }
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && queue.length && queue.length >= concurrency) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeCatch(val, onDone);
            queue.push(val);
          } finally {
            var _options$signal3;
            done = true;
            if (next) {
              next();
              next = null;
            }
            options === null || options === void 0 ? void 0 : (_options$signal3 = options.signal) === null || _options$signal3 === void 0 ? void 0 : _options$signal3.removeEventListener("abort", abort);
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              if (resume) {
                resume();
                resume = null;
              }
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          ac.abort();
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }.call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal4;
          if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }.call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal5;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal6;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }.call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* drop2() {
        var _options$signal8;
        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal9;
          if (options !== null && options !== void 0 && (_options$signal9 = options.signal) !== null && _options$signal9 !== void 0 && _options$signal9.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }.call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return async function* take2() {
        var _options$signal10;
        if (options !== null && options !== void 0 && (_options$signal10 = options.signal) !== null && _options$signal10 !== void 0 && _options$signal10.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal11;
          if (options !== null && options !== void 0 && (_options$signal11 = options.signal) !== null && _options$signal11 !== void 0 && _options$signal11.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          } else {
            return;
          }
        }
      }.call(this);
    }
    module2.exports.streamReturningOperators = {
      asIndexedPairs,
      drop,
      filter,
      flatMap,
      map,
      take
    };
    module2.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors2();
    var { Symbol: Symbol2 } = require_primordials();
    var { kDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils5();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w && w.emitClose || r && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w && w.destroyed || r && r.destroyed) {
        return this;
      }
      if (r && r.autoDestroy || w && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct(onConstruct);
      } catch (err) {
        onConstruct(err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return stream && stream.setHeader && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process.nextTick(emitErrorCloseLegacy, stream);
      } else {
        process.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kDestroyed] = true;
      }
    }
    module2.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/legacy.js"(exports2, module2) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require("events");
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = {
      Stream,
      prependListener
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports2, module2) {
    "use strict";
    var { AbortError, codes } = require_errors2();
    var eos = require_end_of_stream2();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    function isNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function");
    }
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
      }
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, () => signal.removeEventListener("abort", onAbort));
      }
      return stream;
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { inspect } = require_util2();
    module2.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer.alloc(0);
        const ret = Buffer.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      _getBuffer(n) {
        const ret = Buffer.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          depth: 0,
          customInspect: false
        });
      }
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? 16 : 16 * 1024;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer) {
        return new Readable({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process.nextTick(cb, error),
          (e) => process.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/readable.js"(exports2, module2) {
    "use strict";
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module2.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = require("events");
    var { Stream, prependListener } = require_legacy();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream2();
    var debug = require_util2().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list2();
    var destroyImpl = require_destroy2();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      }
    } = require_errors2();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require("string_decoder");
    var from = require_from2();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.constructed = true;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this[kPaused] = null;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.destroyed = false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.multiAwaitDrain = false;
      this.readingMore = false;
      this.dataEmitted = false;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored)
            return false;
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length)
          return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length)
        return n;
      return state.ended ? state.length : 0;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        if (state.flowing) {
          pause();
        }
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable.prototype, {
      readable: {
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      pipesCount: {
        get() {
          return this.pipes.length;
        }
      },
      paused: {
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      let ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable.from = function(iterable, opts) {
      return from(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/writable.js"(exports2, module2) {
    "use strict";
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require("events");
    var Stream = require_legacy().Stream;
    var destroyImpl = require_destroy2();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state2();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors2().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports2, module2) {
    "use strict";
    var bufferModule = require("buffer");
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream
    } = require_utils5();
    var eos = require_end_of_stream2();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors2();
    var { destroyer } = require_destroy2();
    var Duplex = require_duplex();
    var Readable = require_readable2();
    var { createDeferredPromise } = require_util2();
    var from = require_from2();
    var Blob = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module2.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process.nextTick(cb, null);
                } catch (err) {
                  process.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          objectMode: true,
          writable: false
        });
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      d = new Duplexify({
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/duplex.js"(exports2, module2) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module2.exports = Duplex;
    var Readable = require_readable2();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable"),
      writableHighWaterMark: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
      writableObjectMode: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
      writableBuffer: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
      writableLength: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength"),
      writableFinished: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
      writableCorked: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
      writableEnded: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
      writableNeedDrain: ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
      destroyed: {
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/transform.js"(exports2, module2) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
    var Duplex = require_duplex();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.highWaterMark === 0 || rState.length === 0) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports2, module2) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator } = require_primordials();
    var eos = require_end_of_stream2();
    var { once } = require_util2();
    var destroyImpl = require_destroy2();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED },
      AbortError
    } = require_errors2();
    var { validateFunction, validateAbortSignal } = require_validators();
    var { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require_utils5();
    var AbortController = globalThis.AbortController || require_abort_controller().AbortController;
    var PassThrough;
    var Readable;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable) {
        Readable = require_readable2();
      }
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pump(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
        }
        await wait();
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.addEventListener("abort", abort);
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        outerSignal === null || outerSignal === void 0 ? void 0 : outerSignal.removeEventListener("abort", abort);
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          ret = makeAsyncIterable(ret);
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret = ret) === null || _ret === void 0 ? void 0 : _ret.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pump(ret, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isIterable(ret)) {
            finishCount++;
            pump(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], ret);
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      src.pipe(dst, {
        end
      });
      if (end) {
        src.once("end", () => dst.end());
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module2.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/internal/streams/compose.js"(exports2, module2) {
    "use strict";
    var { pipeline } = require_pipeline2();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy2();
    var { isNodeStream, isReadable, isWritable } = require_utils5();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors2();
    module2.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !isReadable(streams[n])) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !isWritable(streams[n])) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!isWritable(head);
      const readable = !!isReadable(tail);
      d = new Duplex({
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.writableObjectMode),
        writable,
        readable
      });
      if (writable) {
        d._write = function(chunk, encoding, callback) {
          if (head.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          head.end();
          onfinish = callback;
        };
        head.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        tail.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        tail.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        tail.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = tail.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(tail, err);
        }
      };
      return d;
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/stream/promises.js"(exports2, module2) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream } = require_utils5();
    var { pipelineImpl: pl } = require_pipeline2();
    var { finished } = require_end_of_stream2();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module2.exports = {
      finished,
      pipeline
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/stream.js
var require_stream2 = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/stream.js"(exports2, module2) {
    "use strict";
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util2();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors2();
    var compose = require_compose();
    var { pipeline } = require_pipeline2();
    var { destroyer } = require_destroy2();
    var eos = require_end_of_stream2();
    var promises = require_promises();
    var utils2 = require_utils5();
    var Stream = module2.exports = require_legacy().Stream;
    Stream.isDisturbed = utils2.isDisturbed;
    Stream.isErrored = utils2.isErrored;
    Stream.isReadable = utils2.isReadable;
    Stream.Readable = require_readable2();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    ObjectDefineProperty(Stream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// ../node_modules/minecraft-protocol/node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS({
  "../node_modules/minecraft-protocol/node_modules/readable-stream/lib/ours/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    if (Stream && process.env.READABLE_STREAM === "disable") {
      const promises = Stream.promises;
      module2.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = Stream._isUint8Array;
      module2.exports.isDisturbed = Stream.isDisturbed;
      module2.exports.isErrored = Stream.isErrored;
      module2.exports.isReadable = Stream.isReadable;
      module2.exports.Readable = Stream.Readable;
      module2.exports.Writable = Stream.Writable;
      module2.exports.Duplex = Stream.Duplex;
      module2.exports.Transform = Stream.Transform;
      module2.exports.PassThrough = Stream.PassThrough;
      module2.exports.addAbortSignal = Stream.addAbortSignal;
      module2.exports.finished = Stream.finished;
      module2.exports.destroy = Stream.destroy;
      module2.exports.pipeline = Stream.pipeline;
      module2.exports.compose = Stream.compose;
      Object.defineProperty(Stream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = Stream.Stream;
    } else {
      const CustomStream = require_stream2();
      const promises = require_promises();
      const originalDestroy = CustomStream.Readable.destroy;
      module2.exports = CustomStream.Readable;
      module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
      module2.exports._isUint8Array = CustomStream._isUint8Array;
      module2.exports.isDisturbed = CustomStream.isDisturbed;
      module2.exports.isErrored = CustomStream.isErrored;
      module2.exports.isReadable = CustomStream.isReadable;
      module2.exports.Readable = CustomStream.Readable;
      module2.exports.Writable = CustomStream.Writable;
      module2.exports.Duplex = CustomStream.Duplex;
      module2.exports.Transform = CustomStream.Transform;
      module2.exports.PassThrough = CustomStream.PassThrough;
      module2.exports.addAbortSignal = CustomStream.addAbortSignal;
      module2.exports.finished = CustomStream.finished;
      module2.exports.destroy = CustomStream.destroy;
      module2.exports.destroy = originalDestroy;
      module2.exports.pipeline = CustomStream.pipeline;
      module2.exports.compose = CustomStream.compose;
      Object.defineProperty(CustomStream, "promises", {
        configurable: true,
        enumerable: true,
        get() {
          return promises;
        }
      });
      module2.exports.Stream = CustomStream.Stream;
    }
    module2.exports.default = module2.exports;
  }
});

// ../node_modules/minecraft-protocol/src/transforms/compression.js
var require_compression = __commonJS({
  "../node_modules/minecraft-protocol/src/transforms/compression.js"(exports2, module2) {
    "use strict";
    var [readVarInt, writeVarInt, sizeOfVarInt] = require_protodef2().types.varint;
    var zlib = require("zlib");
    var Transform = require_ours().Transform;
    module2.exports.createCompressor = function(threshold) {
      return new Compressor(threshold);
    };
    module2.exports.createDecompressor = function(threshold, hideErrors) {
      return new Decompressor(threshold, hideErrors);
    };
    var Compressor = class extends Transform {
      constructor(compressionThreshold = -1) {
        super();
        this.compressionThreshold = compressionThreshold;
      }
      _transform(chunk, enc, cb) {
        if (chunk.length >= this.compressionThreshold) {
          zlib.deflate(chunk, (err, newChunk) => {
            if (err) {
              return cb(err);
            }
            const buf = Buffer.alloc(sizeOfVarInt(chunk.length) + newChunk.length);
            const offset = writeVarInt(chunk.length, buf, 0);
            newChunk.copy(buf, offset);
            this.push(buf);
            return cb();
          });
        } else {
          const buf = Buffer.alloc(sizeOfVarInt(0) + chunk.length);
          const offset = writeVarInt(0, buf, 0);
          chunk.copy(buf, offset);
          this.push(buf);
          return cb();
        }
      }
    };
    var Decompressor = class extends Transform {
      constructor(compressionThreshold = -1, hideErrors = false) {
        super();
        this.compressionThreshold = compressionThreshold;
        this.hideErrors = hideErrors;
      }
      _transform(chunk, enc, cb) {
        const { size, value, error } = readVarInt(chunk, 0);
        if (error) {
          return cb(error);
        }
        if (value === 0) {
          this.push(chunk.slice(size));
          return cb();
        } else {
          zlib.unzip(chunk.slice(size), { finishFlush: 2 }, (err, newBuf) => {
            if (err) {
              if (!this.hideErrors) {
                console.error("problem inflating chunk");
                console.error("uncompressed length " + value);
                console.error("compressed length " + chunk.length);
                console.error("hex " + chunk.toString("hex"));
                console.log(err);
              }
              return cb();
            }
            if (newBuf.length !== value && !this.hideErrors) {
              console.error("uncompressed length should be " + value + " but is " + newBuf.length);
            }
            this.push(newBuf);
            return cb();
          });
        }
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/transforms/framing.js
var require_framing = __commonJS({
  "../node_modules/minecraft-protocol/src/transforms/framing.js"(exports2, module2) {
    "use strict";
    var [readVarInt, writeVarInt, sizeOfVarInt] = require_protodef2().types.varint;
    var Transform = require_ours().Transform;
    module2.exports.createSplitter = function() {
      return new Splitter();
    };
    module2.exports.createFramer = function() {
      return new Framer();
    };
    var Framer = class extends Transform {
      _transform(chunk, enc, cb) {
        const varIntSize = sizeOfVarInt(chunk.length);
        const buffer = Buffer.alloc(varIntSize + chunk.length);
        writeVarInt(chunk.length, buffer, 0);
        chunk.copy(buffer, varIntSize);
        this.push(buffer);
        return cb();
      }
    };
    var LEGACY_PING_PACKET_ID = 254;
    var Splitter = class extends Transform {
      constructor() {
        super();
        this.buffer = Buffer.alloc(0);
        this.recognizeLegacyPing = false;
      }
      _transform(chunk, enc, cb) {
        this.buffer = Buffer.concat([this.buffer, chunk]);
        if (this.recognizeLegacyPing && this.buffer[0] === LEGACY_PING_PACKET_ID) {
          const header = Buffer.alloc(sizeOfVarInt(LEGACY_PING_PACKET_ID));
          writeVarInt(LEGACY_PING_PACKET_ID, header, 0);
          let payload = this.buffer.slice(1);
          if (payload.length === 0)
            payload = Buffer.from("\0");
          this.push(Buffer.concat([header, payload]));
          return cb();
        }
        let offset = 0;
        let value, size;
        let stop = false;
        try {
          ({ value, size } = readVarInt(this.buffer, offset));
        } catch (e) {
          if (!e.partialReadError) {
            throw e;
          } else {
            stop = true;
          }
        }
        if (!stop) {
          while (this.buffer.length >= offset + size + value) {
            try {
              this.push(this.buffer.slice(offset + size, offset + size + value));
              offset += size + value;
              ({ value, size } = readVarInt(this.buffer, offset));
            } catch (e) {
              if (e.partialReadError) {
                break;
              } else {
                throw e;
              }
            }
          }
        }
        this.buffer = this.buffer.slice(offset);
        return cb();
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/states.js
var require_states = __commonJS({
  "../node_modules/minecraft-protocol/src/states.js"(exports2, module2) {
    "use strict";
    var states = {
      HANDSHAKING: "handshaking",
      STATUS: "status",
      LOGIN: "login",
      PLAY: "play"
    };
    module2.exports = states;
  }
});

// ../node_modules/prismarine-nbt/nbt.json
var require_nbt = __commonJS({
  "../node_modules/prismarine-nbt/nbt.json"(exports2, module2) {
    module2.exports = {
      void: "native",
      container: "native",
      i8: "native",
      switch: "native",
      compound: "native",
      i16: "native",
      u16: "native",
      i32: "native",
      i64: "native",
      f32: "native",
      f64: "native",
      pstring: "native",
      shortString: ["pstring", {
        countType: "u16"
      }],
      byteArray: [
        "array",
        {
          countType: "i32",
          type: "i8"
        }
      ],
      list: [
        "container",
        [
          {
            name: "type",
            type: "nbtMapper"
          },
          {
            name: "value",
            type: [
              "array",
              {
                countType: "i32",
                type: ["nbtSwitch", { type: "type" }]
              }
            ]
          }
        ]
      ],
      intArray: [
        "array",
        {
          countType: "i32",
          type: "i32"
        }
      ],
      longArray: [
        "array",
        {
          countType: "i32",
          type: "i64"
        }
      ],
      nbtMapper: [
        "mapper",
        {
          type: "i8",
          mappings: {
            "0": "end",
            "1": "byte",
            "2": "short",
            "3": "int",
            "4": "long",
            "5": "float",
            "6": "double",
            "7": "byteArray",
            "8": "string",
            "9": "list",
            "10": "compound",
            "11": "intArray",
            "12": "longArray"
          }
        }
      ],
      nbtSwitch: [
        "switch",
        {
          compareTo: "$type",
          fields: {
            end: "void",
            byte: "i8",
            short: "i16",
            int: "i32",
            long: "i64",
            float: "f32",
            double: "f64",
            byteArray: "byteArray",
            string: "shortString",
            list: "list",
            compound: "compound",
            intArray: "intArray",
            longArray: "longArray"
          }
        }
      ],
      nbt: [
        "container",
        [
          {
            name: "type",
            type: "nbtMapper"
          },
          {
            name: "name",
            type: "nbtTagName"
          },
          {
            name: "value",
            type: ["nbtSwitch", { type: "type" }]
          }
        ]
      ]
    };
  }
});

// ../node_modules/prismarine-nbt/nbt-varint.json
var require_nbt_varint = __commonJS({
  "../node_modules/prismarine-nbt/nbt-varint.json"(exports2, module2) {
    module2.exports = {
      void: "native",
      container: "native",
      i8: "native",
      switch: "native",
      compound: "native",
      zigzag32: "native",
      zigzag64: "native",
      i16: "native",
      i32: "native",
      i64: "native",
      f32: "native",
      f64: "native",
      pstring: "native",
      shortString: [
        "pstring",
        {
          countType: "varint"
        }
      ],
      byteArray: [
        "array",
        {
          countType: "zigzag32",
          type: "i8"
        }
      ],
      list: [
        "container",
        [
          {
            name: "type",
            type: "nbtMapper"
          },
          {
            name: "value",
            type: [
              "array",
              {
                countType: "zigzag32",
                type: [
                  "nbtSwitch",
                  {
                    type: "type"
                  }
                ]
              }
            ]
          }
        ]
      ],
      intArray: [
        "array",
        {
          countType: "zigzag32",
          type: "i32"
        }
      ],
      longArray: [
        "array",
        {
          countType: "zigzag32",
          type: "i64"
        }
      ],
      nbtMapper: [
        "mapper",
        {
          type: "i8",
          mappings: {
            "0": "end",
            "1": "byte",
            "2": "short",
            "3": "int",
            "4": "long",
            "5": "float",
            "6": "double",
            "7": "byteArray",
            "8": "string",
            "9": "list",
            "10": "compound",
            "11": "intArray",
            "12": "longArray"
          }
        }
      ],
      nbtSwitch: [
        "switch",
        {
          compareTo: "$type",
          fields: {
            end: "void",
            byte: "i8",
            short: "i16",
            int: "zigzag32",
            long: "zigzag64",
            float: "f32",
            double: "f64",
            byteArray: "byteArray",
            string: "shortString",
            list: "list",
            compound: "compound",
            intArray: "intArray",
            longArray: "longArray"
          }
        }
      ],
      nbt: [
        "container",
        [
          {
            name: "type",
            type: "nbtMapper"
          },
          {
            name: "name",
            type: "nbtTagName"
          },
          {
            name: "value",
            type: [
              "nbtSwitch",
              {
                type: "type"
              }
            ]
          }
        ]
      ]
    };
  }
});

// ../node_modules/prismarine-nbt/compiler-compound.js
var require_compiler_compound = __commonJS({
  "../node_modules/prismarine-nbt/compiler-compound.js"(exports2, module2) {
    module2.exports = {
      Read: {
        compound: ["context", (buffer, offset) => {
          const results = {
            value: {},
            size: 0
          };
          while (offset !== buffer.length) {
            const typ = ctx.i8(buffer, offset);
            if (typ.value === 0) {
              results.size += typ.size;
              break;
            }
            if (typ.value > 20) {
              throw new Error(`Invalid tag: ${typ.value} > 20`);
            }
            const readResults = ctx.nbt(buffer, offset);
            offset += readResults.size;
            results.size += readResults.size;
            results.value[readResults.value.name] = {
              type: readResults.value.type,
              value: readResults.value.value
            };
          }
          return results;
        }]
      },
      Write: {
        compound: ["context", (value, buffer, offset) => {
          for (const key in value) {
            offset = ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            }, buffer, offset);
          }
          offset = ctx.i8(0, buffer, offset);
          return offset;
        }]
      },
      SizeOf: {
        compound: ["context", (value) => {
          let size = 1;
          for (const key in value) {
            size += ctx.nbt({
              name: key,
              type: value[key].type,
              value: value[key].value
            });
          }
          return size;
        }]
      }
    };
  }
});

// ../node_modules/prismarine-nbt/compiler-tagname.js
var require_compiler_tagname = __commonJS({
  "../node_modules/prismarine-nbt/compiler-tagname.js"(exports2, module2) {
    function readPString(buffer, offset) {
      const { value, size } = ctx.shortString(buffer, offset);
      for (const c of value) {
        if (c === "\0")
          throw new Error("unexpected tag end");
      }
      return { value, size };
    }
    function writePString(...args) {
      return ctx.shortString(...args);
    }
    function sizeOfPString(...args) {
      return ctx.shortString(...args);
    }
    module2.exports = {
      Read: { nbtTagName: ["context", readPString] },
      Write: { nbtTagName: ["context", writePString] },
      SizeOf: { nbtTagName: ["context", sizeOfPString] }
    };
  }
});

// ../node_modules/prismarine-nbt/compiler-zigzag.js
var require_compiler_zigzag = __commonJS({
  "../node_modules/prismarine-nbt/compiler-zigzag.js"(exports2, module2) {
    function sizeOfVarInt(value) {
      value = value << 1 ^ value >> 63;
      let cursor = 0;
      while (value & ~127) {
        value >>>= 7;
        cursor++;
      }
      return cursor + 1;
    }
    function sizeOfVarLong(value) {
      if (typeof value.valueOf() === "object") {
        value = BigInt(value[0]) << 32n | BigInt(value[1]);
      } else if (typeof value !== "bigint")
        value = BigInt(value);
      value = value << 1n ^ value >> 63n;
      let cursor = 0;
      while (value > 127n) {
        value >>= 7n;
        cursor++;
      }
      return cursor + 1;
    }
    function readSignedVarLong(buffer, offset) {
      let result = BigInt(0);
      let shift = 0n;
      let cursor = offset;
      let size = 0;
      while (true) {
        if (cursor + 1 > buffer.length) {
          throw new Error("unexpected buffer end");
        }
        const b = buffer.readUInt8(cursor);
        result |= (BigInt(b) & 0x7fn) << shift;
        cursor++;
        if (!(b & 128)) {
          size = cursor - offset;
          break;
        }
        shift += 7n;
        if (shift > 63n)
          throw new Error(`varint is too big: ${shift}`);
      }
      const zigzag = result >> 1n ^ -(result & 1n);
      return { value: zigzag, size };
    }
    function writeSignedVarLong(value, buffer, offset) {
      if (typeof value.valueOf() === "object") {
        value = BigInt.asIntN(64, BigInt(value[0]) << 32n) | BigInt(value[1]);
      } else if (typeof value !== "bigint")
        value = BigInt(value);
      value = value << 1n ^ value >> 63n;
      let cursor = 0;
      while (value > 127n) {
        const num = Number(value & 0xFFn);
        buffer.writeUInt8(num | 128, offset + cursor);
        cursor++;
        value >>= 7n;
      }
      buffer.writeUInt8(Number(value), offset + cursor);
      return offset + cursor + 1;
    }
    function readSignedVarInt(buffer, offset) {
      let result = 0;
      let shift = 0;
      let cursor = offset;
      let size = 0;
      while (true) {
        if (cursor + 1 > buffer.length) {
          throw new Error("unexpected buffer end");
        }
        const b = buffer.readUInt8(cursor);
        result |= (b & 127) << shift;
        cursor++;
        if (!(b & 128)) {
          size = cursor - offset;
          break;
        }
        shift += 7;
        if (shift > 31)
          throw new Error(`varint is too big: ${shift}`);
      }
      const zigzag = (result << 63 >> 63 ^ result) >> 1 ^ result & 1 << 63;
      return { value: zigzag, size };
    }
    function writeSignedVarInt(value, buffer, offset) {
      value = value << 1 ^ value >> 31;
      let cursor = 0;
      while (value & ~127) {
        const num = Number(value & 255 | 128);
        buffer.writeUInt8(num, offset + cursor);
        cursor++;
        value >>>= 7;
      }
      buffer.writeUInt8(value, offset + cursor);
      return offset + cursor + 1;
    }
    module2.exports = {
      Read: { zigzag64: ["native", readSignedVarLong], zigzag32: ["native", readSignedVarInt] },
      Write: { zigzag64: ["native", writeSignedVarLong], zigzag32: ["native", writeSignedVarInt] },
      SizeOf: { zigzag64: ["native", sizeOfVarLong], zigzag32: ["native", sizeOfVarInt] }
    };
  }
});

// ../node_modules/prismarine-nbt/typings/tag-type.js
var require_tag_type = __commonJS({
  "../node_modules/prismarine-nbt/typings/tag-type.js"(exports2, module2) {
    var TagType = {
      Byte: "byte",
      Short: "short",
      Int: "int",
      Long: "long",
      Float: "float",
      Double: "double",
      ByteArray: "byteArray",
      String: "string",
      List: "list",
      Compound: "compound",
      IntArray: "intArray",
      LongArray: "longArray"
    };
    module2.exports = TagType;
  }
});

// ../node_modules/prismarine-nbt/nbt.js
var require_nbt2 = __commonJS({
  "../node_modules/prismarine-nbt/nbt.js"(exports2, module2) {
    var zlib = require("zlib");
    var { ProtoDefCompiler: ProtoDefCompiler2 } = require_protodef2().Compiler;
    var beNbtJson = JSON.stringify(require_nbt());
    var leNbtJson = beNbtJson.replace(/([iuf][0-7]+)/g, "l$1");
    var varintJson = JSON.stringify(require_nbt_varint()).replace(/([if][0-7]+)/g, "l$1");
    function createProto(type) {
      const compiler = new ProtoDefCompiler2();
      compiler.addTypes(require_compiler_compound());
      compiler.addTypes(require_compiler_tagname());
      let proto = beNbtJson;
      if (type === "littleVarint") {
        compiler.addTypes(require_compiler_zigzag());
        proto = varintJson;
      } else if (type === "little") {
        proto = leNbtJson;
      }
      compiler.addTypesToCompile(JSON.parse(proto));
      return compiler.compileProtoDefSync();
    }
    var protoBE = createProto("big");
    var protoLE = createProto("little");
    var protoVarInt = createProto("littleVarint");
    var protos = {
      big: protoBE,
      little: protoLE,
      littleVarint: protoVarInt
    };
    function writeUncompressed(value, proto = "big") {
      if (proto === true)
        proto = "little";
      return protos[proto].createPacketBuffer("nbt", value);
    }
    function parseUncompressed(data, proto = "big") {
      if (proto === true)
        proto = "little";
      return protos[proto].parsePacketBuffer("nbt", data, data.startOffset).data;
    }
    var hasGzipHeader = function(data) {
      let result = true;
      if (data[0] !== 31)
        result = false;
      if (data[1] !== 139)
        result = false;
      return result;
    };
    var hasBedrockLevelHeader = (data) => data[1] === 0 && data[2] === 0 && data[3] === 0;
    async function parseAs(data, type) {
      if (hasGzipHeader(data)) {
        data = await new Promise((resolve, reject) => {
          zlib.gunzip(data, (error, uncompressed) => {
            if (error)
              reject(error);
            else
              resolve(uncompressed);
          });
        });
      }
      const parsed = protos[type].parsePacketBuffer("nbt", data, data.startOffset);
      parsed.metadata.buffer = data;
      parsed.type = type;
      return parsed;
    }
    async function parse(data, format, callback) {
      let fmt = null;
      if (typeof format === "function") {
        callback = format;
      } else if (format === true || format === "little") {
        fmt = "little";
      } else if (format === "big") {
        fmt = "big";
      } else if (format === "littleVarint") {
        fmt = "littleVarint";
      } else if (format) {
        throw new Error("Unrecognized format: " + format);
      }
      data.startOffset = data.startOffset || 0;
      if (!fmt && !data.startOffset) {
        if (hasBedrockLevelHeader(data)) {
          data.startOffset += 8;
          fmt = "little";
        }
      }
      if (fmt) {
        try {
          const res = await parseAs(data, fmt);
          if (callback)
            callback(null, res.data, res.type, res.metadata);
          return { parsed: res.data, type: res.type, metadata: res.metadata };
        } catch (e) {
          if (callback)
            return callback(e);
          else
            throw e;
        }
      }
      const verifyEOF = ({ buffer, size }) => {
        const readLen = size;
        const bufferLen = buffer.length - buffer.startOffset;
        const lastByte = buffer[readLen + buffer.startOffset];
        const nextNbtTag = lastByte === 10;
        if (readLen < bufferLen && !nextNbtTag) {
          throw new Error(`Unexpected EOF at ${readLen}: still have ${bufferLen - readLen} bytes to read !`);
        }
      };
      let ret = null;
      try {
        ret = await parseAs(data, "big");
        verifyEOF(ret.metadata);
      } catch (e) {
        try {
          ret = await parseAs(data, "little");
          verifyEOF(ret.metadata);
        } catch (e2) {
          try {
            ret = await parseAs(data, "littleVarint");
            verifyEOF(ret.metadata);
          } catch (e3) {
            if (callback)
              return callback(e);
            else
              throw e;
          }
        }
      }
      if (callback)
        callback(null, ret.data, ret.type, ret.metadata);
      return { parsed: ret.data, type: ret.type, metadata: ret.metadata };
    }
    function simplify(data) {
      function transform(value, type) {
        if (type === "compound") {
          return Object.keys(value).reduce(function(acc, key) {
            acc[key] = simplify(value[key]);
            return acc;
          }, {});
        }
        if (type === "list") {
          return value.value.map(function(v) {
            return transform(v, value.type);
          });
        }
        return value;
      }
      return transform(data.value, data.type);
    }
    var builder = {
      bool(value = false) {
        return { type: "bool", value };
      },
      short(value) {
        return { type: "short", value };
      },
      byte(value) {
        return { type: "byte", value };
      },
      string(value) {
        return { type: "string", value };
      },
      comp(value, name = "") {
        return { type: "compound", name, value };
      },
      int(value) {
        return { type: "int", value };
      },
      float(value) {
        return { type: "float", value };
      },
      double(value) {
        return { type: "double", value };
      },
      long(value) {
        return { type: "long", value };
      },
      list(value) {
        const type = value?.type ?? "end";
        return { type: "list", value: { type, value: value?.value ?? [] } };
      },
      byteArray(value = []) {
        return { type: "byteArray", value };
      },
      shortArray(value = []) {
        return { type: "shortArray", value };
      },
      intArray(value = []) {
        return { type: "intArray", value };
      },
      longArray(value = []) {
        return { type: "longArray", value };
      }
    };
    module2.exports = {
      writeUncompressed,
      parseUncompressed,
      simplify,
      hasBedrockLevelHeader,
      parse,
      parseAs,
      proto: protoBE,
      protoLE,
      protos,
      TagType: require_tag_type(),
      ...builder
    };
  }
});

// ../node_modules/macaddress/lib/util.js
var require_util3 = __commonJS({
  "../node_modules/macaddress/lib/util.js"(exports2, module2) {
    "use strict";
    var lib = {};
    var nextTick = process.nextTick || global.setImmediate || global.setTimeout;
    lib.nextTick = function(func) {
      nextTick(func);
    };
    lib.parallel = function(tasks, done) {
      var results = [];
      var errs = [];
      var length = 0;
      var doneLength = 0;
      function doneIt(ix, err, result) {
        if (err) {
          errs[ix] = err;
        } else {
          results[ix] = result;
        }
        doneLength += 1;
        if (doneLength >= length) {
          done(errs.length > 0 ? errs : errs, results);
        }
      }
      Object.keys(tasks).forEach(function(key) {
        length += 1;
        var task = tasks[key];
        lib.nextTick(function() {
          task(doneIt.bind(null, key), 1);
        });
      });
    };
    lib.promisify = function(func) {
      return new Promise(function(resolve, reject) {
        func(function(err, data) {
          if (err) {
            if (!err instanceof Error) {
              err = new Error(err);
            }
            reject(err);
            return;
          }
          resolve(data);
        });
      });
    };
    lib.iterate = function(args, func, callback) {
      var errors = [];
      var f = function() {
        if (args.length === 0) {
          lib.nextTick(callback.bind(null, errors));
          return;
        }
        var arg = args.shift();
        if (typeof arg === "function") {
          arg(function(err, res) {
            if (err) {
              errors.push(err);
            } else {
              while (res.length > 0) {
                args.unshift(res.pop());
              }
            }
            f();
          });
          return;
        }
        func(arg, function(err, res) {
          if (err) {
            errors.push(err);
            f();
          } else {
            lib.nextTick(callback.bind(null, null, res));
          }
        });
      };
      lib.nextTick(f);
    };
    module2.exports = lib;
  }
});

// ../node_modules/macaddress/lib/platform/getmacaddress_windows.js
var require_getmacaddress_windows = __commonJS({
  "../node_modules/macaddress/lib/platform/getmacaddress_windows.js"(exports2, module2) {
    var execFile = require("child_process").execFile;
    var regexRegex = /[-\/\\^$*+?.()|[\]{}]/g;
    function escape(string) {
      return string.replace(regexRegex, "\\$&");
    }
    module2.exports = function(iface, callback) {
      execFile("ipconfig", ["/all"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        var match = new RegExp(escape(iface)).exec(out);
        if (!match) {
          callback("did not find interface in `ipconfig /all`", null);
          return;
        }
        out = out.substring(match.index + iface.length);
        match = /[A-Fa-f0-9]{2}(\-[A-Fa-f0-9]{2}){5}/.exec(out);
        if (!match) {
          callback("did not find a mac address", null);
          return;
        }
        callback(null, match[0].toLowerCase().replace(/\-/g, ":"));
      });
    };
  }
});

// ../node_modules/macaddress/lib/platform/getmacaddress_linux.js
var require_getmacaddress_linux = __commonJS({
  "../node_modules/macaddress/lib/platform/getmacaddress_linux.js"(exports2, module2) {
    var execFile = require("child_process").execFile;
    module2.exports = function(iface, callback) {
      execFile("/bin/cat", ["/sys/class/net/" + iface + "/address"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        callback(null, out.trim().toLowerCase());
      });
    };
  }
});

// ../node_modules/macaddress/lib/platform/getmacaddress_unix.js
var require_getmacaddress_unix = __commonJS({
  "../node_modules/macaddress/lib/platform/getmacaddress_unix.js"(exports2, module2) {
    var execFile = require("child_process").execFile;
    module2.exports = function(iface, callback) {
      execFile("ifconfig", [iface], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        var match = /[a-f0-9]{2}(:[a-f0-9]{2}){5}/.exec(out.toLowerCase());
        if (!match) {
          callback("did not find a mac address", null);
          return;
        }
        callback(null, match[0].toLowerCase());
      });
    };
  }
});

// ../node_modules/macaddress/lib/getmacaddress.js
var require_getmacaddress = __commonJS({
  "../node_modules/macaddress/lib/getmacaddress.js"(exports2, module2) {
    var os = require("os");
    var _getMacAddress;
    var _validIfaceRegExp = "^[a-z0-9]+$";
    switch (os.platform()) {
      case "win32":
        _validIfaceRegExp = "^[a-z0-9 -]+$";
        _getMacAddress = require_getmacaddress_windows();
        break;
      case "linux":
        _getMacAddress = require_getmacaddress_linux();
        break;
      case "darwin":
      case "sunos":
      case "freebsd":
        _getMacAddress = require_getmacaddress_unix();
        break;
      default:
        console.warn("node-macaddress: Unknown os.platform(), defaulting to 'unix'.");
        _getMacAddress = require_getmacaddress_unix();
        break;
    }
    var validIfaceRegExp = new RegExp(_validIfaceRegExp, "i");
    module2.exports = function(iface, callback) {
      if (!validIfaceRegExp.test(iface)) {
        callback(new Error([
          "invalid iface: '",
          iface,
          "' (must conform to reg exp /",
          validIfaceRegExp,
          "/)"
        ].join("")), null);
        return;
      }
      _getMacAddress(iface, callback);
    };
  }
});

// ../node_modules/macaddress/lib/platform/getallinterfaces_windows.js
var require_getallinterfaces_windows = __commonJS({
  "../node_modules/macaddress/lib/platform/getallinterfaces_windows.js"(exports2, module2) {
    "use strict";
    var execFile = require("child_process").execFile;
    module2.exports = function(callback) {
      execFile("wmic", ["nic", "get", "NetConnectionID"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        var ifaces = out.trim().replace(/\s{2,}/g, "\n").split("\n").slice(1);
        var result = [];
        for (var i = 0; i < ifaces.length; i += 1) {
          var iface = ifaces[i].trim();
          if (iface !== "") {
            result.push(iface);
          }
        }
        callback(null, result);
      });
    };
  }
});

// ../node_modules/macaddress/lib/platform/getallinterfaces_linux.js
var require_getallinterfaces_linux = __commonJS({
  "../node_modules/macaddress/lib/platform/getallinterfaces_linux.js"(exports2, module2) {
    var execFile = require("child_process").execFile;
    module2.exports = function(callback) {
      execFile("/bin/ls", ["/sys/class/net"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        var ifaces = out.split(/[ \t\n]+/);
        var result = [];
        for (var i = 0; i < ifaces.length; i += 1) {
          var iface = ifaces[i].trim();
          if (iface !== "") {
            result.push(iface);
          }
        }
        callback(null, result);
      });
    };
  }
});

// ../node_modules/macaddress/lib/platform/getallinterfaces_unix.js
var require_getallinterfaces_unix = __commonJS({
  "../node_modules/macaddress/lib/platform/getallinterfaces_unix.js"(exports2, module2) {
    "use strict";
    var execFile = require("child_process").execFile;
    module2.exports = function(callback) {
      execFile("/sbin/ifconfig", ["-l"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        var ifaces = out.split(/[ \t]+/);
        var result = [];
        for (var i = 0; i < ifaces.length; i += 1) {
          var iface = ifaces[i].trim();
          if (iface !== "") {
            result.push(iface);
          }
        }
        callback(null, result);
      });
    };
  }
});

// ../node_modules/macaddress/lib/getallinterfaces.js
var require_getallinterfaces = __commonJS({
  "../node_modules/macaddress/lib/getallinterfaces.js"(exports2, module2) {
    var os = require("os");
    var _getAllInterfaces;
    switch (os.platform()) {
      case "win32":
        _getAllInterfaces = require_getallinterfaces_windows();
        break;
      case "linux":
        _getAllInterfaces = require_getallinterfaces_linux();
        break;
      case "darwin":
      case "sunos":
      case "freebsd":
        _getAllInterfaces = require_getallinterfaces_unix();
        break;
      default:
        console.warn("node-macaddress: Unknown os.platform(), defaulting to 'unix'.");
        _getAllInterfaces = require_getallinterfaces_unix();
        break;
    }
    module2.exports = _getAllInterfaces;
  }
});

// ../node_modules/macaddress/lib/networkinterfaces.js
var require_networkinterfaces = __commonJS({
  "../node_modules/macaddress/lib/networkinterfaces.js"(exports2, module2) {
    var os = require("os");
    module2.exports = function() {
      var allAddresses = {};
      try {
        var ifaces = os.networkInterfaces();
      } catch (e) {
        if (e.syscall === "uv_interface_addresses") {
          return allAddresses;
        } else {
          throw e;
        }
      }
      Object.keys(ifaces).forEach(function(iface) {
        var addresses = {};
        var hasAddresses = false;
        ifaces[iface].forEach(function(address) {
          if (!address.internal) {
            var family = typeof address.family === "number" ? "ipv" + address.family : (address.family || "").toLowerCase();
            addresses[family] = address.address;
            hasAddresses = true;
            if (address.mac && address.mac !== "00:00:00:00:00:00") {
              addresses.mac = address.mac;
            }
          }
        });
        if (hasAddresses) {
          allAddresses[iface] = addresses;
        }
      });
      return allAddresses;
    };
  }
});

// ../node_modules/macaddress/index.js
var require_macaddress = __commonJS({
  "../node_modules/macaddress/index.js"(exports2, module2) {
    "use strict";
    var util = require_util3();
    var lib = {};
    lib.getMacAddress = require_getmacaddress();
    lib.getAllInterfaces = require_getallinterfaces();
    lib.networkInterfaces = require_networkinterfaces();
    var goodIfaces = new RegExp("^((en|eth)[0-9]+|ethernet)$", "i");
    var badIfaces = new RegExp("^(vboxnet[0-9]+)$", "i");
    lib.one = function() {
      var iface = null;
      var callback = null;
      if (arguments.length >= 1) {
        if (typeof arguments[0] === "function") {
          callback = arguments[0];
        } else if (typeof arguments[0] === "string") {
          iface = arguments[0];
        }
        if (arguments.length >= 2) {
          if (typeof arguments[1] === "function") {
            callback = arguments[1];
          }
        }
      }
      if (!callback) {
        return util.promisify(function(callback2) {
          lib.one(iface, callback2);
        });
      }
      if (iface) {
        lib.getMacAddress(iface, callback);
        return;
      }
      var ifaces = lib.networkInterfaces();
      var addresses = {};
      var best = [];
      var args = [];
      Object.keys(ifaces).forEach(function(name) {
        args.push(name);
        var score = 0;
        var iface2 = ifaces[name];
        if (typeof iface2.mac === "string" && iface2.mac !== "00:00:00:00:00:00") {
          addresses[name] = iface2.mac;
          if (iface2.ipv4) {
            score += 1;
          }
          if (iface2.ipv6) {
            score += 1;
          }
          if (goodIfaces.test(name)) {
            score += 2;
          }
          if (badIfaces.test(name)) {
            score -= 3;
          }
          best.push({
            name,
            score,
            mac: iface2.mac
          });
        }
      });
      if (best.length > 0) {
        best.sort(function(left, right) {
          var comparison = right.score - left.score;
          if (comparison !== 0) {
            return comparison;
          }
          if (left.name < right.name) {
            return -1;
          }
          if (left.name > right.name) {
            return 1;
          }
          return 0;
        });
        util.nextTick(callback.bind(null, null, best[0].mac));
        return;
      }
      args.push(lib.getAllInterfaces);
      var getMacAddress = function(d, cb) {
        if (addresses[d]) {
          cb(null, addresses[d]);
          return;
        }
        lib.getMacAddress(d, cb);
      };
      util.iterate(args, getMacAddress, callback);
    };
    lib.all = function(callback) {
      if (typeof callback !== "function") {
        return util.promisify(lib.all);
      }
      var ifaces = lib.networkInterfaces();
      var resolve = {};
      Object.keys(ifaces).forEach(function(iface) {
        if (!ifaces[iface].mac) {
          resolve[iface] = lib.getMacAddress.bind(null, iface);
        }
      });
      if (Object.keys(resolve).length === 0) {
        if (typeof callback === "function") {
          util.nextTick(callback.bind(null, null, ifaces));
        }
        return ifaces;
      }
      util.parallel(resolve, function(err, result) {
        Object.keys(result).forEach(function(iface) {
          ifaces[iface].mac = result[iface];
        });
        if (typeof callback === "function") {
          callback(null, ifaces);
        }
      });
      return null;
    };
    module2.exports = lib;
  }
});

// ../node_modules/uuid-1345/index.js
var require_uuid_1345 = __commonJS({
  "../node_modules/uuid-1345/index.js"(exports2, module2) {
    var crypto = require("crypto");
    var invalidNamespace = "options.namespace must be a string or a Buffer containing a valid UUID, or a UUID object";
    var invalidName = "options.name must be either a string or a Buffer";
    var moreThan10000 = "can not generate more than 10000 UUIDs per second";
    var randomHost = crypto.randomBytes(16);
    randomHost[0] = randomHost[0] | 1;
    var seed = crypto.randomBytes(2);
    var clockSeq = (seed[0] | seed[1] << 8) & 16383;
    var lastMTime = 0;
    var lastNTime = 0;
    var hex2byte = {};
    var byte2hex = [];
    for (i = 0; i < 256; i++) {
      hex = (i + 256).toString(16).substr(1);
      hex2byte[hex] = i;
      byte2hex[i] = hex;
    }
    var hex;
    var i;
    var newBufferFromSize;
    var newBufferFromBuffer;
    if (Buffer.allocUnsafe) {
      newBufferFromSize = function newBufferFromSize2(size) {
        return Buffer.allocUnsafe(size);
      };
      newBufferFromBuffer = function newBufferFromBuffer2(buf) {
        return Buffer.from(buf);
      };
    } else {
      newBufferFromSize = function(size) {
        return new Buffer(size);
      };
      newBufferFromBuffer = function(buf) {
        return new Buffer(buf);
      };
    }
    function parseMacAddress(address) {
      var buffer = newBufferFromSize(6);
      buffer[0] = hex2byte[address[0] + address[1]];
      buffer[1] = hex2byte[address[3] + address[4]];
      buffer[2] = hex2byte[address[6] + address[7]];
      buffer[3] = hex2byte[address[9] + address[10]];
      buffer[4] = hex2byte[address[12] + address[13]];
      buffer[5] = hex2byte[address[15] + address[16]];
      return buffer;
    }
    var macAddress = randomHost;
    var macAddressLoaded = false;
    function loadMacAddress() {
      require_macaddress().one(function(err, result) {
        if (!err) {
          macAddress = parseMacAddress(result);
        }
        macAddressLoaded = true;
      });
    }
    var UUID = function(uuid) {
      var check2 = UUID.check(uuid);
      if (!check2) {
        throw "not a UUID";
      }
      this.version = check2.version;
      this.variant = check2.variant;
      this[check2.format] = uuid;
    };
    UUID.prototype.toString = function() {
      if (!this.ascii) {
        this.ascii = UUID.stringify(this.binary);
      }
      return this.ascii;
    };
    UUID.prototype.toBuffer = function() {
      if (!this.binary) {
        this.binary = UUID.parse(this.ascii);
      }
      return newBufferFromBuffer(this.binary);
    };
    UUID.prototype.inspect = function() {
      return "UUID v" + this.version + " " + this.toString();
    };
    function error(message, callback) {
      if (callback) {
        callback(message, null);
      } else {
        throw new Error(message);
      }
    }
    function parse(string) {
      var buffer = newBufferFromSize(16);
      var j = 0;
      for (var i2 = 0; i2 < 16; i2++) {
        buffer[i2] = hex2byte[string[j++] + string[j++]];
        if (i2 === 3 || i2 === 5 || i2 === 7 || i2 === 9) {
          j += 1;
        }
      }
      return buffer;
    }
    function getVariant(bits) {
      switch (bits) {
        case 0:
        case 1:
        case 3:
          return "ncs";
        case 4:
        case 5:
          return "rfc4122";
        case 6:
          return "microsoft";
        default:
          return "future";
      }
    }
    function check(uuid, offset) {
      if (typeof uuid === "string") {
        uuid = uuid.toLowerCase();
        if (!/^[a-f0-9]{8}(\-[a-f0-9]{4}){3}\-([a-f0-9]{12})$/.test(uuid)) {
          return false;
        }
        if (uuid === "00000000-0000-0000-0000-000000000000") {
          return { version: void 0, variant: "nil", format: "ascii" };
        }
        return {
          version: (hex2byte[uuid[14] + uuid[15]] & 240) >> 4,
          variant: getVariant((hex2byte[uuid[19] + uuid[20]] & 224) >> 5),
          format: "ascii"
        };
      }
      if (uuid instanceof Buffer) {
        offset = offset || 0;
        if (uuid.length < offset + 16) {
          return false;
        }
        for (var i2 = 0; i2 < 16; i2++) {
          if (uuid[offset + i2] !== 0) {
            break;
          }
        }
        if (i2 === 16) {
          return { version: void 0, variant: "nil", format: "binary" };
        }
        return {
          version: (uuid[offset + 6] & 240) >> 4,
          variant: getVariant((uuid[offset + 8] & 224) >> 5),
          format: "binary"
        };
      }
    }
    function uuidTimeBased(nodeId, options, callback) {
      var mTime = Date.now();
      var nTime = lastNTime + 1;
      var delta = mTime - lastMTime + (nTime - lastNTime) / 1e4;
      if (delta < 0) {
        clockSeq = clockSeq + 1 & 16383;
        nTime = 0;
      } else if (mTime > lastMTime) {
        nTime = 0;
      } else if (nTime >= 1e4) {
        return moreThan10000;
      }
      lastMTime = mTime;
      lastNTime = nTime;
      mTime += 122192928e5;
      var buffer = newBufferFromSize(16);
      var myClockSeq = options.clockSeq === void 0 ? clockSeq : options.clockSeq & 16383;
      var timeLow = ((mTime & 268435455) * 1e4 + nTime) % 4294967296;
      var timeHigh = mTime / 4294967296 * 1e4 & 268435455;
      buffer[0] = timeLow >>> 24 & 255;
      buffer[1] = timeLow >>> 16 & 255;
      buffer[2] = timeLow >>> 8 & 255;
      buffer[3] = timeLow & 255;
      buffer[4] = timeHigh >>> 8 & 255;
      buffer[5] = timeHigh & 255;
      buffer[6] = timeHigh >>> 24 & 15 | 16;
      buffer[7] = timeHigh >>> 16 & 63 | 128;
      buffer[8] = myClockSeq >>> 8;
      buffer[9] = myClockSeq & 255;
      var result;
      switch (options.encoding && options.encoding[0]) {
        case "b":
        case "B":
          buffer[10] = nodeId[0];
          buffer[11] = nodeId[1];
          buffer[12] = nodeId[2];
          buffer[13] = nodeId[3];
          buffer[14] = nodeId[4];
          buffer[15] = nodeId[5];
          result = buffer;
          break;
        case "o":
        case "U":
          buffer[10] = nodeId[0];
          buffer[11] = nodeId[1];
          buffer[12] = nodeId[2];
          buffer[13] = nodeId[3];
          buffer[14] = nodeId[4];
          buffer[15] = nodeId[5];
          result = new UUID(buffer);
          break;
        default:
          result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[nodeId[0]] + byte2hex[nodeId[1]] + byte2hex[nodeId[2]] + byte2hex[nodeId[3]] + byte2hex[nodeId[4]] + byte2hex[nodeId[5]];
          break;
      }
      if (callback) {
        setImmediate(function() {
          callback(null, result);
        });
      }
      return result;
    }
    function uuidNamed(hashFunc, version, arg1, arg2) {
      var options = arg1 || {};
      var callback = typeof arg1 === "function" ? arg1 : arg2;
      var namespace = options.namespace;
      var name = options.name;
      var hash = crypto.createHash(hashFunc);
      if (typeof namespace === "string") {
        if (!check(namespace)) {
          return error(invalidNamespace, callback);
        }
        namespace = parse(namespace);
      } else if (namespace instanceof UUID) {
        namespace = namespace.toBuffer();
      } else if (!(namespace instanceof Buffer) || namespace.length !== 16) {
        return error(invalidNamespace, callback);
      }
      var nameIsNotAString = typeof name !== "string";
      if (nameIsNotAString && !(name instanceof Buffer)) {
        return error(invalidName, callback);
      }
      hash.update(namespace);
      hash.update(options.name, nameIsNotAString ? "binary" : "utf8");
      var buffer = hash.digest();
      var result;
      switch (options.encoding && options.encoding[0]) {
        case "b":
        case "B":
          buffer[6] = buffer[6] & 15 | version;
          buffer[8] = buffer[8] & 63 | 128;
          result = buffer;
          break;
        case "o":
        case "U":
          buffer[6] = buffer[6] & 15 | version;
          buffer[8] = buffer[8] & 63 | 128;
          result = new UUID(buffer);
          break;
        default:
          result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 15 | version] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
          break;
      }
      if (callback) {
        setImmediate(function() {
          callback(null, result);
        });
      } else {
        return result;
      }
    }
    function uuidRandom(arg1, arg2) {
      var options = arg1 || {};
      var callback = typeof arg1 === "function" ? arg1 : arg2;
      var buffer = crypto.randomBytes(16);
      buffer[6] = buffer[6] & 15 | 64;
      buffer[8] = buffer[8] & 63 | 128;
      var result;
      switch (options.encoding && options.encoding[0]) {
        case "b":
        case "B":
          result = buffer;
          break;
        case "o":
        case "U":
          result = new UUID(buffer);
          break;
        default:
          result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 15 | 64] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
          break;
      }
      if (callback) {
        setImmediate(function() {
          callback(null, result);
        });
      } else {
        return result;
      }
    }
    function uuidRandomFast() {
      var r1 = Math.random() * 4294967296;
      var r2 = Math.random() * 4294967296;
      var r3 = Math.random() * 4294967296;
      var r4 = Math.random() * 4294967296;
      return byte2hex[r1 & 255] + byte2hex[r1 >>> 8 & 255] + byte2hex[r1 >>> 16 & 255] + byte2hex[r1 >>> 24 & 255] + "-" + byte2hex[r2 & 255] + byte2hex[r2 >>> 8 & 255] + "-" + byte2hex[r2 >>> 16 & 15 | 64] + byte2hex[r2 >>> 24 & 255] + "-" + byte2hex[r3 & 63 | 128] + byte2hex[r3 >>> 8 & 255] + "-" + byte2hex[r3 >>> 16 & 255] + byte2hex[r3 >>> 24 & 255] + byte2hex[r4 & 255] + byte2hex[r4 >>> 8 & 255] + byte2hex[r4 >>> 16 & 255] + byte2hex[r4 >>> 24 & 255];
    }
    function stringify(buffer) {
      return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
    }
    UUID.stringify = stringify;
    UUID.parse = parse;
    UUID.check = check;
    UUID.nil = new UUID("00000000-0000-0000-0000-000000000000");
    UUID.namespace = {
      dns: new UUID("6ba7b810-9dad-11d1-80b4-00c04fd430c8"),
      url: new UUID("6ba7b811-9dad-11d1-80b4-00c04fd430c8"),
      oid: new UUID("6ba7b812-9dad-11d1-80b4-00c04fd430c8"),
      x500: new UUID("6ba7b814-9dad-11d1-80b4-00c04fd430c8")
    };
    UUID.v1 = function v1(arg1, arg2) {
      var options = arg1 || {};
      var callback = typeof arg1 === "function" ? arg1 : arg2;
      var nodeId = options.mac;
      if (nodeId === void 0) {
        if (!macAddressLoaded) {
          loadMacAddress();
        }
        if (!macAddressLoaded && callback) {
          setImmediate(function() {
            UUID.v1(options, callback);
          });
          return;
        }
        return uuidTimeBased(macAddress, options, callback);
      }
      if (nodeId === false) {
        return uuidTimeBased(randomHost, options, callback);
      }
      return uuidTimeBased(parseMacAddress(nodeId), options, callback);
    };
    UUID.v4 = uuidRandom;
    UUID.v4fast = uuidRandomFast;
    UUID.v3 = function(options, callback) {
      return uuidNamed("md5", 48, options, callback);
    };
    UUID.v5 = function(options, callback) {
      return uuidNamed("sha1", 80, options, callback);
    };
    module2.exports = UUID;
  }
});

// ../node_modules/minecraft-protocol/src/datatypes/minecraft.js
var require_minecraft = __commonJS({
  "../node_modules/minecraft-protocol/src/datatypes/minecraft.js"(exports2, module2) {
    "use strict";
    var nbt = require_nbt2();
    var UUID = require_uuid_1345();
    var zlib = require("zlib");
    var [readVarInt, writeVarInt, sizeOfVarInt] = require_protodef2().types.varint;
    module2.exports = {
      varlong: [readVarLong, writeVarLong, sizeOfVarLong],
      UUID: [readUUID, writeUUID, 16],
      nbt: [readNbt, writeNbt, sizeOfNbt],
      optionalNbt: [readOptionalNbt, writeOptionalNbt, sizeOfOptionalNbt],
      compressedNbt: [readCompressedNbt, writeCompressedNbt, sizeOfCompressedNbt],
      restBuffer: [readRestBuffer, writeRestBuffer, sizeOfRestBuffer],
      entityMetadataLoop: [readEntityMetadata, writeEntityMetadata, sizeOfEntityMetadata],
      topBitSetTerminatedArray: [readTopBitSetTerminatedArray, writeTopBitSetTerminatedArray, sizeOfTopBitSetTerminatedArray]
    };
    var PartialReadError2 = require_protodef2().utils.PartialReadError;
    function readVarLong(buffer, offset) {
      return readVarInt(buffer, offset);
    }
    function writeVarLong(value, buffer, offset) {
      return writeVarInt(value, buffer, offset);
    }
    function sizeOfVarLong(value) {
      return sizeOfVarInt(value);
    }
    function readUUID(buffer, offset) {
      if (offset + 16 > buffer.length) {
        throw new PartialReadError2();
      }
      return {
        value: UUID.stringify(buffer.slice(offset, 16 + offset)),
        size: 16
      };
    }
    function writeUUID(value, buffer, offset) {
      const buf = UUID.parse(value);
      buf.copy(buffer, offset);
      return offset + 16;
    }
    function readNbt(buffer, offset) {
      return nbt.proto.read(buffer, offset, "nbt");
    }
    function writeNbt(value, buffer, offset) {
      return nbt.proto.write(value, buffer, offset, "nbt");
    }
    function sizeOfNbt(value) {
      return nbt.proto.sizeOf(value, "nbt");
    }
    function readOptionalNbt(buffer, offset) {
      if (offset + 1 > buffer.length) {
        throw new PartialReadError2();
      }
      if (buffer.readInt8(offset) === 0)
        return { size: 1 };
      return nbt.proto.read(buffer, offset, "nbt");
    }
    function writeOptionalNbt(value, buffer, offset) {
      if (value === void 0) {
        buffer.writeInt8(0, offset);
        return offset + 1;
      }
      return nbt.proto.write(value, buffer, offset, "nbt");
    }
    function sizeOfOptionalNbt(value) {
      if (value === void 0) {
        return 1;
      }
      return nbt.proto.sizeOf(value, "nbt");
    }
    function readCompressedNbt(buffer, offset) {
      if (offset + 2 > buffer.length) {
        throw new PartialReadError2();
      }
      const length = buffer.readInt16BE(offset);
      if (length === -1)
        return { size: 2 };
      if (offset + 2 + length > buffer.length) {
        throw new PartialReadError2();
      }
      const compressedNbt = buffer.slice(offset + 2, offset + 2 + length);
      const nbtBuffer = zlib.gunzipSync(compressedNbt);
      const results = nbt.proto.read(nbtBuffer, 0, "nbt");
      return {
        size: length + 2,
        value: results.value
      };
    }
    function writeCompressedNbt(value, buffer, offset) {
      if (value === void 0) {
        buffer.writeInt16BE(-1, offset);
        return offset + 2;
      }
      const nbtBuffer = Buffer.alloc(sizeOfNbt(value));
      nbt.proto.write(value, nbtBuffer, 0, "nbt");
      const compressedNbt = zlib.gzipSync(nbtBuffer);
      compressedNbt.writeUInt8(0, 9);
      buffer.writeInt16BE(compressedNbt.length, offset);
      compressedNbt.copy(buffer, offset + 2);
      return offset + 2 + compressedNbt.length;
    }
    function sizeOfCompressedNbt(value) {
      if (value === void 0) {
        return 2;
      }
      const nbtBuffer = Buffer.alloc(sizeOfNbt(value, "nbt"));
      nbt.proto.write(value, nbtBuffer, 0, "nbt");
      const compressedNbt = zlib.gzipSync(nbtBuffer);
      return 2 + compressedNbt.length;
    }
    function readRestBuffer(buffer, offset) {
      return {
        value: buffer.slice(offset),
        size: buffer.length - offset
      };
    }
    function writeRestBuffer(value, buffer, offset) {
      value.copy(buffer, offset);
      return offset + value.length;
    }
    function sizeOfRestBuffer(value) {
      return value.length;
    }
    function readEntityMetadata(buffer, offset, { type, endVal }) {
      let cursor = offset;
      const metadata = [];
      let item;
      while (true) {
        if (offset + 1 > buffer.length) {
          throw new PartialReadError2();
        }
        item = buffer.readUInt8(cursor);
        if (item === endVal) {
          return {
            value: metadata,
            size: cursor + 1 - offset
          };
        }
        const results = this.read(buffer, cursor, type, {});
        metadata.push(results.value);
        cursor += results.size;
      }
    }
    function writeEntityMetadata(value, buffer, offset, { type, endVal }) {
      const self2 = this;
      value.forEach(function(item) {
        offset = self2.write(item, buffer, offset, type, {});
      });
      buffer.writeUInt8(endVal, offset);
      return offset + 1;
    }
    function sizeOfEntityMetadata(value, { type }) {
      let size = 1;
      for (let i = 0; i < value.length; ++i) {
        size += this.sizeOf(value[i], type, {});
      }
      return size;
    }
    function readTopBitSetTerminatedArray(buffer, offset, { type }) {
      let cursor = offset;
      const values = [];
      let item;
      while (true) {
        if (offset + 1 > buffer.length) {
          throw new PartialReadError2();
        }
        item = buffer.readUInt8(cursor);
        buffer[cursor] = buffer[cursor] & 127;
        const results = this.read(buffer, cursor, type, {});
        values.push(results.value);
        cursor += results.size;
        if ((item & 128) === 0) {
          return {
            value: values,
            size: cursor - offset
          };
        }
      }
    }
    function writeTopBitSetTerminatedArray(value, buffer, offset, { type }) {
      const self2 = this;
      let prevOffset = offset;
      value.forEach(function(item, i) {
        prevOffset = offset;
        offset = self2.write(item, buffer, offset, type, {});
        buffer[prevOffset] = i !== value.length - 1 ? buffer[prevOffset] | 128 : buffer[prevOffset];
      });
      return offset;
    }
    function sizeOfTopBitSetTerminatedArray(value, { type }) {
      let size = 0;
      for (let i = 0; i < value.length; ++i) {
        size += this.sizeOf(value[i], type, {});
      }
      return size;
    }
  }
});

// ../node_modules/lodash.merge/index.js
var require_lodash3 = __commonJS({
  "../node_modules/lodash.merge/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module2.exports = merge;
  }
});

// node_modules/minecraft-data/minecraft-data/data/pc/1.19/protocol.json
var protocol_default;
var init_protocol = __esm({
  "node_modules/minecraft-data/minecraft-data/data/pc/1.19/protocol.json"() {
    protocol_default = {
      types: {
        varint: "native",
        optvarint: "varint",
        pstring: "native",
        buffer: "native",
        u8: "native",
        u16: "native",
        u32: "native",
        u64: "native",
        i8: "native",
        i16: "native",
        i32: "native",
        i64: "native",
        bool: "native",
        f32: "native",
        f64: "native",
        UUID: "native",
        option: "native",
        entityMetadataLoop: "native",
        topBitSetTerminatedArray: "native",
        bitfield: "native",
        container: "native",
        switch: "native",
        void: "native",
        array: "native",
        restBuffer: "native",
        nbt: "native",
        optionalNbt: "native",
        string: [
          "pstring",
          {
            countType: "varint"
          }
        ],
        slot: [
          "container",
          [
            {
              name: "present",
              type: "bool"
            },
            {
              anon: true,
              type: [
                "switch",
                {
                  compareTo: "present",
                  fields: {
                    false: "void",
                    true: [
                      "container",
                      [
                        {
                          name: "itemId",
                          type: "varint"
                        },
                        {
                          name: "itemCount",
                          type: "i8"
                        },
                        {
                          name: "nbtData",
                          type: "optionalNbt"
                        }
                      ]
                    ]
                  }
                }
              ]
            }
          ]
        ],
        particle: [
          "container",
          [
            {
              name: "particleId",
              type: "varint"
            },
            {
              name: "data",
              type: [
                "particleData",
                {
                  compareTo: "particleId"
                }
              ]
            }
          ]
        ],
        particleData: [
          "switch",
          {
            compareTo: "$compareTo",
            fields: {
              "2": [
                "container",
                [
                  {
                    name: "blockState",
                    type: "varint"
                  }
                ]
              ],
              "3": [
                "container",
                [
                  {
                    name: "blockState",
                    type: "varint"
                  }
                ]
              ],
              "14": [
                "container",
                [
                  {
                    name: "red",
                    type: "f32"
                  },
                  {
                    name: "green",
                    type: "f32"
                  },
                  {
                    name: "blue",
                    type: "f32"
                  },
                  {
                    name: "scale",
                    type: "f32"
                  }
                ]
              ],
              "15": [
                "container",
                [
                  {
                    name: "fromRed",
                    type: "f32"
                  },
                  {
                    name: "fromGreen",
                    type: "f32"
                  },
                  {
                    name: "fromBlue",
                    type: "f32"
                  },
                  {
                    name: "scale",
                    type: "f32"
                  },
                  {
                    name: "toRed",
                    type: "f32"
                  },
                  {
                    name: "toGreen",
                    type: "f32"
                  },
                  {
                    name: "toBlue",
                    type: "f32"
                  }
                ]
              ],
              "24": [
                "container",
                [
                  {
                    name: "blockState",
                    type: "varint"
                  }
                ]
              ],
              "35": [
                "container",
                [
                  {
                    name: "item",
                    type: "slot"
                  }
                ]
              ],
              "36": [
                "container",
                [
                  {
                    name: "origin",
                    type: "position"
                  },
                  {
                    name: "positionType",
                    type: "string"
                  },
                  {
                    name: "destination",
                    type: [
                      "switch",
                      {
                        compareTo: "positionType",
                        fields: {
                          "minecraft:block": "position",
                          "minecraft:entity": "varint"
                        }
                      }
                    ]
                  },
                  {
                    name: "ticks",
                    type: "varint"
                  }
                ]
              ]
            },
            default: "void"
          }
        ],
        ingredient: [
          "array",
          {
            countType: "varint",
            type: "slot"
          }
        ],
        position: [
          "bitfield",
          [
            {
              name: "x",
              size: 26,
              signed: true
            },
            {
              name: "z",
              size: 26,
              signed: true
            },
            {
              name: "y",
              size: 12,
              signed: true
            }
          ]
        ],
        entityMetadataItem: [
          "switch",
          {
            compareTo: "$compareTo",
            fields: {
              "0": "i8",
              "1": "varint",
              "2": "f32",
              "3": "string",
              "4": "string",
              "5": [
                "option",
                "string"
              ],
              "6": "slot",
              "7": "bool",
              "8": [
                "container",
                [
                  {
                    name: "pitch",
                    type: "f32"
                  },
                  {
                    name: "yaw",
                    type: "f32"
                  },
                  {
                    name: "roll",
                    type: "f32"
                  }
                ]
              ],
              "9": "position",
              "10": [
                "option",
                "position"
              ],
              "11": "varint",
              "12": [
                "option",
                "UUID"
              ],
              "13": "varint",
              "14": "nbt",
              "15": "particle",
              "16": [
                "container",
                [
                  {
                    name: "villagerType",
                    type: "varint"
                  },
                  {
                    name: "villagerProfession",
                    type: "varint"
                  },
                  {
                    name: "level",
                    type: "varint"
                  }
                ]
              ],
              "17": "optvarint",
              "18": "varint"
            }
          }
        ],
        entityMetadata: [
          "entityMetadataLoop",
          {
            endVal: 255,
            type: [
              "container",
              [
                {
                  anon: true,
                  type: [
                    "container",
                    [
                      {
                        name: "key",
                        type: "u8"
                      },
                      {
                        name: "type",
                        type: "varint"
                      }
                    ]
                  ]
                },
                {
                  name: "value",
                  type: [
                    "entityMetadataItem",
                    {
                      compareTo: "type"
                    }
                  ]
                }
              ]
            ]
          }
        ],
        minecraft_smelting_format: [
          "container",
          [
            {
              name: "group",
              type: "string"
            },
            {
              name: "ingredient",
              type: "ingredient"
            },
            {
              name: "result",
              type: "slot"
            },
            {
              name: "experience",
              type: "f32"
            },
            {
              name: "cookTime",
              type: "varint"
            }
          ]
        ],
        tags: [
          "array",
          {
            countType: "varint",
            type: [
              "container",
              [
                {
                  name: "tagName",
                  type: "string"
                },
                {
                  name: "entries",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "varint"
                    }
                  ]
                }
              ]
            ]
          }
        ],
        chunkBlockEntity: [
          "container",
          [
            {
              anon: true,
              type: [
                "bitfield",
                [
                  {
                    name: "x",
                    size: 4,
                    signed: false
                  },
                  {
                    name: "z",
                    size: 4,
                    signed: false
                  }
                ]
              ]
            },
            {
              name: "y",
              type: "i16"
            },
            {
              name: "type",
              type: "varint"
            },
            {
              name: "nbtData",
              type: "optionalNbt"
            }
          ]
        ],
        command_node: [
          "container",
          [
            {
              name: "flags",
              type: [
                "bitfield",
                [
                  {
                    name: "unused",
                    size: 3,
                    signed: false
                  },
                  {
                    name: "has_custom_suggestions",
                    size: 1,
                    signed: false
                  },
                  {
                    name: "has_redirect_node",
                    size: 1,
                    signed: false
                  },
                  {
                    name: "has_command",
                    size: 1,
                    signed: false
                  },
                  {
                    name: "command_node_type",
                    size: 2,
                    signed: false
                  }
                ]
              ]
            },
            {
              name: "children",
              type: [
                "array",
                {
                  countType: "varint",
                  type: "varint"
                }
              ]
            },
            {
              name: "redirectNode",
              type: [
                "switch",
                {
                  compareTo: "flags/has_redirect_node",
                  fields: {
                    "1": "varint"
                  },
                  default: "void"
                }
              ]
            },
            {
              name: "extraNodeData",
              type: [
                "switch",
                {
                  compareTo: "flags/command_node_type",
                  fields: {
                    "0": "void",
                    "1": [
                      "container",
                      [
                        {
                          name: "name",
                          type: "string"
                        }
                      ]
                    ],
                    "2": [
                      "container",
                      [
                        {
                          name: "name",
                          type: "string"
                        },
                        {
                          name: "parser",
                          type: [
                            "mapper",
                            {
                              type: "varint",
                              mappings: {
                                "0": "brigadier:bool",
                                "1": "brigadier:float",
                                "2": "brigadier:double",
                                "3": "brigadier:integer",
                                "4": "brigadier:long",
                                "5": "brigadier:string",
                                "6": "minecraft:entity",
                                "7": "minecraft:game_profile",
                                "8": "minecraft:block_pos",
                                "9": "minecraft:column_pos",
                                "10": "minecraft:vec3",
                                "11": "minecraft:vec2",
                                "12": "minecraft:block_state",
                                "13": "minecraft:block_predicate",
                                "14": "minecraft:item_stack",
                                "15": "minecraft:item_predicate",
                                "16": "minecraft:color",
                                "17": "minecraft:component",
                                "18": "minecraft:message",
                                "19": "minecraft:nbt",
                                "20": "minecraft:nbt_tag",
                                "21": "minecraft:nbt_path",
                                "22": "minecraft:objective",
                                "23": "minecraft:objective_criteria",
                                "24": "minecraft:operation",
                                "25": "minecraft:particle",
                                "26": "minecraft:angle",
                                "27": "minecraft:rotation",
                                "28": "minecraft:scoreboard_slot",
                                "29": "minecraft:score_holder",
                                "30": "minecraft:swizzle",
                                "31": "minecraft:team",
                                "32": "minecraft:item_slot",
                                "33": "minecraft:resource_location",
                                "34": "minecraft:mob_effect",
                                "35": "minecraft:function",
                                "36": "minecraft:entity_anchor",
                                "37": "minecraft:int_range",
                                "38": "minecraft:float_range",
                                "39": "minecraft:item_enchantment",
                                "40": "minecraft:entity_summon",
                                "41": "minecraft:dimension",
                                "42": "minecraft:time",
                                "43": "minecraft:resource_or_tag",
                                "44": "minecraft:resource",
                                "45": "template_mirror",
                                "46": "template_rotation",
                                "47": "minecraft:uuid"
                              }
                            }
                          ]
                        },
                        {
                          name: "properties",
                          type: [
                            "switch",
                            {
                              compareTo: "parser",
                              fields: {
                                "brigadier:bool": "void",
                                "brigadier:float": [
                                  "container",
                                  [
                                    {
                                      name: "flags",
                                      type: [
                                        "bitfield",
                                        [
                                          {
                                            name: "unused",
                                            size: 6,
                                            signed: false
                                          },
                                          {
                                            name: "max_present",
                                            size: 1,
                                            signed: false
                                          },
                                          {
                                            name: "min_present",
                                            size: 1,
                                            signed: false
                                          }
                                        ]
                                      ]
                                    },
                                    {
                                      name: "min",
                                      type: [
                                        "switch",
                                        {
                                          compareTo: "flags/min_present",
                                          fields: {
                                            "1": "f32"
                                          },
                                          default: "void"
                                        }
                                      ]
                                    },
                                    {
                                      name: "max",
                                      type: [
                                        "switch",
                                        {
                                          compareTo: "flags/max_present",
                                          fields: {
                                            "1": "f32"
                                          },
                                          default: "void"
                                        }
                                      ]
                                    }
                                  ]
                                ],
                                "brigadier:double": [
                                  "container",
                                  [
                                    {
                                      name: "flags",
                                      type: [
                                        "bitfield",
                                        [
                                          {
                                            name: "unused",
                                            size: 6,
                                            signed: false
                                          },
                                          {
                                            name: "max_present",
                                            size: 1,
                                            signed: false
                                          },
                                          {
                                            name: "min_present",
                                            size: 1,
                                            signed: false
                                          }
                                        ]
                                      ]
                                    },
                                    {
                                      name: "min",
                                      type: [
                                        "switch",
                                        {
                                          compareTo: "flags/min_present",
                                          fields: {
                                            "1": "f64"
                                          },
                                          default: "void"
                                        }
                                      ]
                                    },
                                    {
                                      name: "max",
                                      type: [
                                        "switch",
                                        {
                                          compareTo: "flags/max_present",
                                          fields: {
                                            "1": "f64"
                                          },
                                          default: "void"
                                        }
                                      ]
                                    }
                                  ]
                                ],
                                "brigadier:integer": [
                                  "container",
                                  [
                                    {
                                      name: "flags",
                                      type: [
                                        "bitfield",
                                        [
                                          {
                                            name: "unused",
                                            size: 6,
                                            signed: false
                                          },
                                          {
                                            name: "max_present",
                                            size: 1,
                                            signed: false
                                          },
                                          {
                                            name: "min_present",
                                            size: 1,
                                            signed: false
                                          }
                                        ]
                                      ]
                                    },
                                    {
                                      name: "min",
                                      type: [
                                        "switch",
                                        {
                                          compareTo: "flags/min_present",
                                          fields: {
                                            "1": "i32"
                                          },
                                          default: "void"
                                        }
                                      ]
                                    },
                                    {
                                      name: "max",
                                      type: [
                                        "switch",
                                        {
                                          compareTo: "flags/max_present",
                                          fields: {
                                            "1": "i32"
                                          },
                                          default: "void"
                                        }
                                      ]
                                    }
                                  ]
                                ],
                                "brigadier:long": [
                                  "container",
                                  [
                                    {
                                      name: "flags",
                                      type: [
                                        "bitfield",
                                        [
                                          {
                                            name: "unused",
                                            size: 6,
                                            signed: false
                                          },
                                          {
                                            name: "max_present",
                                            size: 1,
                                            signed: false
                                          },
                                          {
                                            name: "min_present",
                                            size: 1,
                                            signed: false
                                          }
                                        ]
                                      ]
                                    },
                                    {
                                      name: "min",
                                      type: [
                                        "switch",
                                        {
                                          compareTo: "flags/min_present",
                                          fields: {
                                            "1": "i64"
                                          },
                                          default: "void"
                                        }
                                      ]
                                    },
                                    {
                                      name: "max",
                                      type: [
                                        "switch",
                                        {
                                          compareTo: "flags/max_present",
                                          fields: {
                                            "1": "i64"
                                          },
                                          default: "void"
                                        }
                                      ]
                                    }
                                  ]
                                ],
                                "brigadier:string": [
                                  "mapper",
                                  {
                                    type: "varint",
                                    mappings: {
                                      "0": "SINGLE_WORD",
                                      "1": "QUOTABLE_PHRASE",
                                      "2": "GREEDY_PHRASE"
                                    }
                                  }
                                ],
                                "minecraft:entity": [
                                  "bitfield",
                                  [
                                    {
                                      name: "unused",
                                      size: 6,
                                      signed: false
                                    },
                                    {
                                      name: "onlyAllowPlayers",
                                      size: 1,
                                      signed: false
                                    },
                                    {
                                      name: "onlyAllowEntities",
                                      size: 1,
                                      signed: false
                                    }
                                  ]
                                ],
                                "minecraft:game_profile": "void",
                                "minecraft:block_pos": "void",
                                "minecraft:column_pos": "void",
                                "minecraft:vec3": "void",
                                "minecraft:vec2": "void",
                                "minecraft:block_state": "void",
                                "minecraft:block_predicate": "void",
                                "minecraft:item_stack": "void",
                                "minecraft:item_predicate": "void",
                                "minecraft:color": "void",
                                "minecraft:component": "void",
                                "minecraft:message": "void",
                                "minecraft:nbt": "void",
                                "minecraft:nbt_path": "void",
                                "minecraft:objective": "void",
                                "minecraft:objective_criteria": "void",
                                "minecraft:operation": "void",
                                "minecraft:particle": "void",
                                "minecraft:angle": "void",
                                "minecraft:rotation": "void",
                                "minecraft:scoreboard_slot": "void",
                                "minecraft:score_holder": [
                                  "bitfield",
                                  [
                                    {
                                      name: "unused",
                                      size: 7,
                                      signed: false
                                    },
                                    {
                                      name: "allowMultiple",
                                      size: 1,
                                      signed: false
                                    }
                                  ]
                                ],
                                "minecraft:swizzle": "void",
                                "minecraft:team": "void",
                                "minecraft:item_slot": "void",
                                "minecraft:resource_location": "void",
                                "minecraft:mob_effect": "void",
                                "minecraft:function": "void",
                                "minecraft:entity_anchor": "void",
                                "minecraft:int_range": "void",
                                "minecraft:float_range": "void",
                                "minecraft:item_enchantment": "void",
                                "minecraft:entity_summon": "void",
                                "minecraft:dimension": "void",
                                "minecraft:time": "void",
                                "minecraft:resource_or_tag": [
                                  "container",
                                  [
                                    {
                                      name: "registry",
                                      type: "string"
                                    }
                                  ]
                                ],
                                "minecraft:resource": [
                                  "container",
                                  [
                                    {
                                      name: "registry",
                                      type: "string"
                                    }
                                  ]
                                ],
                                template_mirror: "void",
                                template_rotation: "void",
                                "minecraft:uuid": "void"
                              }
                            }
                          ]
                        },
                        {
                          name: "suggestionType",
                          type: [
                            "switch",
                            {
                              compareTo: "../flags/has_custom_suggestions",
                              fields: {
                                "1": "string"
                              },
                              default: "void"
                            }
                          ]
                        }
                      ]
                    ]
                  }
                }
              ]
            }
          ]
        ]
      },
      handshaking: {
        toClient: {
          types: {
            packet: [
              "container",
              [
                {
                  name: "name",
                  type: [
                    "mapper",
                    {
                      type: "varint",
                      mappings: {}
                    }
                  ]
                },
                {
                  name: "params",
                  type: [
                    "switch",
                    {
                      compareTo: "name",
                      fields: {}
                    }
                  ]
                }
              ]
            ]
          }
        },
        toServer: {
          types: {
            packet_set_protocol: [
              "container",
              [
                {
                  name: "protocolVersion",
                  type: "varint"
                },
                {
                  name: "serverHost",
                  type: "string"
                },
                {
                  name: "serverPort",
                  type: "u16"
                },
                {
                  name: "nextState",
                  type: "varint"
                }
              ]
            ],
            packet_legacy_server_list_ping: [
              "container",
              [
                {
                  name: "payload",
                  type: "u8"
                }
              ]
            ],
            packet: [
              "container",
              [
                {
                  name: "name",
                  type: [
                    "mapper",
                    {
                      type: "varint",
                      mappings: {
                        "0x00": "set_protocol",
                        "0xfe": "legacy_server_list_ping"
                      }
                    }
                  ]
                },
                {
                  name: "params",
                  type: [
                    "switch",
                    {
                      compareTo: "name",
                      fields: {
                        set_protocol: "packet_set_protocol",
                        legacy_server_list_ping: "packet_legacy_server_list_ping"
                      }
                    }
                  ]
                }
              ]
            ]
          }
        }
      },
      status: {
        toClient: {
          types: {
            packet_server_info: [
              "container",
              [
                {
                  name: "response",
                  type: "string"
                }
              ]
            ],
            packet_ping: [
              "container",
              [
                {
                  name: "time",
                  type: "i64"
                }
              ]
            ],
            packet: [
              "container",
              [
                {
                  name: "name",
                  type: [
                    "mapper",
                    {
                      type: "varint",
                      mappings: {
                        "0x00": "server_info",
                        "0x01": "ping"
                      }
                    }
                  ]
                },
                {
                  name: "params",
                  type: [
                    "switch",
                    {
                      compareTo: "name",
                      fields: {
                        server_info: "packet_server_info",
                        ping: "packet_ping"
                      }
                    }
                  ]
                }
              ]
            ]
          }
        },
        toServer: {
          types: {
            packet_ping_start: [
              "container",
              []
            ],
            packet_ping: [
              "container",
              [
                {
                  name: "time",
                  type: "i64"
                }
              ]
            ],
            packet: [
              "container",
              [
                {
                  name: "name",
                  type: [
                    "mapper",
                    {
                      type: "varint",
                      mappings: {
                        "0x00": "ping_start",
                        "0x01": "ping"
                      }
                    }
                  ]
                },
                {
                  name: "params",
                  type: [
                    "switch",
                    {
                      compareTo: "name",
                      fields: {
                        ping_start: "packet_ping_start",
                        ping: "packet_ping"
                      }
                    }
                  ]
                }
              ]
            ]
          }
        }
      },
      login: {
        toClient: {
          types: {
            packet_disconnect: [
              "container",
              [
                {
                  name: "reason",
                  type: "string"
                }
              ]
            ],
            packet_encryption_begin: [
              "container",
              [
                {
                  name: "serverId",
                  type: "string"
                },
                {
                  name: "publicKey",
                  type: [
                    "buffer",
                    {
                      countType: "varint"
                    }
                  ]
                },
                {
                  name: "verifyToken",
                  type: [
                    "buffer",
                    {
                      countType: "varint"
                    }
                  ]
                }
              ]
            ],
            packet_success: [
              "container",
              [
                {
                  name: "uuid",
                  type: "UUID"
                },
                {
                  name: "username",
                  type: "string"
                },
                {
                  name: "properties",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "name",
                            type: "string"
                          },
                          {
                            name: "value",
                            type: "string"
                          },
                          {
                            name: "signature",
                            type: [
                              "option",
                              "string"
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_compress: [
              "container",
              [
                {
                  name: "threshold",
                  type: "varint"
                }
              ]
            ],
            packet_login_plugin_request: [
              "container",
              [
                {
                  name: "messageId",
                  type: "varint"
                },
                {
                  name: "channel",
                  type: "string"
                },
                {
                  name: "data",
                  type: "restBuffer"
                }
              ]
            ],
            packet: [
              "container",
              [
                {
                  name: "name",
                  type: [
                    "mapper",
                    {
                      type: "varint",
                      mappings: {
                        "0x00": "disconnect",
                        "0x01": "encryption_begin",
                        "0x02": "success",
                        "0x03": "compress",
                        "0x04": "login_plugin_request"
                      }
                    }
                  ]
                },
                {
                  name: "params",
                  type: [
                    "switch",
                    {
                      compareTo: "name",
                      fields: {
                        disconnect: "packet_disconnect",
                        encryption_begin: "packet_encryption_begin",
                        success: "packet_success",
                        compress: "packet_compress",
                        login_plugin_request: "packet_login_plugin_request"
                      }
                    }
                  ]
                }
              ]
            ]
          }
        },
        toServer: {
          types: {
            packet_login_start: [
              "container",
              [
                {
                  name: "username",
                  type: "string"
                },
                {
                  name: "signature",
                  type: [
                    "option",
                    [
                      "container",
                      [
                        {
                          name: "timestamp",
                          type: "i64"
                        },
                        {
                          name: "publicKey",
                          type: [
                            "buffer",
                            {
                              countType: "varint"
                            }
                          ]
                        },
                        {
                          name: "signature",
                          type: [
                            "buffer",
                            {
                              countType: "varint"
                            }
                          ]
                        }
                      ]
                    ]
                  ]
                }
              ]
            ],
            packet_encryption_begin: [
              "container",
              [
                {
                  name: "sharedSecret",
                  type: [
                    "buffer",
                    {
                      countType: "varint"
                    }
                  ]
                },
                {
                  name: "hasVerifyToken",
                  type: "bool"
                },
                {
                  name: "crypto",
                  type: [
                    "switch",
                    {
                      compareTo: "hasVerifyToken",
                      fields: {
                        true: [
                          "container",
                          [
                            {
                              name: "verifyToken",
                              type: [
                                "buffer",
                                {
                                  countType: "varint"
                                }
                              ]
                            }
                          ]
                        ],
                        false: [
                          "container",
                          [
                            {
                              name: "salt",
                              type: "i64"
                            },
                            {
                              name: "messageSignature",
                              type: [
                                "buffer",
                                {
                                  countType: "varint"
                                }
                              ]
                            }
                          ]
                        ]
                      }
                    }
                  ]
                }
              ]
            ],
            packet_login_plugin_response: [
              "container",
              [
                {
                  name: "messageId",
                  type: "varint"
                },
                {
                  name: "data",
                  type: [
                    "option",
                    "restBuffer"
                  ]
                }
              ]
            ],
            packet: [
              "container",
              [
                {
                  name: "name",
                  type: [
                    "mapper",
                    {
                      type: "varint",
                      mappings: {
                        "0x00": "login_start",
                        "0x01": "encryption_begin",
                        "0x02": "login_plugin_response"
                      }
                    }
                  ]
                },
                {
                  name: "params",
                  type: [
                    "switch",
                    {
                      compareTo: "name",
                      fields: {
                        login_start: "packet_login_start",
                        encryption_begin: "packet_encryption_begin",
                        login_plugin_response: "packet_login_plugin_response"
                      }
                    }
                  ]
                }
              ]
            ]
          }
        }
      },
      play: {
        toClient: {
          types: {
            packet_spawn_entity: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "objectUUID",
                  type: "UUID"
                },
                {
                  name: "type",
                  type: "varint"
                },
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "pitch",
                  type: "i8"
                },
                {
                  name: "yaw",
                  type: "i8"
                },
                {
                  name: "headYaw",
                  type: "i8"
                },
                {
                  name: "objectData",
                  type: "varint"
                },
                {
                  name: "velocityX",
                  type: "i16"
                },
                {
                  name: "velocityY",
                  type: "i16"
                },
                {
                  name: "velocityZ",
                  type: "i16"
                }
              ]
            ],
            packet_spawn_entity_experience_orb: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "count",
                  type: "i16"
                }
              ]
            ],
            packet_spawn_entity_living: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "entityUUID",
                  type: "UUID"
                },
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "yaw",
                  type: "i8"
                },
                {
                  name: "pitch",
                  type: "i8"
                }
              ]
            ],
            packet_animation: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "animation",
                  type: "u8"
                }
              ]
            ],
            packet_statistics: [
              "container",
              [
                {
                  name: "entries",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "categoryId",
                            type: "varint"
                          },
                          {
                            name: "statisticId",
                            type: "varint"
                          },
                          {
                            name: "value",
                            type: "varint"
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_advancements: [
              "container",
              [
                {
                  name: "reset",
                  type: "bool"
                },
                {
                  name: "advancementMapping",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "key",
                            type: "string"
                          },
                          {
                            name: "value",
                            type: [
                              "container",
                              [
                                {
                                  name: "parentId",
                                  type: [
                                    "option",
                                    "string"
                                  ]
                                },
                                {
                                  name: "displayData",
                                  type: [
                                    "option",
                                    [
                                      "container",
                                      [
                                        {
                                          name: "title",
                                          type: "string"
                                        },
                                        {
                                          name: "description",
                                          type: "string"
                                        },
                                        {
                                          name: "icon",
                                          type: "slot"
                                        },
                                        {
                                          name: "frameType",
                                          type: "varint"
                                        },
                                        {
                                          name: "flags",
                                          type: [
                                            "bitfield",
                                            [
                                              {
                                                name: "_unused",
                                                size: 29,
                                                signed: false
                                              },
                                              {
                                                name: "hidden",
                                                size: 1,
                                                signed: false
                                              },
                                              {
                                                name: "show_toast",
                                                size: 1,
                                                signed: false
                                              },
                                              {
                                                name: "has_background_texture",
                                                size: 1,
                                                signed: false
                                              }
                                            ]
                                          ]
                                        },
                                        {
                                          name: "backgroundTexture",
                                          type: [
                                            "switch",
                                            {
                                              compareTo: "flags/has_background_texture",
                                              fields: {
                                                "1": "string"
                                              },
                                              default: "void"
                                            }
                                          ]
                                        },
                                        {
                                          name: "xCord",
                                          type: "f32"
                                        },
                                        {
                                          name: "yCord",
                                          type: "f32"
                                        }
                                      ]
                                    ]
                                  ]
                                },
                                {
                                  name: "criteria",
                                  type: [
                                    "array",
                                    {
                                      countType: "varint",
                                      type: [
                                        "container",
                                        [
                                          {
                                            name: "key",
                                            type: "string"
                                          },
                                          {
                                            name: "value",
                                            type: "void"
                                          }
                                        ]
                                      ]
                                    }
                                  ]
                                },
                                {
                                  name: "requirements",
                                  type: [
                                    "array",
                                    {
                                      countType: "varint",
                                      type: [
                                        "array",
                                        {
                                          countType: "varint",
                                          type: "string"
                                        }
                                      ]
                                    }
                                  ]
                                }
                              ]
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                },
                {
                  name: "identifiers",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "string"
                    }
                  ]
                },
                {
                  name: "progressMapping",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "key",
                            type: "string"
                          },
                          {
                            name: "value",
                            type: [
                              "array",
                              {
                                countType: "varint",
                                type: [
                                  "container",
                                  [
                                    {
                                      name: "criterionIdentifier",
                                      type: "string"
                                    },
                                    {
                                      name: "criterionProgress",
                                      type: [
                                        "option",
                                        "i64"
                                      ]
                                    }
                                  ]
                                ]
                              }
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_block_break_animation: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "destroyStage",
                  type: "i8"
                }
              ]
            ],
            packet_tile_entity_data: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "action",
                  type: "varint"
                },
                {
                  name: "nbtData",
                  type: "optionalNbt"
                }
              ]
            ],
            packet_block_action: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "byte1",
                  type: "u8"
                },
                {
                  name: "byte2",
                  type: "u8"
                },
                {
                  name: "blockId",
                  type: "varint"
                }
              ]
            ],
            packet_block_change: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "type",
                  type: "varint"
                }
              ]
            ],
            packet_boss_bar: [
              "container",
              [
                {
                  name: "entityUUID",
                  type: "UUID"
                },
                {
                  name: "action",
                  type: "varint"
                },
                {
                  name: "title",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": "string",
                        "3": "string"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "health",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": "f32",
                        "2": "f32"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "color",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": "varint",
                        "4": "varint"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "dividers",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": "varint",
                        "4": "varint"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "flags",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": "u8",
                        "5": "u8"
                      },
                      default: "void"
                    }
                  ]
                }
              ]
            ],
            packet_difficulty: [
              "container",
              [
                {
                  name: "difficulty",
                  type: "u8"
                },
                {
                  name: "difficultyLocked",
                  type: "bool"
                }
              ]
            ],
            packet_chat_preview: [
              "container",
              [
                {
                  name: "queryId",
                  type: "i32"
                },
                {
                  name: "message",
                  type: [
                    "option",
                    "string"
                  ]
                }
              ]
            ],
            packet_tab_complete: [
              "container",
              [
                {
                  name: "transactionId",
                  type: "varint"
                },
                {
                  name: "start",
                  type: "varint"
                },
                {
                  name: "length",
                  type: "varint"
                },
                {
                  name: "matches",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "match",
                            type: "string"
                          },
                          {
                            name: "tooltip",
                            type: [
                              "option",
                              "string"
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_declare_commands: [
              "container",
              [
                {
                  name: "nodes",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "command_node"
                    }
                  ]
                },
                {
                  name: "rootIndex",
                  type: "varint"
                }
              ]
            ],
            packet_face_player: [
              "container",
              [
                {
                  name: "feet_eyes",
                  type: "varint"
                },
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "isEntity",
                  type: "bool"
                },
                {
                  name: "entityId",
                  type: [
                    "switch",
                    {
                      compareTo: "isEntity",
                      fields: {
                        true: "varint"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "entity_feet_eyes",
                  type: [
                    "switch",
                    {
                      compareTo: "isEntity",
                      fields: {
                        true: "string"
                      },
                      default: "void"
                    }
                  ]
                }
              ]
            ],
            packet_nbt_query_response: [
              "container",
              [
                {
                  name: "transactionId",
                  type: "varint"
                },
                {
                  name: "nbt",
                  type: "optionalNbt"
                }
              ]
            ],
            packet_multi_block_change: [
              "container",
              [
                {
                  name: "chunkCoordinates",
                  type: [
                    "bitfield",
                    [
                      {
                        name: "x",
                        size: 22,
                        signed: true
                      },
                      {
                        name: "z",
                        size: 22,
                        signed: true
                      },
                      {
                        name: "y",
                        size: 20,
                        signed: true
                      }
                    ]
                  ]
                },
                {
                  name: "notTrustEdges",
                  type: "bool"
                },
                {
                  name: "records",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "varint"
                    }
                  ]
                }
              ]
            ],
            packet_close_window: [
              "container",
              [
                {
                  name: "windowId",
                  type: "u8"
                }
              ]
            ],
            packet_open_window: [
              "container",
              [
                {
                  name: "windowId",
                  type: "varint"
                },
                {
                  name: "inventoryType",
                  type: "varint"
                },
                {
                  name: "windowTitle",
                  type: "string"
                }
              ]
            ],
            packet_window_items: [
              "container",
              [
                {
                  name: "windowId",
                  type: "u8"
                },
                {
                  name: "stateId",
                  type: "varint"
                },
                {
                  name: "items",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "slot"
                    }
                  ]
                },
                {
                  name: "carriedItem",
                  type: "slot"
                }
              ]
            ],
            packet_craft_progress_bar: [
              "container",
              [
                {
                  name: "windowId",
                  type: "u8"
                },
                {
                  name: "property",
                  type: "i16"
                },
                {
                  name: "value",
                  type: "i16"
                }
              ]
            ],
            packet_set_slot: [
              "container",
              [
                {
                  name: "windowId",
                  type: "i8"
                },
                {
                  name: "stateId",
                  type: "varint"
                },
                {
                  name: "slot",
                  type: "i16"
                },
                {
                  name: "item",
                  type: "slot"
                }
              ]
            ],
            packet_set_cooldown: [
              "container",
              [
                {
                  name: "itemID",
                  type: "varint"
                },
                {
                  name: "cooldownTicks",
                  type: "varint"
                }
              ]
            ],
            packet_custom_payload: [
              "container",
              [
                {
                  name: "channel",
                  type: "string"
                },
                {
                  name: "data",
                  type: "restBuffer"
                }
              ]
            ],
            packet_named_sound_effect: [
              "container",
              [
                {
                  name: "soundName",
                  type: "string"
                },
                {
                  name: "soundCategory",
                  type: "varint"
                },
                {
                  name: "x",
                  type: "i32"
                },
                {
                  name: "y",
                  type: "i32"
                },
                {
                  name: "z",
                  type: "i32"
                },
                {
                  name: "volume",
                  type: "f32"
                },
                {
                  name: "pitch",
                  type: "f32"
                },
                {
                  name: "seed",
                  type: "i64"
                }
              ]
            ],
            packet_kick_disconnect: [
              "container",
              [
                {
                  name: "reason",
                  type: "string"
                }
              ]
            ],
            packet_entity_status: [
              "container",
              [
                {
                  name: "entityId",
                  type: "i32"
                },
                {
                  name: "entityStatus",
                  type: "i8"
                }
              ]
            ],
            packet_explosion: [
              "container",
              [
                {
                  name: "x",
                  type: "f32"
                },
                {
                  name: "y",
                  type: "f32"
                },
                {
                  name: "z",
                  type: "f32"
                },
                {
                  name: "radius",
                  type: "f32"
                },
                {
                  name: "affectedBlockOffsets",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "x",
                            type: "i8"
                          },
                          {
                            name: "y",
                            type: "i8"
                          },
                          {
                            name: "z",
                            type: "i8"
                          }
                        ]
                      ]
                    }
                  ]
                },
                {
                  name: "playerMotionX",
                  type: "f32"
                },
                {
                  name: "playerMotionY",
                  type: "f32"
                },
                {
                  name: "playerMotionZ",
                  type: "f32"
                }
              ]
            ],
            packet_unload_chunk: [
              "container",
              [
                {
                  name: "chunkX",
                  type: "i32"
                },
                {
                  name: "chunkZ",
                  type: "i32"
                }
              ]
            ],
            packet_game_state_change: [
              "container",
              [
                {
                  name: "reason",
                  type: "u8"
                },
                {
                  name: "gameMode",
                  type: "f32"
                }
              ]
            ],
            packet_open_horse_window: [
              "container",
              [
                {
                  name: "windowId",
                  type: "u8"
                },
                {
                  name: "nbSlots",
                  type: "varint"
                },
                {
                  name: "entityId",
                  type: "i32"
                }
              ]
            ],
            packet_keep_alive: [
              "container",
              [
                {
                  name: "keepAliveId",
                  type: "i64"
                }
              ]
            ],
            packet_map_chunk: [
              "container",
              [
                {
                  name: "x",
                  type: "i32"
                },
                {
                  name: "z",
                  type: "i32"
                },
                {
                  name: "heightmaps",
                  type: "nbt"
                },
                {
                  name: "chunkData",
                  type: [
                    "buffer",
                    {
                      countType: "varint"
                    }
                  ]
                },
                {
                  name: "blockEntities",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "chunkBlockEntity"
                    }
                  ]
                },
                {
                  name: "trustEdges",
                  type: "bool"
                },
                {
                  name: "skyLightMask",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "i64"
                    }
                  ]
                },
                {
                  name: "blockLightMask",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "i64"
                    }
                  ]
                },
                {
                  name: "emptySkyLightMask",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "i64"
                    }
                  ]
                },
                {
                  name: "emptyBlockLightMask",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "i64"
                    }
                  ]
                },
                {
                  name: "skyLight",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "array",
                        {
                          countType: "varint",
                          type: "u8"
                        }
                      ]
                    }
                  ]
                },
                {
                  name: "blockLight",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "array",
                        {
                          countType: "varint",
                          type: "u8"
                        }
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_world_event: [
              "container",
              [
                {
                  name: "effectId",
                  type: "i32"
                },
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "data",
                  type: "i32"
                },
                {
                  name: "global",
                  type: "bool"
                }
              ]
            ],
            packet_world_particles: [
              "container",
              [
                {
                  name: "particleId",
                  type: "varint"
                },
                {
                  name: "longDistance",
                  type: "bool"
                },
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "offsetX",
                  type: "f32"
                },
                {
                  name: "offsetY",
                  type: "f32"
                },
                {
                  name: "offsetZ",
                  type: "f32"
                },
                {
                  name: "particleData",
                  type: "f32"
                },
                {
                  name: "particles",
                  type: "i32"
                },
                {
                  name: "data",
                  type: [
                    "particleData",
                    {
                      compareTo: "particleId"
                    }
                  ]
                }
              ]
            ],
            packet_update_light: [
              "container",
              [
                {
                  name: "chunkX",
                  type: "varint"
                },
                {
                  name: "chunkZ",
                  type: "varint"
                },
                {
                  name: "trustEdges",
                  type: "bool"
                },
                {
                  name: "skyLightMask",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "i64"
                    }
                  ]
                },
                {
                  name: "blockLightMask",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "i64"
                    }
                  ]
                },
                {
                  name: "emptySkyLightMask",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "i64"
                    }
                  ]
                },
                {
                  name: "emptyBlockLightMask",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "i64"
                    }
                  ]
                },
                {
                  name: "skyLight",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "array",
                        {
                          countType: "varint",
                          type: "u8"
                        }
                      ]
                    }
                  ]
                },
                {
                  name: "blockLight",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "array",
                        {
                          countType: "varint",
                          type: "u8"
                        }
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_login: [
              "container",
              [
                {
                  name: "entityId",
                  type: "i32"
                },
                {
                  name: "isHardcore",
                  type: "bool"
                },
                {
                  name: "gameMode",
                  type: "u8"
                },
                {
                  name: "previousGameMode",
                  type: "i8"
                },
                {
                  name: "worldNames",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "string"
                    }
                  ]
                },
                {
                  name: "dimensionCodec",
                  type: "nbt"
                },
                {
                  name: "worldType",
                  type: "string"
                },
                {
                  name: "worldName",
                  type: "string"
                },
                {
                  name: "hashedSeed",
                  type: "i64"
                },
                {
                  name: "maxPlayers",
                  type: "varint"
                },
                {
                  name: "viewDistance",
                  type: "varint"
                },
                {
                  name: "simulationDistance",
                  type: "varint"
                },
                {
                  name: "reducedDebugInfo",
                  type: "bool"
                },
                {
                  name: "enableRespawnScreen",
                  type: "bool"
                },
                {
                  name: "isDebug",
                  type: "bool"
                },
                {
                  name: "isFlat",
                  type: "bool"
                },
                {
                  name: "death",
                  type: [
                    "option",
                    [
                      "container",
                      [
                        {
                          name: "dimensionName",
                          type: "string"
                        },
                        {
                          name: "location",
                          type: "position"
                        }
                      ]
                    ]
                  ]
                }
              ]
            ],
            packet_map: [
              "container",
              [
                {
                  name: "itemDamage",
                  type: "varint"
                },
                {
                  name: "scale",
                  type: "i8"
                },
                {
                  name: "locked",
                  type: "bool"
                },
                {
                  name: "icons",
                  type: [
                    "option",
                    [
                      "array",
                      {
                        countType: "varint",
                        type: [
                          "container",
                          [
                            {
                              name: "type",
                              type: "varint"
                            },
                            {
                              name: "x",
                              type: "i8"
                            },
                            {
                              name: "z",
                              type: "i8"
                            },
                            {
                              name: "direction",
                              type: "u8"
                            },
                            {
                              name: "displayName",
                              type: [
                                "option",
                                "string"
                              ]
                            }
                          ]
                        ]
                      }
                    ]
                  ]
                },
                {
                  name: "columns",
                  type: "u8"
                },
                {
                  name: "rows",
                  type: [
                    "switch",
                    {
                      compareTo: "columns",
                      fields: {
                        "0": "void"
                      },
                      default: "u8"
                    }
                  ]
                },
                {
                  name: "x",
                  type: [
                    "switch",
                    {
                      compareTo: "columns",
                      fields: {
                        "0": "void"
                      },
                      default: "u8"
                    }
                  ]
                },
                {
                  name: "y",
                  type: [
                    "switch",
                    {
                      compareTo: "columns",
                      fields: {
                        "0": "void"
                      },
                      default: "u8"
                    }
                  ]
                },
                {
                  name: "data",
                  type: [
                    "switch",
                    {
                      compareTo: "columns",
                      fields: {
                        "0": "void"
                      },
                      default: [
                        "buffer",
                        {
                          countType: "varint"
                        }
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_trade_list: [
              "container",
              [
                {
                  name: "windowId",
                  type: "varint"
                },
                {
                  name: "trades",
                  type: [
                    "array",
                    {
                      countType: "u8",
                      type: [
                        "container",
                        [
                          {
                            name: "inputItem1",
                            type: "slot"
                          },
                          {
                            name: "outputItem",
                            type: "slot"
                          },
                          {
                            name: "inputItem2",
                            type: [
                              "option",
                              "slot"
                            ]
                          },
                          {
                            name: "tradeDisabled",
                            type: "bool"
                          },
                          {
                            name: "nbTradeUses",
                            type: "i32"
                          },
                          {
                            name: "maximumNbTradeUses",
                            type: "i32"
                          },
                          {
                            name: "xp",
                            type: "i32"
                          },
                          {
                            name: "specialPrice",
                            type: "i32"
                          },
                          {
                            name: "priceMultiplier",
                            type: "f32"
                          },
                          {
                            name: "demand",
                            type: "i32"
                          }
                        ]
                      ]
                    }
                  ]
                },
                {
                  name: "villagerLevel",
                  type: "varint"
                },
                {
                  name: "experience",
                  type: "varint"
                },
                {
                  name: "isRegularVillager",
                  type: "bool"
                },
                {
                  name: "canRestock",
                  type: "bool"
                }
              ]
            ],
            packet_rel_entity_move: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "dX",
                  type: "i16"
                },
                {
                  name: "dY",
                  type: "i16"
                },
                {
                  name: "dZ",
                  type: "i16"
                },
                {
                  name: "onGround",
                  type: "bool"
                }
              ]
            ],
            packet_entity_move_look: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "dX",
                  type: "i16"
                },
                {
                  name: "dY",
                  type: "i16"
                },
                {
                  name: "dZ",
                  type: "i16"
                },
                {
                  name: "yaw",
                  type: "i8"
                },
                {
                  name: "pitch",
                  type: "i8"
                },
                {
                  name: "onGround",
                  type: "bool"
                }
              ]
            ],
            packet_entity_look: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "yaw",
                  type: "i8"
                },
                {
                  name: "pitch",
                  type: "i8"
                },
                {
                  name: "onGround",
                  type: "bool"
                }
              ]
            ],
            packet_vehicle_move: [
              "container",
              [
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "yaw",
                  type: "f32"
                },
                {
                  name: "pitch",
                  type: "f32"
                }
              ]
            ],
            packet_open_book: [
              "container",
              [
                {
                  name: "hand",
                  type: "varint"
                }
              ]
            ],
            packet_open_sign_entity: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                }
              ]
            ],
            packet_craft_recipe_response: [
              "container",
              [
                {
                  name: "windowId",
                  type: "i8"
                },
                {
                  name: "recipe",
                  type: "string"
                }
              ]
            ],
            packet_abilities: [
              "container",
              [
                {
                  name: "flags",
                  type: "i8"
                },
                {
                  name: "flyingSpeed",
                  type: "f32"
                },
                {
                  name: "walkingSpeed",
                  type: "f32"
                }
              ]
            ],
            packet_player_chat: [
              "container",
              [
                {
                  name: "signedChatContent",
                  type: "string"
                },
                {
                  name: "unsignedChatContent",
                  type: [
                    "option",
                    "string"
                  ]
                },
                {
                  name: "type",
                  type: "varint"
                },
                {
                  name: "senderUuid",
                  type: "UUID"
                },
                {
                  name: "senderName",
                  type: "string"
                },
                {
                  name: "senderTeam",
                  type: [
                    "option",
                    "string"
                  ]
                },
                {
                  name: "timestamp",
                  type: "i64"
                },
                {
                  name: "salt",
                  type: "i64"
                },
                {
                  name: "signature",
                  type: [
                    "buffer",
                    {
                      countType: "varint"
                    }
                  ]
                }
              ]
            ],
            packet_end_combat_event: [
              "container",
              [
                {
                  name: "duration",
                  type: "varint"
                },
                {
                  name: "entityId",
                  type: "i32"
                }
              ]
            ],
            packet_enter_combat_event: [
              "container",
              []
            ],
            packet_death_combat_event: [
              "container",
              [
                {
                  name: "playerId",
                  type: "varint"
                },
                {
                  name: "entityId",
                  type: "i32"
                },
                {
                  name: "message",
                  type: "string"
                }
              ]
            ],
            packet_player_info: [
              "container",
              [
                {
                  name: "action",
                  type: "varint"
                },
                {
                  name: "data",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "UUID",
                            type: "UUID"
                          },
                          {
                            name: "name",
                            type: [
                              "switch",
                              {
                                compareTo: "../action",
                                fields: {
                                  "0": "string"
                                },
                                default: "void"
                              }
                            ]
                          },
                          {
                            name: "properties",
                            type: [
                              "switch",
                              {
                                compareTo: "../action",
                                fields: {
                                  "0": [
                                    "array",
                                    {
                                      countType: "varint",
                                      type: [
                                        "container",
                                        [
                                          {
                                            name: "name",
                                            type: "string"
                                          },
                                          {
                                            name: "value",
                                            type: "string"
                                          },
                                          {
                                            name: "signature",
                                            type: [
                                              "option",
                                              "string"
                                            ]
                                          }
                                        ]
                                      ]
                                    }
                                  ]
                                },
                                default: "void"
                              }
                            ]
                          },
                          {
                            name: "gamemode",
                            type: [
                              "switch",
                              {
                                compareTo: "../action",
                                fields: {
                                  "0": "varint",
                                  "1": "varint"
                                },
                                default: "void"
                              }
                            ]
                          },
                          {
                            name: "ping",
                            type: [
                              "switch",
                              {
                                compareTo: "../action",
                                fields: {
                                  "0": "varint",
                                  "2": "varint"
                                },
                                default: "void"
                              }
                            ]
                          },
                          {
                            name: "displayName",
                            type: [
                              "switch",
                              {
                                compareTo: "../action",
                                fields: {
                                  "0": [
                                    "option",
                                    "string"
                                  ],
                                  "3": [
                                    "option",
                                    "string"
                                  ]
                                },
                                default: "void"
                              }
                            ]
                          },
                          {
                            name: "crypto",
                            type: [
                              "switch",
                              {
                                compareTo: "../action",
                                fields: {
                                  "0": [
                                    "option",
                                    [
                                      "container",
                                      [
                                        {
                                          name: "timestamp",
                                          type: "i64"
                                        },
                                        {
                                          name: "publicKey",
                                          type: [
                                            "buffer",
                                            {
                                              countType: "varint"
                                            }
                                          ]
                                        },
                                        {
                                          name: "signature",
                                          type: [
                                            "buffer",
                                            {
                                              countType: "varint"
                                            }
                                          ]
                                        }
                                      ]
                                    ]
                                  ]
                                },
                                default: "void"
                              }
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_position: [
              "container",
              [
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "yaw",
                  type: "f32"
                },
                {
                  name: "pitch",
                  type: "f32"
                },
                {
                  name: "flags",
                  type: "i8"
                },
                {
                  name: "teleportId",
                  type: "varint"
                },
                {
                  name: "dismountVehicle",
                  type: "bool"
                }
              ]
            ],
            packet_unlock_recipes: [
              "container",
              [
                {
                  name: "action",
                  type: "varint"
                },
                {
                  name: "craftingBookOpen",
                  type: "bool"
                },
                {
                  name: "filteringCraftable",
                  type: "bool"
                },
                {
                  name: "smeltingBookOpen",
                  type: "bool"
                },
                {
                  name: "filteringSmeltable",
                  type: "bool"
                },
                {
                  name: "blastFurnaceOpen",
                  type: "bool"
                },
                {
                  name: "filteringBlastFurnace",
                  type: "bool"
                },
                {
                  name: "smokerBookOpen",
                  type: "bool"
                },
                {
                  name: "filteringSmoker",
                  type: "bool"
                },
                {
                  name: "recipes1",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "string"
                    }
                  ]
                },
                {
                  name: "recipes2",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": [
                          "array",
                          {
                            countType: "varint",
                            type: "string"
                          }
                        ]
                      },
                      default: "void"
                    }
                  ]
                }
              ]
            ],
            packet_entity_destroy: [
              "container",
              [
                {
                  name: "entityIds",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "varint"
                    }
                  ]
                }
              ]
            ],
            packet_remove_entity_effect: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "effectId",
                  type: "varint"
                }
              ]
            ],
            packet_resource_pack_send: [
              "container",
              [
                {
                  name: "url",
                  type: "string"
                },
                {
                  name: "hash",
                  type: "string"
                },
                {
                  name: "forced",
                  type: "bool"
                },
                {
                  name: "promptMessage",
                  type: [
                    "option",
                    "string"
                  ]
                }
              ]
            ],
            packet_respawn: [
              "container",
              [
                {
                  name: "dimension",
                  type: "string"
                },
                {
                  name: "worldName",
                  type: "string"
                },
                {
                  name: "hashedSeed",
                  type: "i64"
                },
                {
                  name: "gamemode",
                  type: "u8"
                },
                {
                  name: "previousGamemode",
                  type: "u8"
                },
                {
                  name: "isDebug",
                  type: "bool"
                },
                {
                  name: "isFlat",
                  type: "bool"
                },
                {
                  name: "copyMetadata",
                  type: "bool"
                },
                {
                  name: "death",
                  type: [
                    "option",
                    [
                      "container",
                      [
                        {
                          name: "dimensionName",
                          type: "string"
                        },
                        {
                          name: "location",
                          type: "position"
                        }
                      ]
                    ]
                  ]
                }
              ]
            ],
            packet_entity_head_rotation: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "headYaw",
                  type: "i8"
                }
              ]
            ],
            packet_camera: [
              "container",
              [
                {
                  name: "cameraId",
                  type: "varint"
                }
              ]
            ],
            packet_held_item_slot: [
              "container",
              [
                {
                  name: "slot",
                  type: "i8"
                }
              ]
            ],
            packet_update_view_position: [
              "container",
              [
                {
                  name: "chunkX",
                  type: "varint"
                },
                {
                  name: "chunkZ",
                  type: "varint"
                }
              ]
            ],
            packet_update_view_distance: [
              "container",
              [
                {
                  name: "viewDistance",
                  type: "varint"
                }
              ]
            ],
            packet_should_display_chat_preview: [
              "container",
              [
                {
                  name: "should_display_chat_preview",
                  type: "bool"
                }
              ]
            ],
            packet_scoreboard_display_objective: [
              "container",
              [
                {
                  name: "position",
                  type: "i8"
                },
                {
                  name: "name",
                  type: "string"
                }
              ]
            ],
            packet_entity_metadata: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "metadata",
                  type: "entityMetadata"
                }
              ]
            ],
            packet_attach_entity: [
              "container",
              [
                {
                  name: "entityId",
                  type: "i32"
                },
                {
                  name: "vehicleId",
                  type: "i32"
                }
              ]
            ],
            packet_entity_velocity: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "velocityX",
                  type: "i16"
                },
                {
                  name: "velocityY",
                  type: "i16"
                },
                {
                  name: "velocityZ",
                  type: "i16"
                }
              ]
            ],
            packet_entity_equipment: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "equipments",
                  type: [
                    "topBitSetTerminatedArray",
                    {
                      type: [
                        "container",
                        [
                          {
                            name: "slot",
                            type: "i8"
                          },
                          {
                            name: "item",
                            type: "slot"
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_experience: [
              "container",
              [
                {
                  name: "experienceBar",
                  type: "f32"
                },
                {
                  name: "level",
                  type: "varint"
                },
                {
                  name: "totalExperience",
                  type: "varint"
                }
              ]
            ],
            packet_update_health: [
              "container",
              [
                {
                  name: "health",
                  type: "f32"
                },
                {
                  name: "food",
                  type: "varint"
                },
                {
                  name: "foodSaturation",
                  type: "f32"
                }
              ]
            ],
            packet_scoreboard_objective: [
              "container",
              [
                {
                  name: "name",
                  type: "string"
                },
                {
                  name: "action",
                  type: "i8"
                },
                {
                  name: "displayText",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": "string",
                        "2": "string"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "type",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": "varint",
                        "2": "varint"
                      },
                      default: "void"
                    }
                  ]
                }
              ]
            ],
            packet_set_passengers: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "passengers",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "varint"
                    }
                  ]
                }
              ]
            ],
            packet_teams: [
              "container",
              [
                {
                  name: "team",
                  type: "string"
                },
                {
                  name: "mode",
                  type: "i8"
                },
                {
                  name: "name",
                  type: [
                    "switch",
                    {
                      compareTo: "mode",
                      fields: {
                        "0": "string",
                        "2": "string"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "friendlyFire",
                  type: [
                    "switch",
                    {
                      compareTo: "mode",
                      fields: {
                        "0": "i8",
                        "2": "i8"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "nameTagVisibility",
                  type: [
                    "switch",
                    {
                      compareTo: "mode",
                      fields: {
                        "0": "string",
                        "2": "string"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "collisionRule",
                  type: [
                    "switch",
                    {
                      compareTo: "mode",
                      fields: {
                        "0": "string",
                        "2": "string"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "formatting",
                  type: [
                    "switch",
                    {
                      compareTo: "mode",
                      fields: {
                        "0": "varint",
                        "2": "varint"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "prefix",
                  type: [
                    "switch",
                    {
                      compareTo: "mode",
                      fields: {
                        "0": "string",
                        "2": "string"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "suffix",
                  type: [
                    "switch",
                    {
                      compareTo: "mode",
                      fields: {
                        "0": "string",
                        "2": "string"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "players",
                  type: [
                    "switch",
                    {
                      compareTo: "mode",
                      fields: {
                        "0": [
                          "array",
                          {
                            countType: "varint",
                            type: "string"
                          }
                        ],
                        "3": [
                          "array",
                          {
                            countType: "varint",
                            type: "string"
                          }
                        ],
                        "4": [
                          "array",
                          {
                            countType: "varint",
                            type: "string"
                          }
                        ]
                      },
                      default: "void"
                    }
                  ]
                }
              ]
            ],
            packet_scoreboard_score: [
              "container",
              [
                {
                  name: "itemName",
                  type: "string"
                },
                {
                  name: "action",
                  type: "varint"
                },
                {
                  name: "scoreName",
                  type: "string"
                },
                {
                  name: "value",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "1": "void"
                      },
                      default: "varint"
                    }
                  ]
                }
              ]
            ],
            packet_spawn_position: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "angle",
                  type: "f32"
                }
              ]
            ],
            packet_update_time: [
              "container",
              [
                {
                  name: "age",
                  type: "i64"
                },
                {
                  name: "time",
                  type: "i64"
                }
              ]
            ],
            packet_entity_sound_effect: [
              "container",
              [
                {
                  name: "soundId",
                  type: "varint"
                },
                {
                  name: "soundCategory",
                  type: "varint"
                },
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "volume",
                  type: "f32"
                },
                {
                  name: "pitch",
                  type: "f32"
                }
              ]
            ],
            packet_stop_sound: [
              "container",
              [
                {
                  name: "flags",
                  type: "i8"
                },
                {
                  name: "source",
                  type: [
                    "switch",
                    {
                      compareTo: "flags",
                      fields: {
                        "3": "varint",
                        "1": "varint"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "sound",
                  type: [
                    "switch",
                    {
                      compareTo: "flags",
                      fields: {
                        "3": "string",
                        "2": "string"
                      },
                      default: "void"
                    }
                  ]
                }
              ]
            ],
            packet_sound_effect: [
              "container",
              [
                {
                  name: "soundId",
                  type: "varint"
                },
                {
                  name: "soundCategory",
                  type: "varint"
                },
                {
                  name: "x",
                  type: "i32"
                },
                {
                  name: "y",
                  type: "i32"
                },
                {
                  name: "z",
                  type: "i32"
                },
                {
                  name: "volume",
                  type: "f32"
                },
                {
                  name: "pitch",
                  type: "f32"
                },
                {
                  name: "seed",
                  type: "i64"
                }
              ]
            ],
            packet_system_chat: [
              "container",
              [
                {
                  name: "content",
                  type: "string"
                },
                {
                  name: "type",
                  type: "varint"
                }
              ]
            ],
            packet_playerlist_header: [
              "container",
              [
                {
                  name: "header",
                  type: "string"
                },
                {
                  name: "footer",
                  type: "string"
                }
              ]
            ],
            packet_collect: [
              "container",
              [
                {
                  name: "collectedEntityId",
                  type: "varint"
                },
                {
                  name: "collectorEntityId",
                  type: "varint"
                },
                {
                  name: "pickupItemCount",
                  type: "varint"
                }
              ]
            ],
            packet_entity_teleport: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "yaw",
                  type: "i8"
                },
                {
                  name: "pitch",
                  type: "i8"
                },
                {
                  name: "onGround",
                  type: "bool"
                }
              ]
            ],
            packet_entity_update_attributes: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "properties",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "key",
                            type: "string"
                          },
                          {
                            name: "value",
                            type: "f64"
                          },
                          {
                            name: "modifiers",
                            type: [
                              "array",
                              {
                                countType: "varint",
                                type: [
                                  "container",
                                  [
                                    {
                                      name: "uuid",
                                      type: "UUID"
                                    },
                                    {
                                      name: "amount",
                                      type: "f64"
                                    },
                                    {
                                      name: "operation",
                                      type: "i8"
                                    }
                                  ]
                                ]
                              }
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_entity_effect: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "effectId",
                  type: "varint"
                },
                {
                  name: "amplifier",
                  type: "i8"
                },
                {
                  name: "duration",
                  type: "varint"
                },
                {
                  name: "hideParticles",
                  type: "i8"
                },
                {
                  name: "factorCodec",
                  type: [
                    "option",
                    "nbt"
                  ]
                }
              ]
            ],
            packet_select_advancement_tab: [
              "container",
              [
                {
                  name: "id",
                  type: [
                    "option",
                    "string"
                  ]
                }
              ]
            ],
            packet_server_data: [
              "container",
              [
                {
                  name: "motd",
                  type: [
                    "option",
                    "string"
                  ]
                },
                {
                  name: "icon",
                  type: [
                    "option",
                    "string"
                  ]
                },
                {
                  name: "previewsChat",
                  type: "bool"
                }
              ]
            ],
            packet_declare_recipes: [
              "container",
              [
                {
                  name: "recipes",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "type",
                            type: "string"
                          },
                          {
                            name: "recipeId",
                            type: "string"
                          },
                          {
                            name: "data",
                            type: [
                              "switch",
                              {
                                compareTo: "type",
                                fields: {
                                  "minecraft:crafting_shapeless": [
                                    "container",
                                    [
                                      {
                                        name: "group",
                                        type: "string"
                                      },
                                      {
                                        name: "ingredients",
                                        type: [
                                          "array",
                                          {
                                            countType: "varint",
                                            type: "ingredient"
                                          }
                                        ]
                                      },
                                      {
                                        name: "result",
                                        type: "slot"
                                      }
                                    ]
                                  ],
                                  "minecraft:crafting_shaped": [
                                    "container",
                                    [
                                      {
                                        name: "width",
                                        type: "varint"
                                      },
                                      {
                                        name: "height",
                                        type: "varint"
                                      },
                                      {
                                        name: "group",
                                        type: "string"
                                      },
                                      {
                                        name: "ingredients",
                                        type: [
                                          "array",
                                          {
                                            count: "width",
                                            type: [
                                              "array",
                                              {
                                                count: "height",
                                                type: "ingredient"
                                              }
                                            ]
                                          }
                                        ]
                                      },
                                      {
                                        name: "result",
                                        type: "slot"
                                      }
                                    ]
                                  ],
                                  "minecraft:crafting_special_armordye": "void",
                                  "minecraft:crafting_special_bookcloning": "void",
                                  "minecraft:crafting_special_mapcloning": "void",
                                  "minecraft:crafting_special_mapextending": "void",
                                  "minecraft:crafting_special_firework_rocket": "void",
                                  "minecraft:crafting_special_firework_star": "void",
                                  "minecraft:crafting_special_firework_star_fade": "void",
                                  "minecraft:crafting_special_repairitem": "void",
                                  "minecraft:crafting_special_tippedarrow": "void",
                                  "minecraft:crafting_special_bannerduplicate": "void",
                                  "minecraft:crafting_special_banneraddpattern": "void",
                                  "minecraft:crafting_special_shielddecoration": "void",
                                  "minecraft:crafting_special_shulkerboxcoloring": "void",
                                  "minecraft:crafting_special_suspiciousstew": "void",
                                  "minecraft:smelting": "minecraft_smelting_format",
                                  "minecraft:blasting": "minecraft_smelting_format",
                                  "minecraft:smoking": "minecraft_smelting_format",
                                  "minecraft:campfire_cooking": "minecraft_smelting_format",
                                  "minecraft:stonecutting": [
                                    "container",
                                    [
                                      {
                                        name: "group",
                                        type: "string"
                                      },
                                      {
                                        name: "ingredient",
                                        type: "ingredient"
                                      },
                                      {
                                        name: "result",
                                        type: "slot"
                                      }
                                    ]
                                  ],
                                  "minecraft:smithing": [
                                    "container",
                                    [
                                      {
                                        name: "base",
                                        type: "ingredient"
                                      },
                                      {
                                        name: "addition",
                                        type: "ingredient"
                                      },
                                      {
                                        name: "result",
                                        type: "slot"
                                      }
                                    ]
                                  ]
                                }
                              }
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_tags: [
              "container",
              [
                {
                  name: "tags",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "tagType",
                            type: "string"
                          },
                          {
                            name: "tags",
                            type: "tags"
                          }
                        ]
                      ]
                    }
                  ]
                }
              ]
            ],
            packet_acknowledge_player_digging: [
              "container",
              [
                {
                  name: "sequenceId",
                  type: "varint"
                }
              ]
            ],
            packet_clear_titles: [
              "container",
              [
                {
                  name: "reset",
                  type: "bool"
                }
              ]
            ],
            packet_initialize_world_border: [
              "container",
              [
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "oldDiameter",
                  type: "f64"
                },
                {
                  name: "newDiameter",
                  type: "f64"
                },
                {
                  name: "speed",
                  type: "varint"
                },
                {
                  name: "portalTeleportBoundary",
                  type: "varint"
                },
                {
                  name: "warningBlocks",
                  type: "varint"
                },
                {
                  name: "warningTime",
                  type: "varint"
                }
              ]
            ],
            packet_action_bar: [
              "container",
              [
                {
                  name: "text",
                  type: "string"
                }
              ]
            ],
            packet_world_border_center: [
              "container",
              [
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                }
              ]
            ],
            packet_world_border_lerp_size: [
              "container",
              [
                {
                  name: "oldDiameter",
                  type: "f64"
                },
                {
                  name: "newDiameter",
                  type: "f64"
                },
                {
                  name: "speed",
                  type: "varint"
                }
              ]
            ],
            packet_world_border_size: [
              "container",
              [
                {
                  name: "diameter",
                  type: "f64"
                }
              ]
            ],
            packet_world_border_warning_delay: [
              "container",
              [
                {
                  name: "warningTime",
                  type: "varint"
                }
              ]
            ],
            packet_world_border_warning_reach: [
              "container",
              [
                {
                  name: "warningBlocks",
                  type: "varint"
                }
              ]
            ],
            packet_ping: [
              "container",
              [
                {
                  name: "id",
                  type: "i32"
                }
              ]
            ],
            packet_set_title_subtitle: [
              "container",
              [
                {
                  name: "text",
                  type: "string"
                }
              ]
            ],
            packet_set_title_text: [
              "container",
              [
                {
                  name: "text",
                  type: "string"
                }
              ]
            ],
            packet_set_title_time: [
              "container",
              [
                {
                  name: "fadeIn",
                  type: "i32"
                },
                {
                  name: "stay",
                  type: "i32"
                },
                {
                  name: "fadeOut",
                  type: "i32"
                }
              ]
            ],
            packet_simulation_distance: [
              "container",
              [
                {
                  name: "distance",
                  type: "varint"
                }
              ]
            ],
            packet: [
              "container",
              [
                {
                  name: "name",
                  type: [
                    "mapper",
                    {
                      type: "varint",
                      mappings: {
                        "0x00": "spawn_entity",
                        "0x01": "spawn_entity_experience_orb",
                        "0x02": "spawn_entity_living",
                        "0x03": "animation",
                        "0x04": "statistics",
                        "0x05": "acknowledge_player_digging",
                        "0x06": "block_break_animation",
                        "0x07": "tile_entity_data",
                        "0x08": "block_action",
                        "0x09": "block_change",
                        "0x0a": "boss_bar",
                        "0x0b": "difficulty",
                        "0x0c": "chat_preview",
                        "0x0d": "clear_titles",
                        "0x0e": "tab_complete",
                        "0x0f": "declare_commands",
                        "0x10": "close_window",
                        "0x11": "window_items",
                        "0x12": "craft_progress_bar",
                        "0x13": "set_slot",
                        "0x14": "set_cooldown",
                        "0x15": "custom_payload",
                        "0x16": "named_sound_effect",
                        "0x17": "kick_disconnect",
                        "0x18": "entity_status",
                        "0x19": "explosion",
                        "0x1a": "unload_chunk",
                        "0x1b": "game_state_change",
                        "0x1c": "open_horse_window",
                        "0x1d": "initialize_world_border",
                        "0x1e": "keep_alive",
                        "0x1f": "map_chunk",
                        "0x20": "world_event",
                        "0x21": "world_particles",
                        "0x22": "update_light",
                        "0x23": "login",
                        "0x24": "map",
                        "0x25": "trade_list",
                        "0x26": "rel_entity_move",
                        "0x27": "entity_move_look",
                        "0x28": "entity_look",
                        "0x29": "vehicle_move",
                        "0x2a": "open_book",
                        "0x2b": "open_window",
                        "0x2c": "open_sign_entity",
                        "0x2d": "ping",
                        "0x2e": "craft_recipe_response",
                        "0x2f": "abilities",
                        "0x30": "player_chat",
                        "0x31": "end_combat_event",
                        "0x32": "enter_combat_event",
                        "0x33": "death_combat_event",
                        "0x34": "player_info",
                        "0x35": "face_player",
                        "0x36": "position",
                        "0x37": "unlock_recipes",
                        "0x38": "entity_destroy",
                        "0x39": "remove_entity_effect",
                        "0x3a": "resource_pack_send",
                        "0x3b": "respawn",
                        "0x3c": "entity_head_rotation",
                        "0x3d": "multi_block_change",
                        "0x3e": "select_advancement_tab",
                        "0x3f": "server_data",
                        "0x40": "action_bar",
                        "0x41": "world_border_center",
                        "0x42": "world_border_lerp_size",
                        "0x43": "world_border_size",
                        "0x44": "world_border_warning_delay",
                        "0x45": "world_border_warning_reach",
                        "0x46": "camera",
                        "0x47": "held_item_slot",
                        "0x48": "update_view_position",
                        "0x49": "update_view_distance",
                        "0x4a": "spawn_position",
                        "0x4b": "should_display_chat_preview",
                        "0x4c": "scoreboard_display_objective",
                        "0x4d": "entity_metadata",
                        "0x4e": "attach_entity",
                        "0x4f": "entity_velocity",
                        "0x50": "entity_equipment",
                        "0x51": "experience",
                        "0x52": "update_health",
                        "0x53": "scoreboard_objective",
                        "0x54": "set_passengers",
                        "0x55": "teams",
                        "0x56": "scoreboard_score",
                        "0x57": "simulation_distance",
                        "0x58": "set_title_subtitle",
                        "0x59": "update_time",
                        "0x5a": "set_title_text",
                        "0x5b": "set_title_time",
                        "0x5c": "entity_sound_effect",
                        "0x5d": "sound_effect",
                        "0x5e": "stop_sound",
                        "0x5f": "system_chat",
                        "0x60": "playerlist_header",
                        "0x61": "nbt_query_response",
                        "0x62": "collect",
                        "0x63": "entity_teleport",
                        "0x64": "advancements",
                        "0x65": "entity_update_attributes",
                        "0x66": "entity_effect",
                        "0x67": "declare_recipes",
                        "0x68": "tags"
                      }
                    }
                  ]
                },
                {
                  name: "params",
                  type: [
                    "switch",
                    {
                      compareTo: "name",
                      fields: {
                        spawn_entity: "packet_spawn_entity",
                        spawn_entity_experience_orb: "packet_spawn_entity_experience_orb",
                        spawn_entity_living: "packet_spawn_entity_living",
                        animation: "packet_animation",
                        statistics: "packet_statistics",
                        acknowledge_player_digging: "packet_acknowledge_player_digging",
                        block_break_animation: "packet_block_break_animation",
                        tile_entity_data: "packet_tile_entity_data",
                        block_action: "packet_block_action",
                        block_change: "packet_block_change",
                        boss_bar: "packet_boss_bar",
                        difficulty: "packet_difficulty",
                        chat_preview: "packet_chat_preview",
                        clear_titles: "packet_clear_titles",
                        tab_complete: "packet_tab_complete",
                        declare_commands: "packet_declare_commands",
                        close_window: "packet_close_window",
                        window_items: "packet_window_items",
                        craft_progress_bar: "packet_craft_progress_bar",
                        set_slot: "packet_set_slot",
                        set_cooldown: "packet_set_cooldown",
                        custom_payload: "packet_custom_payload",
                        named_sound_effect: "packet_named_sound_effect",
                        kick_disconnect: "packet_kick_disconnect",
                        entity_status: "packet_entity_status",
                        explosion: "packet_explosion",
                        unload_chunk: "packet_unload_chunk",
                        game_state_change: "packet_game_state_change",
                        open_horse_window: "packet_open_horse_window",
                        initialize_world_border: "packet_initialize_world_border",
                        keep_alive: "packet_keep_alive",
                        map_chunk: "packet_map_chunk",
                        world_event: "packet_world_event",
                        world_particles: "packet_world_particles",
                        update_light: "packet_update_light",
                        login: "packet_login",
                        map: "packet_map",
                        trade_list: "packet_trade_list",
                        rel_entity_move: "packet_rel_entity_move",
                        entity_move_look: "packet_entity_move_look",
                        entity_look: "packet_entity_look",
                        vehicle_move: "packet_vehicle_move",
                        open_book: "packet_open_book",
                        open_window: "packet_open_window",
                        open_sign_entity: "packet_open_sign_entity",
                        ping: "packet_ping",
                        craft_recipe_response: "packet_craft_recipe_response",
                        abilities: "packet_abilities",
                        player_chat: "packet_player_chat",
                        end_combat_event: "packet_end_combat_event",
                        enter_combat_event: "packet_enter_combat_event",
                        death_combat_event: "packet_death_combat_event",
                        player_info: "packet_player_info",
                        face_player: "packet_face_player",
                        position: "packet_position",
                        unlock_recipes: "packet_unlock_recipes",
                        entity_destroy: "packet_entity_destroy",
                        remove_entity_effect: "packet_remove_entity_effect",
                        resource_pack_send: "packet_resource_pack_send",
                        respawn: "packet_respawn",
                        entity_head_rotation: "packet_entity_head_rotation",
                        multi_block_change: "packet_multi_block_change",
                        select_advancement_tab: "packet_select_advancement_tab",
                        server_data: "packet_server_data",
                        action_bar: "packet_action_bar",
                        world_border_center: "packet_world_border_center",
                        world_border_lerp_size: "packet_world_border_lerp_size",
                        world_border_size: "packet_world_border_size",
                        world_border_warning_delay: "packet_world_border_warning_delay",
                        world_border_warning_reach: "packet_world_border_warning_reach",
                        camera: "packet_camera",
                        held_item_slot: "packet_held_item_slot",
                        update_view_position: "packet_update_view_position",
                        update_view_distance: "packet_update_view_distance",
                        spawn_position: "packet_spawn_position",
                        should_display_chat_preview: "packet_should_display_chat_preview",
                        scoreboard_display_objective: "packet_scoreboard_display_objective",
                        entity_metadata: "packet_entity_metadata",
                        attach_entity: "packet_attach_entity",
                        entity_velocity: "packet_entity_velocity",
                        entity_equipment: "packet_entity_equipment",
                        experience: "packet_experience",
                        update_health: "packet_update_health",
                        scoreboard_objective: "packet_scoreboard_objective",
                        set_passengers: "packet_set_passengers",
                        teams: "packet_teams",
                        scoreboard_score: "packet_scoreboard_score",
                        simulation_distance: "packet_simulation_distance",
                        set_title_subtitle: "packet_set_title_subtitle",
                        update_time: "packet_update_time",
                        set_title_text: "packet_set_title_text",
                        set_title_time: "packet_set_title_time",
                        entity_sound_effect: "packet_entity_sound_effect",
                        sound_effect: "packet_sound_effect",
                        stop_sound: "packet_stop_sound",
                        system_chat: "packet_system_chat",
                        playerlist_header: "packet_playerlist_header",
                        nbt_query_response: "packet_nbt_query_response",
                        collect: "packet_collect",
                        entity_teleport: "packet_entity_teleport",
                        advancements: "packet_advancements",
                        entity_update_attributes: "packet_entity_update_attributes",
                        entity_effect: "packet_entity_effect",
                        declare_recipes: "packet_declare_recipes",
                        tags: "packet_tags"
                      }
                    }
                  ]
                }
              ]
            ]
          }
        },
        toServer: {
          types: {
            packet_teleport_confirm: [
              "container",
              [
                {
                  name: "teleportId",
                  type: "varint"
                }
              ]
            ],
            packet_query_block_nbt: [
              "container",
              [
                {
                  name: "transactionId",
                  type: "varint"
                },
                {
                  name: "location",
                  type: "position"
                }
              ]
            ],
            packet_chat_command: [
              "container",
              [
                {
                  name: "command",
                  type: "string"
                },
                {
                  name: "timestamp",
                  type: "i64"
                },
                {
                  name: "salt",
                  type: "i64"
                },
                {
                  name: "argumentSignatures",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "argumentName",
                            type: "string"
                          },
                          {
                            name: "signature",
                            type: [
                              "buffer",
                              {
                                countType: "varint"
                              }
                            ]
                          }
                        ]
                      ]
                    }
                  ]
                },
                {
                  name: "signedPreview",
                  type: "bool"
                }
              ]
            ],
            packet_chat_message: [
              "container",
              [
                {
                  name: "message",
                  type: "string"
                },
                {
                  name: "timestamp",
                  type: "i64"
                },
                {
                  name: "salt",
                  type: "i64"
                },
                {
                  name: "signature",
                  type: [
                    "buffer",
                    {
                      countType: "varint"
                    }
                  ]
                },
                {
                  name: "signedPreview",
                  type: "bool"
                }
              ]
            ],
            packet_chat_preview: [
              "container",
              [
                {
                  name: "query",
                  type: "i32"
                },
                {
                  name: "message",
                  type: "string"
                }
              ]
            ],
            packet_set_difficulty: [
              "container",
              [
                {
                  name: "newDifficulty",
                  type: "u8"
                }
              ]
            ],
            packet_edit_book: [
              "container",
              [
                {
                  name: "hand",
                  type: "varint"
                },
                {
                  name: "pages",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: "string"
                    }
                  ]
                },
                {
                  name: "title",
                  type: [
                    "option",
                    "string"
                  ]
                }
              ]
            ],
            packet_query_entity_nbt: [
              "container",
              [
                {
                  name: "transactionId",
                  type: "varint"
                },
                {
                  name: "entityId",
                  type: "varint"
                }
              ]
            ],
            packet_pick_item: [
              "container",
              [
                {
                  name: "slot",
                  type: "varint"
                }
              ]
            ],
            packet_name_item: [
              "container",
              [
                {
                  name: "name",
                  type: "string"
                }
              ]
            ],
            packet_select_trade: [
              "container",
              [
                {
                  name: "slot",
                  type: "varint"
                }
              ]
            ],
            packet_set_beacon_effect: [
              "container",
              [
                {
                  name: "primary_effect",
                  type: [
                    "option",
                    "varint"
                  ]
                },
                {
                  name: "secondary_effect",
                  type: [
                    "option",
                    "varint"
                  ]
                }
              ]
            ],
            packet_update_command_block: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "command",
                  type: "string"
                },
                {
                  name: "mode",
                  type: "varint"
                },
                {
                  name: "flags",
                  type: "u8"
                }
              ]
            ],
            packet_update_command_block_minecart: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "command",
                  type: "string"
                },
                {
                  name: "track_output",
                  type: "bool"
                }
              ]
            ],
            packet_update_structure_block: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "action",
                  type: "varint"
                },
                {
                  name: "mode",
                  type: "varint"
                },
                {
                  name: "name",
                  type: "string"
                },
                {
                  name: "offset_x",
                  type: "i8"
                },
                {
                  name: "offset_y",
                  type: "i8"
                },
                {
                  name: "offset_z",
                  type: "i8"
                },
                {
                  name: "size_x",
                  type: "i8"
                },
                {
                  name: "size_y",
                  type: "i8"
                },
                {
                  name: "size_z",
                  type: "i8"
                },
                {
                  name: "mirror",
                  type: "varint"
                },
                {
                  name: "rotation",
                  type: "varint"
                },
                {
                  name: "metadata",
                  type: "string"
                },
                {
                  name: "integrity",
                  type: "f32"
                },
                {
                  name: "seed",
                  type: "varint"
                },
                {
                  name: "flags",
                  type: "u8"
                }
              ]
            ],
            packet_tab_complete: [
              "container",
              [
                {
                  name: "transactionId",
                  type: "varint"
                },
                {
                  name: "text",
                  type: "string"
                }
              ]
            ],
            packet_client_command: [
              "container",
              [
                {
                  name: "actionId",
                  type: "varint"
                }
              ]
            ],
            packet_settings: [
              "container",
              [
                {
                  name: "locale",
                  type: "string"
                },
                {
                  name: "viewDistance",
                  type: "i8"
                },
                {
                  name: "chatFlags",
                  type: "varint"
                },
                {
                  name: "chatColors",
                  type: "bool"
                },
                {
                  name: "skinParts",
                  type: "u8"
                },
                {
                  name: "mainHand",
                  type: "varint"
                },
                {
                  name: "enableTextFiltering",
                  type: "bool"
                },
                {
                  name: "enableServerListing",
                  type: "bool"
                }
              ]
            ],
            packet_enchant_item: [
              "container",
              [
                {
                  name: "windowId",
                  type: "i8"
                },
                {
                  name: "enchantment",
                  type: "i8"
                }
              ]
            ],
            packet_window_click: [
              "container",
              [
                {
                  name: "windowId",
                  type: "u8"
                },
                {
                  name: "stateId",
                  type: "varint"
                },
                {
                  name: "slot",
                  type: "i16"
                },
                {
                  name: "mouseButton",
                  type: "i8"
                },
                {
                  name: "mode",
                  type: "varint"
                },
                {
                  name: "changedSlots",
                  type: [
                    "array",
                    {
                      countType: "varint",
                      type: [
                        "container",
                        [
                          {
                            name: "location",
                            type: "i16"
                          },
                          {
                            name: "item",
                            type: "slot"
                          }
                        ]
                      ]
                    }
                  ]
                },
                {
                  name: "cursorItem",
                  type: "slot"
                }
              ]
            ],
            packet_close_window: [
              "container",
              [
                {
                  name: "windowId",
                  type: "u8"
                }
              ]
            ],
            packet_custom_payload: [
              "container",
              [
                {
                  name: "channel",
                  type: "string"
                },
                {
                  name: "data",
                  type: "restBuffer"
                }
              ]
            ],
            packet_use_entity: [
              "container",
              [
                {
                  name: "target",
                  type: "varint"
                },
                {
                  name: "mouse",
                  type: "varint"
                },
                {
                  name: "x",
                  type: [
                    "switch",
                    {
                      compareTo: "mouse",
                      fields: {
                        "2": "f32"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "y",
                  type: [
                    "switch",
                    {
                      compareTo: "mouse",
                      fields: {
                        "2": "f32"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "z",
                  type: [
                    "switch",
                    {
                      compareTo: "mouse",
                      fields: {
                        "2": "f32"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "hand",
                  type: [
                    "switch",
                    {
                      compareTo: "mouse",
                      fields: {
                        "0": "varint",
                        "2": "varint"
                      },
                      default: "void"
                    }
                  ]
                },
                {
                  name: "sneaking",
                  type: "bool"
                }
              ]
            ],
            packet_generate_structure: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "levels",
                  type: "varint"
                },
                {
                  name: "keepJigsaws",
                  type: "bool"
                }
              ]
            ],
            packet_keep_alive: [
              "container",
              [
                {
                  name: "keepAliveId",
                  type: "i64"
                }
              ]
            ],
            packet_lock_difficulty: [
              "container",
              [
                {
                  name: "locked",
                  type: "bool"
                }
              ]
            ],
            packet_position: [
              "container",
              [
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "onGround",
                  type: "bool"
                }
              ]
            ],
            packet_position_look: [
              "container",
              [
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "yaw",
                  type: "f32"
                },
                {
                  name: "pitch",
                  type: "f32"
                },
                {
                  name: "onGround",
                  type: "bool"
                }
              ]
            ],
            packet_look: [
              "container",
              [
                {
                  name: "yaw",
                  type: "f32"
                },
                {
                  name: "pitch",
                  type: "f32"
                },
                {
                  name: "onGround",
                  type: "bool"
                }
              ]
            ],
            packet_flying: [
              "container",
              [
                {
                  name: "onGround",
                  type: "bool"
                }
              ]
            ],
            packet_vehicle_move: [
              "container",
              [
                {
                  name: "x",
                  type: "f64"
                },
                {
                  name: "y",
                  type: "f64"
                },
                {
                  name: "z",
                  type: "f64"
                },
                {
                  name: "yaw",
                  type: "f32"
                },
                {
                  name: "pitch",
                  type: "f32"
                }
              ]
            ],
            packet_steer_boat: [
              "container",
              [
                {
                  name: "leftPaddle",
                  type: "bool"
                },
                {
                  name: "rightPaddle",
                  type: "bool"
                }
              ]
            ],
            packet_craft_recipe_request: [
              "container",
              [
                {
                  name: "windowId",
                  type: "i8"
                },
                {
                  name: "recipe",
                  type: "string"
                },
                {
                  name: "makeAll",
                  type: "bool"
                }
              ]
            ],
            packet_abilities: [
              "container",
              [
                {
                  name: "flags",
                  type: "i8"
                }
              ]
            ],
            packet_block_dig: [
              "container",
              [
                {
                  name: "status",
                  type: "varint"
                },
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "face",
                  type: "i8"
                },
                {
                  name: "sequence",
                  type: "varint"
                }
              ]
            ],
            packet_entity_action: [
              "container",
              [
                {
                  name: "entityId",
                  type: "varint"
                },
                {
                  name: "actionId",
                  type: "varint"
                },
                {
                  name: "jumpBoost",
                  type: "varint"
                }
              ]
            ],
            packet_steer_vehicle: [
              "container",
              [
                {
                  name: "sideways",
                  type: "f32"
                },
                {
                  name: "forward",
                  type: "f32"
                },
                {
                  name: "jump",
                  type: "u8"
                }
              ]
            ],
            packet_displayed_recipe: [
              "container",
              [
                {
                  name: "recipeId",
                  type: "string"
                }
              ]
            ],
            packet_recipe_book: [
              "container",
              [
                {
                  name: "bookId",
                  type: "varint"
                },
                {
                  name: "bookOpen",
                  type: "bool"
                },
                {
                  name: "filterActive",
                  type: "bool"
                }
              ]
            ],
            packet_resource_pack_receive: [
              "container",
              [
                {
                  name: "result",
                  type: "varint"
                }
              ]
            ],
            packet_held_item_slot: [
              "container",
              [
                {
                  name: "slotId",
                  type: "i16"
                }
              ]
            ],
            packet_set_creative_slot: [
              "container",
              [
                {
                  name: "slot",
                  type: "i16"
                },
                {
                  name: "item",
                  type: "slot"
                }
              ]
            ],
            packet_update_jigsaw_block: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "name",
                  type: "string"
                },
                {
                  name: "target",
                  type: "string"
                },
                {
                  name: "pool",
                  type: "string"
                },
                {
                  name: "finalState",
                  type: "string"
                },
                {
                  name: "jointType",
                  type: "string"
                }
              ]
            ],
            packet_update_sign: [
              "container",
              [
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "text1",
                  type: "string"
                },
                {
                  name: "text2",
                  type: "string"
                },
                {
                  name: "text3",
                  type: "string"
                },
                {
                  name: "text4",
                  type: "string"
                }
              ]
            ],
            packet_arm_animation: [
              "container",
              [
                {
                  name: "hand",
                  type: "varint"
                }
              ]
            ],
            packet_spectate: [
              "container",
              [
                {
                  name: "target",
                  type: "UUID"
                }
              ]
            ],
            packet_block_place: [
              "container",
              [
                {
                  name: "hand",
                  type: "varint"
                },
                {
                  name: "location",
                  type: "position"
                },
                {
                  name: "direction",
                  type: "varint"
                },
                {
                  name: "cursorX",
                  type: "f32"
                },
                {
                  name: "cursorY",
                  type: "f32"
                },
                {
                  name: "cursorZ",
                  type: "f32"
                },
                {
                  name: "insideBlock",
                  type: "bool"
                },
                {
                  name: "sequence",
                  type: "varint"
                }
              ]
            ],
            packet_use_item: [
              "container",
              [
                {
                  name: "hand",
                  type: "varint"
                },
                {
                  name: "sequence",
                  type: "varint"
                }
              ]
            ],
            packet_advancement_tab: [
              "container",
              [
                {
                  name: "action",
                  type: "varint"
                },
                {
                  name: "tabId",
                  type: [
                    "switch",
                    {
                      compareTo: "action",
                      fields: {
                        "0": "string",
                        "1": "void"
                      }
                    }
                  ]
                }
              ]
            ],
            packet_pong: [
              "container",
              [
                {
                  name: "id",
                  type: "i32"
                }
              ]
            ],
            packet: [
              "container",
              [
                {
                  name: "name",
                  type: [
                    "mapper",
                    {
                      type: "varint",
                      mappings: {
                        "0x00": "teleport_confirm",
                        "0x01": "query_block_nbt",
                        "0x02": "set_difficulty",
                        "0x03": "chat_command",
                        "0x04": "chat_message",
                        "0x05": "chat_preview",
                        "0x06": "client_command",
                        "0x07": "settings",
                        "0x08": "tab_complete",
                        "0x09": "enchant_item",
                        "0x0a": "window_click",
                        "0x0b": "close_window",
                        "0x0c": "custom_payload",
                        "0x0d": "edit_book",
                        "0x0e": "query_entity_nbt",
                        "0x0f": "use_entity",
                        "0x10": "generate_structure",
                        "0x11": "keep_alive",
                        "0x12": "lock_difficulty",
                        "0x13": "position",
                        "0x14": "position_look",
                        "0x15": "look",
                        "0x16": "flying",
                        "0x17": "vehicle_move",
                        "0x18": "steer_boat",
                        "0x19": "pick_item",
                        "0x1a": "craft_recipe_request",
                        "0x1b": "abilities",
                        "0x1c": "block_dig",
                        "0x1d": "entity_action",
                        "0x1e": "steer_vehicle",
                        "0x1f": "pong",
                        "0x20": "recipe_book",
                        "0x21": "displayed_recipe",
                        "0x22": "name_item",
                        "0x23": "resource_pack_receive",
                        "0x24": "advancement_tab",
                        "0x25": "select_trade",
                        "0x26": "set_beacon_effect",
                        "0x27": "held_item_slot",
                        "0x28": "update_command_block",
                        "0x29": "update_command_block_minecart",
                        "0x2a": "set_creative_slot",
                        "0x2b": "update_jigsaw_block",
                        "0x2c": "update_structure_block",
                        "0x2d": "update_sign",
                        "0x2e": "arm_animation",
                        "0x2f": "spectate",
                        "0x30": "block_place",
                        "0x31": "use_item"
                      }
                    }
                  ]
                },
                {
                  name: "params",
                  type: [
                    "switch",
                    {
                      compareTo: "name",
                      fields: {
                        teleport_confirm: "packet_teleport_confirm",
                        query_block_nbt: "packet_query_block_nbt",
                        set_difficulty: "packet_set_difficulty",
                        chat_command: "packet_chat_command",
                        chat_message: "packet_chat_message",
                        chat_preview: "packet_chat_preview",
                        client_command: "packet_client_command",
                        settings: "packet_settings",
                        tab_complete: "packet_tab_complete",
                        enchant_item: "packet_enchant_item",
                        window_click: "packet_window_click",
                        close_window: "packet_close_window",
                        custom_payload: "packet_custom_payload",
                        edit_book: "packet_edit_book",
                        query_entity_nbt: "packet_query_entity_nbt",
                        use_entity: "packet_use_entity",
                        generate_structure: "packet_generate_structure",
                        keep_alive: "packet_keep_alive",
                        lock_difficulty: "packet_lock_difficulty",
                        position: "packet_position",
                        position_look: "packet_position_look",
                        look: "packet_look",
                        flying: "packet_flying",
                        vehicle_move: "packet_vehicle_move",
                        steer_boat: "packet_steer_boat",
                        pick_item: "packet_pick_item",
                        craft_recipe_request: "packet_craft_recipe_request",
                        abilities: "packet_abilities",
                        block_dig: "packet_block_dig",
                        entity_action: "packet_entity_action",
                        steer_vehicle: "packet_steer_vehicle",
                        pong: "packet_pong",
                        recipe_book: "packet_recipe_book",
                        displayed_recipe: "packet_displayed_recipe",
                        name_item: "packet_name_item",
                        resource_pack_receive: "packet_resource_pack_receive",
                        advancement_tab: "packet_advancement_tab",
                        select_trade: "packet_select_trade",
                        set_beacon_effect: "packet_set_beacon_effect",
                        held_item_slot: "packet_held_item_slot",
                        update_command_block: "packet_update_command_block",
                        update_command_block_minecart: "packet_update_command_block_minecart",
                        set_creative_slot: "packet_set_creative_slot",
                        update_jigsaw_block: "packet_update_jigsaw_block",
                        update_structure_block: "packet_update_structure_block",
                        update_sign: "packet_update_sign",
                        arm_animation: "packet_arm_animation",
                        spectate: "packet_spectate",
                        block_place: "packet_block_place",
                        use_item: "packet_use_item"
                      }
                    }
                  ]
                }
              ]
            ]
          }
        }
      }
    };
  }
});

// node_modules/minecraft-data/minecraft-data/data/pc/1.19/version.json
var version_default;
var init_version = __esm({
  "node_modules/minecraft-data/minecraft-data/data/pc/1.19/version.json"() {
    version_default = {
      minecraftVersion: "1.19",
      version: 759,
      majorVersion: "1.19"
    };
  }
});

// alias/minecraft-data.js
var require_minecraft_data = __commonJS({
  "alias/minecraft-data.js"(exports2, module2) {
    init_protocol();
    init_version();
    module2.exports = () => ({ protocol: protocol_default, version: version_default });
  }
});

// ../node_modules/minecraft-protocol/src/datatypes/compiler-minecraft.js
var require_compiler_minecraft = __commonJS({
  "../node_modules/minecraft-protocol/src/datatypes/compiler-minecraft.js"(exports2, module2) {
    var UUID = require_uuid_1345();
    var minecraft = require_minecraft();
    module2.exports = {
      Read: {
        varlong: ["native", minecraft.varlong[0]],
        UUID: ["native", (buffer, offset) => {
          return {
            value: UUID.stringify(buffer.slice(offset, 16 + offset)),
            size: 16
          };
        }],
        restBuffer: ["native", (buffer, offset) => {
          return {
            value: buffer.slice(offset),
            size: buffer.length - offset
          };
        }],
        nbt: ["native", minecraft.nbt[0]],
        optionalNbt: ["native", minecraft.optionalNbt[0]],
        compressedNbt: ["native", minecraft.compressedNbt[0]],
        entityMetadataLoop: ["parametrizable", (compiler, { type, endVal }) => {
          let code2 = "let cursor = offset\n";
          code2 += "const data = []\n";
          code2 += "while (true) {\n";
          code2 += `  if (ctx.u8(buffer, cursor).value === ${endVal}) return { value: data, size: cursor + 1 - offset }
`;
          code2 += "  const elem = " + compiler.callType(type, "cursor") + "\n";
          code2 += "  data.push(elem.value)\n";
          code2 += "  cursor += elem.size\n";
          code2 += "}";
          return compiler.wrapCode(code2);
        }],
        topBitSetTerminatedArray: ["parametrizable", (compiler, { type, endVal }) => {
          let code2 = "let cursor = offset\n";
          code2 += "const data = []\n";
          code2 += "while (true) {\n";
          code2 += "  const item = ctx.u8(buffer, cursor).value\n";
          code2 += "  buffer[cursor] = buffer[cursor] & 127\n";
          code2 += "  const elem = " + compiler.callType(type, "cursor") + "\n";
          code2 += "  data.push(elem.value)\n";
          code2 += "  cursor += elem.size\n";
          code2 += "  if ((item & 128) === 0) return { value: data, size: cursor - offset }\n";
          code2 += "}";
          return compiler.wrapCode(code2);
        }]
      },
      Write: {
        varlong: ["native", minecraft.varlong[1]],
        UUID: ["native", (value, buffer, offset) => {
          const buf = UUID.parse(value);
          buf.copy(buffer, offset);
          return offset + 16;
        }],
        restBuffer: ["native", (value, buffer, offset) => {
          value.copy(buffer, offset);
          return offset + value.length;
        }],
        nbt: ["native", minecraft.nbt[1]],
        optionalNbt: ["native", minecraft.optionalNbt[1]],
        compressedNbt: ["native", minecraft.compressedNbt[1]],
        entityMetadataLoop: ["parametrizable", (compiler, { type, endVal }) => {
          let code2 = "for (const i in value) {\n";
          code2 += "  offset = " + compiler.callType("value[i]", type) + "\n";
          code2 += "}\n";
          code2 += `return offset + ctx.u8(${endVal}, buffer, offset)`;
          return compiler.wrapCode(code2);
        }],
        topBitSetTerminatedArray: ["parametrizable", (compiler, { type }) => {
          let code2 = "let prevOffset = offset\n";
          code2 += "let ind = 0\n";
          code2 += "for (const i in value) {\n";
          code2 += "  prevOffset = offset\n";
          code2 += "  offset = " + compiler.callType("value[i]", type) + "\n";
          code2 += "  buffer[prevOffset] = ind !== value.length-1 ? (buffer[prevOffset] | 128) : buffer[prevOffset]\n";
          code2 += "  ind++\n";
          code2 += "}\n";
          code2 += "return offset";
          return compiler.wrapCode(code2);
        }]
      },
      SizeOf: {
        varlong: ["native", minecraft.varlong[2]],
        UUID: ["native", 16],
        restBuffer: ["native", (value) => {
          return value.length;
        }],
        nbt: ["native", minecraft.nbt[2]],
        optionalNbt: ["native", minecraft.optionalNbt[2]],
        compressedNbt: ["native", minecraft.compressedNbt[2]],
        entityMetadataLoop: ["parametrizable", (compiler, { type }) => {
          let code2 = "let size = 1\n";
          code2 += "for (const i in value) {\n";
          code2 += "  size += " + compiler.callType("value[i]", type) + "\n";
          code2 += "}\n";
          code2 += "return size";
          return compiler.wrapCode(code2);
        }],
        topBitSetTerminatedArray: ["parametrizable", (compiler, { type }) => {
          let code2 = "let size = 0\n";
          code2 += "for (const i in value) {\n";
          code2 += "  size += " + compiler.callType("value[i]", type) + "\n";
          code2 += "}\n";
          code2 += "return size";
          return compiler.wrapCode(code2);
        }]
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/transforms/serializer.js
var require_serializer2 = __commonJS({
  "../node_modules/minecraft-protocol/src/transforms/serializer.js"(exports2, module2) {
    "use strict";
    var ProtoDef = require_protodef2().ProtoDef;
    var Serializer = require_protodef2().Serializer;
    var Parser = require_protodef2().FullPacketParser;
    var { ProtoDefCompiler: ProtoDefCompiler2 } = require_protodef2().Compiler;
    var minecraft = require_minecraft();
    var states = require_states();
    var merge = require_lodash3();
    var get = require_lodash2();
    var protocols = {};
    function createProtocol(state, direction, version, customPackets, compiled = true) {
      const key = state + ";" + direction + ";" + version + (compiled ? ";c" : "");
      if (protocols[key]) {
        return protocols[key];
      }
      const mcData = require_minecraft_data()(version);
      if (mcData === null) {
        throw new Error(`No data available for version ${version}`);
      }
      if (compiled) {
        const compiler = new ProtoDefCompiler2();
        compiler.addTypes(require_compiler_minecraft());
        compiler.addProtocol(merge(mcData.protocol, get(customPackets, [mcData.version.majorVersion])), [state, direction]);
        const proto2 = compiler.compileProtoDefSync();
        protocols[key] = proto2;
        return proto2;
      }
      const proto = new ProtoDef(false);
      proto.addTypes(minecraft);
      proto.addProtocol(merge(mcData.protocol, get(customPackets, [mcData.version.majorVersion])), [state, direction]);
      protocols[key] = proto;
      return proto;
    }
    function createSerializer({ state = states.HANDSHAKING, isServer = false, version, customPackets, compiled = true } = {}) {
      return new Serializer(createProtocol(state, !isServer ? "toServer" : "toClient", version, customPackets, compiled), "packet");
    }
    function createDeserializer({ state = states.HANDSHAKING, isServer = false, version, customPackets, compiled = true, noErrorLogging = false } = {}) {
      return new Parser(createProtocol(state, isServer ? "toServer" : "toClient", version, customPackets, compiled), "packet", noErrorLogging);
    }
    module2.exports = {
      createSerializer,
      createDeserializer
    };
  }
});

// ../node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "../node_modules/aes-js/index.js"(exports2, module2) {
    (function(root) {
      "use strict";
      function checkInt(value) {
        return parseInt(value) === value;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i = 0; i < arrayish.length; i++) {
          if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy) {
        if (arg.buffer && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length) {
        return new Uint8Array(length);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = function() {
        function toBytes(text) {
          var result = [], i = 0;
          text = encodeURI(text);
          while (i < text.length) {
            var c = text.charCodeAt(i++);
            if (c === 37) {
              result.push(parseInt(text.substr(i, 2), 16));
              i += 2;
            } else {
              result.push(c);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes) {
          var result = [], i = 0;
          while (i < bytes.length) {
            var c = bytes[i];
            if (c < 128) {
              result.push(String.fromCharCode(c));
              i++;
            } else if (c > 191 && c < 224) {
              result.push(String.fromCharCode((c & 31) << 6 | bytes[i + 1] & 63));
              i += 2;
            } else {
              result.push(String.fromCharCode((c & 15) << 12 | (bytes[i + 1] & 63) << 6 | bytes[i + 2] & 63));
              i += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var convertHex = function() {
        function toBytes(text) {
          var result = [];
          for (var i = 0; i < text.length; i += 2) {
            result.push(parseInt(text.substr(i, 2), 16));
          }
          return result;
        }
        var Hex = "0123456789abcdef";
        function fromBytes(bytes) {
          var result = [];
          for (var i = 0; i < bytes.length; i++) {
            var v = bytes[i];
            result.push(Hex[(v & 240) >> 4] + Hex[v & 15]);
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i += 4) {
          result.push(
            bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]
          );
        }
        return result;
      }
      var AES = function(key) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key, true)
        });
        this._prepare();
      };
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i = 0; i <= rounds; i++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index;
        for (var i = 0; i < KC; i++) {
          index = i >> 2;
          this._Ke[index][i % 4] = tk[i];
          this._Kd[rounds - index][i % 4] = tk[i];
        }
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
          tt = tk[KC - 1];
          tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i = 1; i < KC; i++) {
              tk[i] ^= tk[i - 1];
            }
          } else {
            for (var i = 1; i < KC / 2; i++) {
              tk[i] ^= tk[i - 1];
            }
            tt = tk[KC / 2 - 1];
            tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
            for (var i = KC / 2 + 1; i < KC; i++) {
              tk[i] ^= tk[i - 1];
            }
          }
          var i = 0, r, c;
          while (i < KC && t < roundKeyCount) {
            r = t >> 2;
            c = t % 4;
            this._Ke[r][c] = tk[i];
            this._Kd[rounds - r][c] = tk[i++];
            t++;
          }
        }
        for (var r = 1; r < rounds; r++) {
          for (var c = 0; c < 4; c++) {
            tt = this._Kd[r][c];
            this._Kd[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= this._Ke[0][i];
        }
        for (var r = 1; r < rounds; r++) {
          for (var i = 0; i < 4; i++) {
            a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ this._Ke[r][i];
          }
          t = a.slice();
        }
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
          tt = this._Ke[rounds][i];
          result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= this._Kd[0][i];
        }
        for (var r = 1; r < rounds; r++) {
          for (var i = 0; i < 4; i++) {
            a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ this._Kd[r][i];
          }
          t = a.slice();
        }
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
          tt = this._Kd[rounds][i];
          result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i = 0; i < plaintext.length; i += 16) {
          copyArray(plaintext, block, 0, i, i + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i = 0; i < ciphertext.length; i += 16) {
          copyArray(ciphertext, block, 0, i, i + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i = 0; i < plaintext.length; i += 16) {
          copyArray(plaintext, block, 0, i, i + 16);
          for (var j = 0; j < 16; j++) {
            block[j] ^= this._lastCipherblock[j];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i = 0; i < ciphertext.length; i += 16) {
          copyArray(ciphertext, block, 0, i, i + 16);
          block = this._aes.decrypt(block);
          for (var j = 0; j < 16; j++) {
            plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            encrypted[i + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            plaintext[i + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i = 0; i < encrypted.length; i++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        if (value > Number.MAX_SAFE_INTEGER) {
          throw new Error("integer value out of safe range");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value % 256;
          value = parseInt(value / 256);
        }
      };
      Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes;
      };
      Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
          if (this._counter[i] === 255) {
            this._counter[i] = 0;
          } else {
            this._counter[i]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i = 0; i < encrypted.length; i++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i = data.length; i < result.length; i++) {
          result[i] = padder;
        }
        return result;
      }
      function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data[data.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length = data.length - padder;
        for (var i = 0; i < padder; i++) {
          if (data[length + i] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
      }
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports2 !== "undefined") {
        module2.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return aesjs;
        });
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports2);
  }
});

// ../node_modules/minecraft-protocol/src/transforms/encryption.js
var require_encryption = __commonJS({
  "../node_modules/minecraft-protocol/src/transforms/encryption.js"(exports2, module2) {
    var Transform = require_ours().Transform;
    var crypto = require("crypto");
    var aesjs = require_aes_js();
    function createCipher(secret) {
      if (crypto.getCiphers().includes("aes-128-cfb8")) {
        return crypto.createCipheriv("aes-128-cfb8", secret, secret);
      }
      return new Cipher(secret);
    }
    function createDecipher(secret) {
      if (crypto.getCiphers().includes("aes-128-cfb8")) {
        return crypto.createDecipheriv("aes-128-cfb8", secret, secret);
      }
      return new Decipher(secret);
    }
    var Cipher = class extends Transform {
      constructor(secret) {
        super();
        this.aes = new aesjs.ModeOfOperation.cfb(secret, secret, 1);
      }
      _transform(chunk, enc, cb) {
        try {
          const res = this.aes.encrypt(chunk);
          cb(null, res);
        } catch (e) {
          cb(e);
        }
      }
    };
    var Decipher = class extends Transform {
      constructor(secret) {
        super();
        this.aes = new aesjs.ModeOfOperation.cfb(secret, secret, 1);
      }
      _transform(chunk, enc, cb) {
        try {
          const res = this.aes.decrypt(chunk);
          cb(null, res);
        } catch (e) {
          cb(e);
        }
      }
    };
    module2.exports = {
      createCipher,
      createDecipher
    };
  }
});

// ../node_modules/minecraft-protocol/src/client/tcp_dns.js
var require_tcp_dns = __commonJS({
  "../node_modules/minecraft-protocol/src/client/tcp_dns.js"(exports2, module2) {
    var net = require("net");
    var dns = require("dns");
    module2.exports = function(client, options) {
      options.port = options.port || 25565;
      options.host = options.host || "localhost";
      if (!options.connect) {
        options.connect = (client2) => {
          if (options.stream) {
            client2.setSocket(options.stream);
            client2.emit("connect");
            return;
          }
          if (options.port === 25565 && net.isIP(options.host) === 0 && options.host !== "localhost") {
            dns.resolveSrv("_minecraft._tcp." + options.host, (err, addresses) => {
              if (err) {
                client2.setSocket(net.connect(options.port, options.host));
                return;
              }
              if (addresses && addresses.length > 0) {
                options.host = addresses[0].name;
                options.port = addresses[0].port;
                client2.setSocket(net.connect(addresses[0].port, addresses[0].name));
              } else {
                client2.setSocket(net.connect(options.port, options.host));
              }
            });
          } else {
            client2.setSocket(net.connect(options.port, options.host));
          }
        };
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/client.js
var require_client = __commonJS({
  "../node_modules/minecraft-protocol/src/client.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var debug = require_src()("minecraft-protocol");
    var compression = require_compression();
    var framing = require_framing();
    var states = require_states();
    var createSerializer = require_serializer2().createSerializer;
    var createDeserializer = require_serializer2().createDeserializer;
    var createCipher = require_encryption().createCipher;
    var createDecipher = require_encryption().createDecipher;
    var closeTimeout = 30 * 1e3;
    var Client = class extends EventEmitter {
      constructor(isServer, version, customPackets, hideErrors = false) {
        super();
        this.customPackets = customPackets;
        this.version = version;
        this.isServer = !!isServer;
        this.splitter = framing.createSplitter();
        this.packetsToParse = {};
        this.compressor = null;
        this.framer = framing.createFramer();
        this.cipher = null;
        this.decipher = null;
        this.decompressor = null;
        this.ended = true;
        this.latency = 0;
        this.hideErrors = hideErrors;
        this.closeTimer = null;
        this.state = states.HANDSHAKING;
      }
      get state() {
        return this.protocolState;
      }
      setSerializer(state) {
        this.serializer = createSerializer({ isServer: this.isServer, version: this.version, state, customPackets: this.customPackets });
        this.deserializer = createDeserializer({
          isServer: this.isServer,
          version: this.version,
          state,
          packetsToParse: this.packetsToParse,
          customPackets: this.customPackets,
          noErrorLogging: this.hideErrors
        });
        this.splitter.recognizeLegacyPing = state === states.HANDSHAKING;
        this.serializer.on("error", (e) => {
          let parts;
          if (e.field) {
            parts = e.field.split(".");
            parts.shift();
          } else {
            parts = [];
          }
          const serializerDirection = !this.isServer ? "toServer" : "toClient";
          e.field = [this.protocolState, serializerDirection].concat(parts).join(".");
          e.message = `Serialization error for ${e.field} : ${e.message}`;
          if (!this.compressor) {
            this.serializer.pipe(this.framer);
          } else {
            this.serializer.pipe(this.compressor);
          }
          this.emit("error", e);
        });
        this.deserializer.on("error", (e) => {
          let parts;
          if (e.field) {
            parts = e.field.split(".");
            parts.shift();
          } else {
            parts = [];
          }
          const deserializerDirection = this.isServer ? "toServer" : "toClient";
          e.field = [this.protocolState, deserializerDirection].concat(parts).join(".");
          e.message = `Deserialization error for ${e.field} : ${e.message}`;
          if (!this.compressor) {
            this.splitter.pipe(this.deserializer);
          } else {
            this.decompressor.pipe(this.deserializer);
          }
          this.emit("error", e);
        });
        this.deserializer.on("data", (parsed) => {
          parsed.metadata.name = parsed.data.name;
          parsed.data = parsed.data.params;
          parsed.metadata.state = state;
          debug("read packet " + state + "." + parsed.metadata.name);
          if (debug.enabled) {
            const s = JSON.stringify(parsed.data, null, 2);
            debug(s && s.length > 1e4 ? parsed.data : s);
          }
          this.emit("packet", parsed.data, parsed.metadata, parsed.buffer, parsed.fullBuffer);
          this.emit(parsed.metadata.name, parsed.data, parsed.metadata);
          this.emit("raw." + parsed.metadata.name, parsed.buffer, parsed.metadata);
          this.emit("raw", parsed.buffer, parsed.metadata);
        });
      }
      set state(newProperty) {
        const oldProperty = this.protocolState;
        this.protocolState = newProperty;
        if (this.serializer) {
          if (!this.compressor) {
            this.serializer.unpipe();
            this.splitter.unpipe(this.deserializer);
          } else {
            this.serializer.unpipe(this.compressor);
            this.decompressor.unpipe(this.deserializer);
          }
          this.serializer.removeAllListeners();
          this.deserializer.removeAllListeners();
        }
        this.setSerializer(this.protocolState);
        if (!this.compressor) {
          this.serializer.pipe(this.framer);
          this.splitter.pipe(this.deserializer);
        } else {
          this.serializer.pipe(this.compressor);
          this.decompressor.pipe(this.deserializer);
        }
        this.emit("state", newProperty, oldProperty);
      }
      get compressionThreshold() {
        return this.compressor == null ? -2 : this.compressor.compressionThreshold;
      }
      set compressionThreshold(threshold) {
        this.setCompressionThreshold(threshold);
      }
      setSocket(socket) {
        this.ended = false;
        const endSocket = () => {
          if (this.ended)
            return;
          this.ended = true;
          clearTimeout(this.closeTimer);
          this.socket.removeListener("close", endSocket);
          this.socket.removeListener("end", endSocket);
          this.socket.removeListener("timeout", endSocket);
          this.emit("end", this._endReason || "socketClosed");
        };
        const onFatalError = (err) => {
          this.emit("error", err);
          endSocket();
        };
        const onError = (err) => this.emit("error", err);
        this.socket = socket;
        if (this.socket.setNoDelay) {
          this.socket.setNoDelay(true);
        }
        this.socket.on("connect", () => this.emit("connect"));
        this.socket.on("error", onFatalError);
        this.socket.on("close", endSocket);
        this.socket.on("end", endSocket);
        this.socket.on("timeout", endSocket);
        this.framer.on("error", onError);
        this.splitter.on("error", onError);
        this.socket.pipe(this.splitter);
        this.framer.pipe(this.socket);
      }
      end(reason) {
        this._endReason = reason;
        if (this.serializer) {
          this.serializer.end();
        } else {
          if (this.socket)
            this.socket.end();
        }
        if (this.socket) {
          this.closeTimer = setTimeout(
            this.socket.destroy.bind(this.socket),
            closeTimeout
          );
        }
      }
      setEncryption(sharedSecret) {
        if (this.cipher != null) {
          this.emit("error", new Error("Set encryption twice!"));
        }
        this.cipher = createCipher(sharedSecret);
        this.cipher.on("error", (err) => this.emit("error", err));
        this.framer.unpipe(this.socket);
        this.framer.pipe(this.cipher).pipe(this.socket);
        this.decipher = createDecipher(sharedSecret);
        this.decipher.on("error", (err) => this.emit("error", err));
        this.socket.unpipe(this.splitter);
        this.socket.pipe(this.decipher).pipe(this.splitter);
      }
      setCompressionThreshold(threshold) {
        if (this.compressor == null) {
          this.compressor = compression.createCompressor(threshold);
          this.compressor.on("error", (err) => this.emit("error", err));
          this.serializer.unpipe(this.framer);
          this.serializer.pipe(this.compressor).pipe(this.framer);
          this.decompressor = compression.createDecompressor(threshold, this.hideErrors);
          this.decompressor.on("error", (err) => this.emit("error", err));
          this.splitter.unpipe(this.deserializer);
          this.splitter.pipe(this.decompressor).pipe(this.deserializer);
        } else {
          this.decompressor.threshold = threshold;
          this.compressor.threshold = threshold;
        }
      }
      write(name, params) {
        if (!this.serializer.writable) {
          return;
        }
        debug("writing packet " + this.state + "." + name);
        debug(params);
        this.serializer.write({ name, params });
      }
      writeRaw(buffer) {
        const stream = this.compressor === null ? this.framer : this.compressor;
        if (!stream.writable) {
          return;
        }
        stream.write(buffer);
      }
      connect(port, host) {
        const options = { port, host };
        if (!this.options)
          this.options = options;
        require_tcp_dns()(this, options);
        options.connect(this);
      }
    };
    module2.exports = Client;
  }
});

// ../node_modules/minecraft-protocol/src/server.js
var require_server = __commonJS({
  "../node_modules/minecraft-protocol/src/server.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var EventEmitter = require("events").EventEmitter;
    var Client = require_client();
    var states = require_states();
    var { createSerializer } = require_serializer2();
    var Server = class extends EventEmitter {
      constructor(version, customPackets, hideErrors = false) {
        super();
        this.version = version;
        this.socketServer = null;
        this.cipher = null;
        this.decipher = null;
        this.clients = {};
        this.customPackets = customPackets;
        this.hideErrors = hideErrors;
        this.serializer = createSerializer({ state: "play", isServer: true, version, customPackets });
      }
      listen(port, host) {
        const self2 = this;
        let nextId = 0;
        self2.socketServer = net.createServer();
        self2.socketServer.on("connection", (socket) => {
          const client = new Client(true, this.version, this.customPackets, this.hideErrors);
          client._end = client.end;
          client.end = function end(endReason, fullReason = JSON.stringify({ text: endReason })) {
            if (client.state === states.PLAY) {
              client.write("kick_disconnect", { reason: fullReason });
            } else if (client.state === states.LOGIN) {
              client.write("disconnect", { reason: fullReason });
            }
            client._end(endReason);
          };
          client.id = nextId++;
          self2.clients[client.id] = client;
          client.on("end", function() {
            delete self2.clients[client.id];
          });
          client.setSocket(socket);
          self2.emit("connection", client);
        });
        self2.socketServer.on("error", function(err) {
          self2.emit("error", err);
        });
        self2.socketServer.on("close", function() {
          self2.emit("close");
        });
        self2.socketServer.on("listening", function() {
          self2.emit("listening");
        });
        self2.socketServer.listen(port, host);
      }
      close() {
        Object.keys(this.clients).forEach((clientId) => {
          const client = this.clients[clientId];
          client.end("ServerShutdown");
        });
        this.socketServer.close();
      }
      writeToClients(clients, name, params) {
        if (clients.length === 0)
          return;
        const buffer = this.serializer.createPacketBuffer({ name, params });
        clients.forEach((client) => client.writeRaw(buffer));
      }
    };
    module2.exports = Server;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/regex.js
var require_regex = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/validate.js
var require_validate2 = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    function stringify(arr, offset = 0) {
      const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.default)(b);
    }
    var _default = v1;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/parse.js
var require_parse = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    exports2.URL = exports2.DNS = void 0;
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL2;
    function _default(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (namespace.length !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.default)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default = md5;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.default)(rnds);
    }
    var _default = v4;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default = sha1;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/version.js
var require_version = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.substr(14, 1), 16);
    }
    var _default = version;
    exports2.default = _default;
  }
});

// ../node_modules/yggdrasil/node_modules/uuid/dist/index.js
var require_dist = __commonJS({
  "../node_modules/yggdrasil/node_modules/uuid/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate2());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// ../node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "../node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// ../node_modules/whatwg-url/lib/utils.js
var require_utils6 = __commonJS({
  "../node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// ../node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "../node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// ../node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "../node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// ../node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "../node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path = url.path;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// ../node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "../node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// ../node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "../node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib();
    var utils2 = require_utils6();
    var Impl = require_URL_impl();
    var impl = utils2.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils2.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// ../node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "../node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// ../node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "../node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob = class {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      buffer() {
        return consumeBody.call(this);
      },
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
          Object.defineProperty(proto, name, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name) {
      name = `${name}`;
      if (invalidTokenRegex.test(name) || name === "") {
        throw new TypeError(`${name} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name) {
      name = name.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class {
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      get(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      set(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        this[MAP][key !== void 0 ? key : name] = [value];
      }
      append(name, value) {
        name = `${name}`;
        value = `${value}`;
        validateName(name);
        validateValue(value);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name] = [value];
        }
      }
      has(name) {
        name = `${name}`;
        validateName(name);
        return find(this[MAP], name) !== void 0;
      }
      delete(name) {
        name = `${name}`;
        validateName(name);
        const key = find(this[MAP], name);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      raw() {
        return this[MAP];
      }
      keys() {
        return createHeadersIterator(this, "key");
      }
      values() {
        return createHeadersIterator(this, "value");
      }
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name of Object.keys(obj)) {
        if (invalidTokenRegex.test(name)) {
          continue;
        }
        if (Array.isArray(obj[name])) {
          for (const val of obj[name]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name] === void 0) {
              headers[MAP][name] = [val];
            } else {
              headers[MAP][name].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name])) {
          headers[MAP][name] = [obj[name]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      clone() {
        return new Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      clone() {
        return new Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    function fetch(url, opts) {
      if (!fetch.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch.Promise;
      return new fetch.Promise(function(resolve, reject) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            request.body.destroy(error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          finalize();
        });
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL)) {
                  for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    fetch.isRedirect = function(code2) {
      return code2 === 301 || code2 === 302 || code2 === 303 || code2 === 307 || code2 === 308;
    };
    fetch.Promise = global.Promise;
    module2.exports = exports2 = fetch;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers;
    exports2.Request = Request;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
  }
});

// ../node_modules/yggdrasil/package.json
var require_package = __commonJS({
  "../node_modules/yggdrasil/package.json"(exports2, module2) {
    module2.exports = {
      name: "yggdrasil",
      version: "1.7.0",
      author: "Zeke Sonxx <zeke@zekesonxx.com>",
      description: "Mojang authentication (Yggdrasil) client",
      scripts: {
        test: "mocha -R spec",
        pretest: "npm run lint",
        lint: "standard",
        fix: "standard --fix"
      },
      main: "./src/index.js",
      repository: {
        type: "git",
        url: "https://github.com/PrismarineJS/node-yggdrasil.git"
      },
      bugs: {
        url: "https://github.com/PrismarineJS/node-yggdrasil/issues"
      },
      keywords: [
        "minecraft",
        "yggdrasil",
        "authentication"
      ],
      dependencies: {
        "node-fetch": "^2.6.1",
        uuid: "^8.2.0"
      },
      license: "MIT",
      devDependencies: {
        "@types/node": "^17.0.4",
        "@types/node-fetch": "^3.0.3",
        "@types/uuid": "^8.3.0",
        mocha: "^9.0.0",
        nock: "^13.0.2",
        standard: "^16.0.3"
      }
    };
  }
});

// ../node_modules/yggdrasil/src/utils.js
var require_utils7 = __commonJS({
  "../node_modules/yggdrasil/src/utils.js"(exports2, module2) {
    var nf = require_lib2();
    var { version } = require_package();
    var headers = {
      "User-Agent": `node-yggdrasil/${version}`,
      "Content-Type": "application/json"
    };
    async function call(host, path, data, agent) {
      const resp = await nf(`${host}/${path}`, { agent, body: JSON.stringify(data), headers, method: "POST" });
      let body = await resp.text();
      if (body.length === 0)
        return "";
      try {
        body = JSON.parse(body);
      } catch (e) {
        if (e instanceof SyntaxError) {
          if (resp.status === 403) {
            if (body.includes("Request blocked.")) {
              throw new Error("Request blocked by CloudFlare");
            }
            if (body.includes('cf-error-code">1009')) {
              throw new Error("Your IP is banned by CloudFlare");
            }
          } else {
            throw new Error(`Response is not JSON. Status code: ${resp.status ?? "no status code"}`);
          }
        } else {
          throw e;
        }
      }
      if (body?.error !== void 0)
        throw new Error(body?.errorMessage ?? body?.error);
      return body;
    }
    function mcHexDigest(hash, encoding) {
      if (!(hash instanceof Buffer)) {
        hash = Buffer.from(hash, encoding);
      }
      const negative = hash.readInt8(0) < 0;
      if (negative)
        performTwosCompliment(hash);
      return (negative ? "-" : "") + hash.toString("hex").replace(/^0+/g, "");
    }
    function callbackify(f, maxParams) {
      return function(...args) {
        let cb;
        let i = args.length;
        while (cb === void 0 && i > 0) {
          if (typeof args[i - 1] === "function") {
            cb = args[i - 1];
            args[i - 1] = void 0;
            args[maxParams] = cb;
            break;
          }
          i--;
        }
        return f(...args).then(
          (r) => {
            if (r[0] !== void 0) {
              cb?.(void 0, ...r);
              return r[r.length - 1];
            } else {
              cb?.(void 0, r);
              return r;
            }
          },
          (err) => {
            if (typeof cb === "function")
              cb(err);
            else
              throw err;
          }
        );
      };
    }
    function performTwosCompliment(buffer) {
      let carry = true;
      let i, newByte, value;
      for (i = buffer.length - 1; i >= 0; --i) {
        value = buffer.readUInt8(i);
        newByte = ~value & 255;
        if (carry) {
          carry = newByte === 255;
          buffer.writeUInt8(carry ? 0 : newByte + 1, i);
        } else {
          buffer.writeUInt8(newByte, i);
        }
      }
    }
    module2.exports = {
      call: callbackify(call, 4),
      callbackify,
      mcHexDigest
    };
  }
});

// ../node_modules/yggdrasil/src/Client.js
var require_Client = __commonJS({
  "../node_modules/yggdrasil/src/Client.js"(exports2, module2) {
    var uuid = require_dist();
    var utils2 = require_utils7();
    var defaultHost = "https://authserver.mojang.com";
    function loader(moduleOptions) {
      async function auth(options) {
        if (options.token === null)
          delete options.token;
        else
          options.token = options.token ?? uuid.v4();
        options.agent = options.agent ?? "Minecraft";
        return await utils2.call(
          moduleOptions?.host ?? defaultHost,
          "authenticate",
          {
            agent: {
              name: options.agent,
              version: options.agent === "Minecraft" ? 1 : options.version
            },
            username: options.user,
            password: options.pass,
            clientToken: options.token,
            requestUser: options.requestUser === true
          },
          moduleOptions?.agent
        );
      }
      async function refresh(accessToken, clientToken, requestUser) {
        const data = await utils2.call(
          moduleOptions?.host ?? defaultHost,
          "refresh",
          { accessToken, clientToken, requestUser: requestUser ?? false },
          moduleOptions?.agent
        );
        if (data.clientToken !== clientToken)
          throw new Error("clientToken assertion failed");
        return [data.accessToken, data];
      }
      async function validate(accessToken) {
        return await utils2.call(moduleOptions?.host ?? defaultHost, "validate", { accessToken }, moduleOptions?.agent);
      }
      async function signout(username, password) {
        return await utils2.call(moduleOptions?.host ?? defaultHost, "signout", { username, password }, moduleOptions?.agent);
      }
      async function invalidate(accessToken, clientToken) {
        return await utils2.call(moduleOptions?.host ?? defaultHost, "invalidate", { accessToken, clientToken }, moduleOptions?.agent);
      }
      return {
        auth: utils2.callbackify(auth, 1),
        refresh: utils2.callbackify(refresh, 3),
        signout: utils2.callbackify(signout, 1),
        validate: utils2.callbackify(validate, 2),
        invalidate: utils2.callbackify(invalidate, 2)
      };
    }
    module2.exports = loader;
  }
});

// ../node_modules/yggdrasil/src/Server.js
var require_Server = __commonJS({
  "../node_modules/yggdrasil/src/Server.js"(exports2, module2) {
    var { createHash } = require("crypto");
    var utils2 = require_utils7();
    var nf = require_lib2();
    var defaultHost = "https://sessionserver.mojang.com";
    function loader(moduleOptions) {
      async function join(accessToken, selectedProfile, serverid, sharedsecret, serverkey) {
        return await utils2.call(
          moduleOptions?.host ?? defaultHost,
          "session/minecraft/join",
          {
            accessToken,
            selectedProfile,
            serverId: utils2.mcHexDigest(createHash("sha1").update(serverid).update(sharedsecret).update(serverkey).digest())
          },
          moduleOptions?.agent
        );
      }
      async function hasJoined(username, serverid, sharedsecret, serverkey) {
        const host = moduleOptions?.host ?? defaultHost;
        const hash = utils2.mcHexDigest(createHash("sha1").update(serverid).update(sharedsecret).update(serverkey).digest());
        const data = await nf(`${host}/session/minecraft/hasJoined?username=${encodeURIComponent(username)}&serverId=${hash}`, { agent: moduleOptions?.agent, method: "GET" });
        const body = JSON.parse(await data.text());
        if (body.id !== void 0)
          return body;
        else
          throw new Error("Failed to verify username!");
      }
      return {
        join: utils2.callbackify(join, 5),
        hasJoined: utils2.callbackify(hasJoined, 4)
      };
    }
    module2.exports = loader;
  }
});

// ../node_modules/yggdrasil/src/index.js
var require_src3 = __commonJS({
  "../node_modules/yggdrasil/src/index.js"(exports2, module2) {
    var Client = require_Client();
    Client.server = require_Server();
    module2.exports = Client;
  }
});

// ../node_modules/minecraft-protocol/src/transforms/binaryStream.js
var require_binaryStream = __commonJS({
  "../node_modules/minecraft-protocol/src/transforms/binaryStream.js"(exports2, module2) {
    var types = {};
    Object.assign(types, require_protodef2().types);
    Object.assign(types, require_minecraft());
    function concat(...args) {
      let allocLen = 0;
      for (let i = 0; i < args.length; i += 2) {
        const type = args[i];
        const value = args[i + 1];
        const [, , s] = types[type];
        allocLen += typeof s === "number" ? s : s(value, {});
      }
      const buffer = Buffer.alloc(allocLen);
      let offset = 0;
      for (let i = 0; i < args.length; i += 2) {
        const type = args[i];
        const value = args[i + 1];
        offset = types[type][1](value, buffer, offset, {});
      }
      return buffer;
    }
    module2.exports = { concat };
  }
});

// ../node_modules/minecraft-protocol/src/client/encrypt.js
var require_encrypt = __commonJS({
  "../node_modules/minecraft-protocol/src/client/encrypt.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    var debug = require_src()("minecraft-protocol");
    var yggdrasil = require_src3();
    var { concat } = require_binaryStream();
    module2.exports = function(client, options) {
      const yggdrasilServer = yggdrasil.server({ agent: options.agent, host: options.sessionServer || "https://sessionserver.mojang.com" });
      client.once("encryption_begin", onEncryptionKeyRequest);
      function onEncryptionKeyRequest(packet) {
        crypto.randomBytes(16, gotSharedSecret);
        function gotSharedSecret(err, sharedSecret) {
          if (err) {
            debug(err);
            client.emit("error", err);
            client.end("encryptionSecretError");
            return;
          }
          if (options.haveCredentials) {
            joinServerRequest(onJoinServerResponse);
          } else {
            if (packet.serverId !== "-") {
              debug("This server appears to be an online server and you are providing no password, the authentication will probably fail");
            }
            sendEncryptionKeyResponse();
          }
          function onJoinServerResponse(err2) {
            if (err2) {
              client.emit("error", err2);
              client.end("encryptionLoginError");
            } else {
              sendEncryptionKeyResponse();
            }
          }
          function joinServerRequest(cb) {
            yggdrasilServer.join(
              options.accessToken,
              client.session.selectedProfile.id,
              packet.serverId,
              sharedSecret,
              packet.publicKey,
              cb
            );
          }
          function sendEncryptionKeyResponse() {
            const mcData = require_minecraft_data()(client.version);
            const pubKey = mcPubKeyToPem(packet.publicKey);
            const encryptedSharedSecretBuffer = crypto.publicEncrypt({ key: pubKey, padding: crypto.constants.RSA_PKCS1_PADDING }, sharedSecret);
            const encryptedVerifyTokenBuffer = crypto.publicEncrypt({ key: pubKey, padding: crypto.constants.RSA_PKCS1_PADDING }, packet.verifyToken);
            if (mcData.supportFeature("signatureEncryption")) {
              const salt = BigInt(Date.now());
              client.write("encryption_begin", {
                sharedSecret: encryptedSharedSecretBuffer,
                hasVerifyToken: client.profileKeys == null,
                crypto: client.profileKeys ? {
                  salt,
                  messageSignature: crypto.sign(
                    "sha256WithRSAEncryption",
                    concat("buffer", packet.verifyToken, "i64", salt),
                    client.profileKeys.private
                  )
                } : {
                  verifyToken: encryptedVerifyTokenBuffer
                }
              });
            } else {
              client.write("encryption_begin", {
                sharedSecret: encryptedSharedSecretBuffer,
                verifyToken: encryptedVerifyTokenBuffer
              });
            }
            client.setEncryption(sharedSecret);
          }
        }
      }
    };
    function mcPubKeyToPem(mcPubKeyBuffer) {
      let pem = "-----BEGIN PUBLIC KEY-----\n";
      let base64PubKey = mcPubKeyBuffer.toString("base64");
      const maxLineLength = 65;
      while (base64PubKey.length > 0) {
        pem += base64PubKey.substring(0, maxLineLength) + "\n";
        base64PubKey = base64PubKey.substring(maxLineLength);
      }
      pem += "-----END PUBLIC KEY-----\n";
      return pem;
    }
  }
});

// ../node_modules/minecraft-protocol/src/client/keepalive.js
var require_keepalive = __commonJS({
  "../node_modules/minecraft-protocol/src/client/keepalive.js"(exports2, module2) {
    "use strict";
    module2.exports = function(client, options) {
      const keepAlive = options.keepAlive == null ? true : options.keepAlive;
      if (!keepAlive)
        return;
      const checkTimeoutInterval = options.checkTimeoutInterval || 30 * 1e3;
      client.on("keep_alive", onKeepAlive);
      let timeout = null;
      client.on("end", () => clearTimeout(timeout));
      function onKeepAlive(packet) {
        if (timeout) {
          clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
          client.emit("error", new Error(`client timed out after ${checkTimeoutInterval} milliseconds`));
          client.end("keepAliveError");
        }, checkTimeoutInterval);
        client.write("keep_alive", {
          keepAliveId: packet.keepAliveId
        });
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/client/compress.js
var require_compress = __commonJS({
  "../node_modules/minecraft-protocol/src/client/compress.js"(exports2, module2) {
    module2.exports = function(client, options) {
      client.once("compress", onCompressionRequest);
      client.on("set_compression", onCompressionRequest);
      function onCompressionRequest(packet) {
        client.compressionThreshold = packet.threshold;
      }
    };
  }
});

// ../node_modules/minecraft-folder-path/index.js
var require_minecraft_folder_path = __commonJS({
  "../node_modules/minecraft-folder-path/index.js"(exports2, module2) {
    var path = require("path");
    var os = require("os");
    var folder = "";
    switch (os.type()) {
      case "Darwin":
        folder = path.join(
          os.homedir(),
          "/Library",
          "Application Support",
          "minecraft"
        );
        break;
      case "win32":
      case "Windows_NT":
        folder = path.join(
          process.env.APPDATA || path.join(os.homedir(), "AppData", "Roaming"),
          ".minecraft"
        );
        break;
      default:
        folder = path.join(os.homedir(), ".minecraft");
        break;
    }
    module2.exports = folder;
  }
});

// ../node_modules/minecraft-protocol/src/client/mojangAuth.js
var require_mojangAuth = __commonJS({
  "../node_modules/minecraft-protocol/src/client/mojangAuth.js"(exports2, module2) {
    var UUID = require_uuid_1345();
    var yggdrasil = require_src3();
    var fs = require("fs").promises;
    var mcDefaultFolderPath = require_minecraft_folder_path();
    var path = require("path");
    var launcherDataFile = "launcher_accounts.json";
    module2.exports = async function(client, options) {
      if (!options.profilesFolder && options.profilesFolder !== false) {
        let mcFolderExists = true;
        try {
          await fs.access(mcDefaultFolderPath);
        } catch (ignoreErr) {
          mcFolderExists = false;
        }
        options.profilesFolder = mcFolderExists ? mcDefaultFolderPath : ".";
      }
      const yggdrasilClient = yggdrasil({ agent: options.agent, host: options.authServer || "https://authserver.mojang.com" });
      const clientToken = options.clientToken || options.session && options.session.clientToken || options.profilesFolder && (await getLauncherProfiles()).mojangClientToken || UUID.v4().toString().replace(/-/g, "");
      const skipValidation = options.skipValidation;
      options.accessToken = null;
      options.haveCredentials = !!options.password || clientToken != null && options.session != null || options.profilesFolder && !!getProfileId(await getLauncherProfiles());
      async function getLauncherProfiles() {
        try {
          return JSON.parse(await fs.readFile(path.join(options.profilesFolder, launcherDataFile), "utf8"));
        } catch (err) {
          await fs.mkdir(options.profilesFolder, { recursive: true });
          await fs.writeFile(path.join(options.profilesFolder, launcherDataFile), "{}");
          return { accounts: {} };
        }
      }
      function getProfileId(auths) {
        try {
          const lowerUsername = options.username.toLowerCase();
          return Object.keys(auths.accounts).find(
            (key) => auths.accounts[key].username.toLowerCase() === lowerUsername || auths.accounts[key].minecraftProfile.name.toLowerCase() === lowerUsername
          );
        } catch (err) {
          return false;
        }
      }
      if (options.haveCredentials) {
        const cb = function(err, session) {
          if (options.profilesFolder) {
            getLauncherProfiles().then((auths) => {
              if (!auths.accounts)
                auths.accounts = [];
              try {
                let profile = getProfileId(auths);
                if (err) {
                  if (profile && auths.accounts[profile].type !== "Xbox") {
                    delete auths.accounts[profile];
                  }
                } else {
                  if (!profile) {
                    profile = UUID.v4().toString().replace(/-/g, "");
                    throw new Error("Account not found");
                  }
                  if (!auths.accounts[profile].remoteId) {
                    delete auths.accounts[profile];
                    throw new Error("Account has no remoteId");
                  }
                  if (!auths.mojangClientToken) {
                    auths.mojangClientToken = clientToken;
                  }
                  if (clientToken === auths.mojangClientToken) {
                    const oldProfileObj = auths.accounts[profile];
                    const newProfileObj = {
                      accessToken: session.accessToken,
                      minecraftProfile: {
                        id: session.selectedProfile.id,
                        name: session.selectedProfile.name
                      },
                      userProperites: oldProfileObj?.userProperites ?? [],
                      remoteId: oldProfileObj?.remoteId ?? "",
                      username: options.username,
                      localId: profile,
                      type: options.auth?.toLowerCase() === "mojang" ? "Mojang" : "Xbox",
                      persistent: true
                    };
                    auths.accounts[profile] = newProfileObj;
                  }
                }
              } catch (ignoreErr) {
              }
              fs.writeFile(path.join(options.profilesFolder, launcherDataFile), JSON.stringify(auths, null, 2)).then(() => {
              }, (ignoreErr) => {
              });
            }, (ignoreErr) => {
            });
          }
          if (err) {
            client.emit("error", err);
          } else {
            client.session = session;
            client.username = session.selectedProfile.name;
            options.accessToken = session.accessToken;
            client.emit("session", session);
            options.connect(client);
          }
        };
        if (!options.session && options.profilesFolder) {
          try {
            const auths = await getLauncherProfiles();
            const profile = getProfileId(auths);
            if (profile) {
              const newUsername = auths.accounts[profile].username;
              const displayName = auths.accounts[profile].minecraftProfile.name;
              const uuid = auths.accounts[profile].minecraftProfile.id;
              const newProfile = {
                id: uuid,
                name: displayName
              };
              options.session = {
                accessToken: auths.accounts[profile].accessToken,
                clientToken: auths.mojangClientToken,
                selectedProfile: newProfile,
                availableProfiles: [newProfile]
              };
              options.username = newUsername;
            }
          } catch (ignoreErr) {
          }
        }
        if (options.session) {
          if (!skipValidation) {
            yggdrasilClient.validate(options.session.accessToken, function(err) {
              if (!err) {
                cb(null, options.session);
              } else {
                yggdrasilClient.refresh(options.session.accessToken, options.session.clientToken, function(err2, accessToken, data) {
                  if (!err2) {
                    cb(null, data);
                  } else if (options.username && options.password) {
                    yggdrasilClient.auth({
                      user: options.username,
                      pass: options.password,
                      token: clientToken,
                      requestUser: true
                    }, cb);
                  } else {
                    cb(err2, data);
                  }
                });
              }
            });
          } else {
            cb(null, options.session);
          }
        } else {
          yggdrasilClient.auth({
            user: options.username,
            pass: options.password,
            token: clientToken
          }, cb);
        }
      } else {
        client.username = options.username;
        options.connect(client);
      }
    };
  }
});

// ../node_modules/prismarine-auth/src/common/Util.js
var require_Util = __commonJS({
  "../node_modules/prismarine-auth/src/common/Util.js"(exports2, module2) {
    var debug = require_src()("prismarine-auth");
    var crypto = require("crypto");
    async function checkStatus(res) {
      if (res.ok) {
        return res.json();
      } else {
        const resp = await res.text();
        debug("Request fail", resp);
        throw Error(`${res.status} ${res.statusText} ${resp}`);
      }
    }
    function createHash(input) {
      return crypto.createHash("sha1").update(input ?? "", "binary").digest("hex").substr(0, 6);
    }
    module2.exports = { checkStatus, createHash };
  }
});

// ../node_modules/prismarine-auth/src/common/Constants.js
var require_Constants = __commonJS({
  "../node_modules/prismarine-auth/src/common/Constants.js"(exports2, module2) {
    module2.exports = {
      Endpoints: {
        PCXSTSRelyingParty: "rp://api.minecraftservices.com/",
        BedrockXSTSRelyingParty: "https://multiplayer.minecraft.net/",
        XboxAuthRelyingParty: "http://auth.xboxlive.com/",
        XboxRelyingParty: "http://xboxlive.com",
        BedrockAuth: "https://multiplayer.minecraft.net/authentication",
        XboxDeviceAuth: "https://device.auth.xboxlive.com/device/authenticate",
        XboxTitleAuth: "https://title.auth.xboxlive.com/title/authenticate",
        XboxUserAuth: "https://user.auth.xboxlive.com/user/authenticate",
        SisuAuthorize: "https://sisu.xboxlive.com/authorize",
        XstsAuthorize: "https://xsts.auth.xboxlive.com/xsts/authorize",
        MinecraftServicesLogWithXbox: "https://api.minecraftservices.com/authentication/login_with_xbox",
        MinecraftServicesCertificate: "https://api.minecraftservices.com/player/certificates",
        MinecraftServicesEntitlement: "https://api.minecraftservices.com/entitlements/mcstore",
        MinecraftServicesProfile: "https://api.minecraftservices.com/minecraft/profile",
        LiveDeviceCodeRequest: "https://login.live.com/oauth20_connect.srf",
        LiveTokenRequest: "https://login.live.com/oauth20_token.srf"
      },
      msalConfig: {
        auth: {
          clientId: "389b1b32-b5d5-43b2-bddc-84ce938d6737",
          authority: "https://login.microsoftonline.com/consumers"
        }
      },
      fetchOptions: {
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "MinecraftLauncher/2.2.10675"
        }
      },
      xboxLiveErrors: {
        2148916227: "Your account was banned by Xbox for violating one or more Community Standards for Xbox and is unable to be used.",
        2148916229: "Your account is currently restricted and your guardian has not given you permission to play online. Login to https://account.microsoft.com/family/ and have your guardian change your permissions.",
        2148916233: "Your account currently does not have an Xbox profile. Please create one at https://signup.live.com/signup",
        2148916234: "Your account has not accepted Xbox's Terms of Service. Please login and accept them.",
        2148916235: "Your account resides in a region that Xbox has not authorized use from. Xbox has blocked your attempt at logging in.",
        2148916236: "Your account requires proof of age. Please login to https://login.live.com/login.srf and provide proof of age.",
        2148916237: "Your account has reached the its limit for playtime. Your account has been blocked from logging in.",
        2148916238: "The account date of birth is under 18 years and cannot proceed unless the account is added to a family by an adult."
      }
    };
  }
});

// ../node_modules/prismarine-auth/src/common/cache/FileCache.js
var require_FileCache = __commonJS({
  "../node_modules/prismarine-auth/src/common/cache/FileCache.js"(exports2, module2) {
    var fs = require("fs");
    var FileCache = class {
      constructor(cacheLocation) {
        this.cacheLocation = cacheLocation;
      }
      async loadInitialValue() {
        try {
          return JSON.parse(fs.readFileSync(this.cacheLocation, "utf8"));
        } catch (e) {
          const cached = {};
          fs.writeFileSync(this.cacheLocation, JSON.stringify(cached));
          return cached;
        }
      }
      async getCached() {
        if (this.cache === void 0) {
          this.cache = await this.loadInitialValue();
        }
        return this.cache;
      }
      async setCached(cached) {
        this.cache = cached;
        fs.writeFileSync(this.cacheLocation, JSON.stringify(this.cache));
      }
      async setCachedPartial(cached) {
        await this.setCached({
          ...this.cache,
          ...cached
        });
      }
    };
    module2.exports = FileCache;
  }
});

// ../node_modules/prismarine-auth/src/TokenManagers/LiveTokenManager.js
var require_LiveTokenManager = __commonJS({
  "../node_modules/prismarine-auth/src/TokenManagers/LiveTokenManager.js"(exports2, module2) {
    var debug = require_src()("prismarine-auth");
    var fetch = require_lib2();
    var { Endpoints } = require_Constants();
    var { checkStatus } = require_Util();
    var LiveTokenManager = class {
      constructor(clientId, scopes, cache) {
        this.clientId = clientId;
        this.scopes = scopes;
        this.cache = cache;
      }
      async verifyTokens() {
        if (this.forceRefresh)
          try {
            await this.refreshTokens();
          } catch {
          }
        const at = await this.getAccessToken();
        const rt = await this.getRefreshToken();
        if (!at || !rt) {
          return false;
        }
        debug("[live] have at, rt", at, rt);
        if (at.valid && rt) {
          return true;
        } else {
          try {
            await this.refreshTokens();
            return true;
          } catch (e) {
            console.warn("Error refreshing token", e);
            return false;
          }
        }
      }
      async refreshTokens() {
        const rtoken = await this.getRefreshToken();
        if (!rtoken) {
          throw new Error("Cannot refresh without refresh token");
        }
        const codeRequest = {
          method: "post",
          body: new URLSearchParams({ scope: this.scopes, client_id: this.clientId, grant_type: "refresh_token", refresh_token: rtoken.token }).toString(),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          credentials: "include"
        };
        const token = await fetch(Endpoints.LiveTokenRequest, codeRequest).then(checkStatus);
        this.updateCache(token);
        return token;
      }
      async getAccessToken() {
        const { token } = await this.cache.getCached();
        if (!token)
          return;
        const until = new Date(token.obtainedOn + token.expires_in) - Date.now();
        const valid = until > 1e3;
        return { valid, until, token: token.access_token };
      }
      async getRefreshToken() {
        const { token } = await this.cache.getCached();
        if (!token)
          return;
        const until = new Date(token.obtainedOn + token.expires_in) - Date.now();
        const valid = until > 1e3;
        return { valid, until, token: token.refresh_token };
      }
      async updateCache(data) {
        await this.cache.setCachedPartial({
          token: {
            ...data,
            obtainedOn: Date.now()
          }
        });
      }
      async authDeviceCode(deviceCodeCallback) {
        const acquireTime = Date.now();
        const codeRequest = {
          method: "post",
          body: new URLSearchParams({ scope: this.scopes, client_id: this.clientId, response_type: "device_code" }).toString(),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          credentials: "include"
        };
        debug("Requesting live device token", codeRequest);
        const cookies = [];
        const res = await fetch(Endpoints.LiveDeviceCodeRequest, codeRequest).then((res2) => {
          if (res2.status !== 200) {
            res2.text().then(console.warn);
            throw Error("Failed to request live.com device code");
          }
          for (const cookie of Object.values(res2.headers.raw()["set-cookie"])) {
            const [keyval] = cookie.split(";");
            cookies.push(keyval);
          }
          return res2;
        }).then(checkStatus).then((resp) => {
          resp.message = `To sign in, use a web browser to open the page ${resp.verification_uri} and enter the code ${resp.user_code} to authenticate.`;
          deviceCodeCallback(resp);
          return resp;
        });
        const expireTime = acquireTime + res.expires_in * 1e3 - 100;
        this.polling = true;
        while (this.polling && expireTime > Date.now()) {
          await new Promise((resolve) => setTimeout(resolve, res.interval * 1e3));
          try {
            const verifi = {
              method: "post",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                Cookie: cookies.join("; ")
              },
              body: new URLSearchParams({
                client_id: this.clientId,
                device_code: res.device_code,
                grant_type: "urn:ietf:params:oauth:grant-type:device_code"
              }).toString()
            };
            const token = await fetch(Endpoints.LiveTokenRequest + "?client_id=" + this.clientId, verifi).then((res2) => res2.json()).then((res2) => {
              if (res2.error) {
                if (res2.error === "authorization_pending") {
                  debug("[live] Still waiting:", res2.error_description);
                } else {
                  throw Error(`Failed to acquire authorization code from device token (${res2.error}) - ${res2.error_description}`);
                }
              } else {
                return res2;
              }
            });
            if (!token)
              continue;
            this.updateCache(token);
            this.polling = false;
            return { accessToken: token.access_token };
          } catch (e) {
            console.debug(e);
          }
        }
        this.polling = false;
        throw Error("Authentication failed, timed out");
      }
    };
    module2.exports = LiveTokenManager;
  }
});

// ../node_modules/prismarine-auth/src/TokenManagers/MinecraftJavaTokenManager.js
var require_MinecraftJavaTokenManager = __commonJS({
  "../node_modules/prismarine-auth/src/TokenManagers/MinecraftJavaTokenManager.js"(exports2, module2) {
    var debug = require_src()("prismarine-auth");
    var fetch = require_lib2();
    var crypto = require("crypto");
    var { Endpoints, fetchOptions } = require_Constants();
    var { checkStatus } = require_Util();
    var toDER = (pem) => pem.split("\n").slice(1, -1).reduce((acc, cur) => Buffer.concat([acc, Buffer.from(cur, "base64")]), Buffer.alloc(0));
    var MinecraftJavaTokenManager = class {
      constructor(cache) {
        this.cache = cache;
      }
      async getCachedAccessToken() {
        const { mca: token } = await this.cache.getCached();
        debug("[mc] token cache", token);
        if (!token)
          return;
        const expires = token.obtainedOn + token.expires_in * 1e3;
        const remaining = expires - Date.now();
        const valid = remaining > 1e3;
        return { valid, until: expires, token: token.access_token, data: token };
      }
      async setCachedAccessToken(data) {
        await this.cache.setCachedPartial({
          mca: {
            ...data,
            obtainedOn: Date.now()
          }
        });
      }
      async verifyTokens() {
        const at = await this.getCachedAccessToken();
        if (!at || this.forceRefresh) {
          return false;
        }
        debug("[mc] have user access token", at);
        if (at.valid) {
          return true;
        }
        return false;
      }
      async getAccessToken(xsts) {
        debug("[mc] authing to minecraft", xsts);
        const MineServicesResponse = await fetch(Endpoints.MinecraftServicesLogWithXbox, {
          method: "post",
          ...fetchOptions,
          body: JSON.stringify({ identityToken: `XBL3.0 x=${xsts.userHash};${xsts.XSTSToken}` })
        }).then(checkStatus);
        debug("[mc] mc auth response", MineServicesResponse);
        await this.setCachedAccessToken(MineServicesResponse);
        return MineServicesResponse.access_token;
      }
      async fetchProfile(accessToken) {
        debug(`[mc] fetching minecraft profile with ${accessToken.slice(0, 16)}`);
        const headers = { ...fetchOptions.headers, Authorization: `Bearer ${accessToken}` };
        const profile = await fetch(Endpoints.MinecraftServicesProfile, { headers }).then(checkStatus);
        debug(`[mc] got profile response: ${profile}`);
        return profile;
      }
      async fetchEntitlements(accessToken) {
        debug(`[mc] fetching entitlements with ${accessToken.slice(0, 16)}`);
        const headers = { ...fetchOptions.headers, Authorization: `Bearer ${accessToken}` };
        const entitlements = await fetch(Endpoints.MinecraftServicesEntitlement, { headers }).then(checkStatus);
        debug(`[mc] got entitlement response: ${entitlements}`);
        return entitlements;
      }
      async fetchCertificates(accessToken) {
        debug(`[mc] fetching key-pair with ${accessToken.slice(0, 16)}`);
        const headers = { ...fetchOptions.headers, Authorization: `Bearer ${accessToken}` };
        const cert = await fetch(Endpoints.MinecraftServicesCertificate, { method: "post", headers }).then(checkStatus);
        debug("[mc] got key-pair");
        const profileKeys = {
          publicPEM: cert.keyPair.publicKey,
          privatePEM: cert.keyPair.privateKey,
          publicDER: toDER(cert.keyPair.publicKey),
          privateDER: toDER(cert.keyPair.privateKey),
          signature: Buffer.from(cert.publicKeySignature, "base64"),
          expiresOn: new Date(cert.expiresAt),
          refreshAfter: new Date(cert.refreshedAfter)
        };
        profileKeys.public = crypto.createPublicKey({ key: profileKeys.publicDER, format: "der", type: "spki" });
        profileKeys.private = crypto.createPrivateKey({ key: profileKeys.privateDER, format: "der", type: "pkcs8" });
        return { profileKeys };
      }
    };
    module2.exports = MinecraftJavaTokenManager;
  }
});

// ../node_modules/@xboxreplay/errors/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/@xboxreplay/errors/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var defaultMessage = "Something went wrong...";
    var defaultDetails = {
      statusCode: 500,
      reason: "INTERNAL_SERVER_ERROR"
    };
    var XboxReplayError = class extends Error {
      constructor(message = defaultMessage, details = {}) {
        super(message);
        this.__XboxReplay__ = true;
        this.details = Object.assign({}, defaultDetails);
        Error.captureStackTrace(this, XboxReplayError);
        this.name = "XboxReplayError";
        this.details = Object.assign({}, this.details, details);
      }
    };
    XboxReplayError.details = Object.assign({}, defaultDetails);
    exports2.XboxReplayError = XboxReplayError;
    exports2.default = {
      badRequest: (message = "Bad request", reason = "BAD_REQUEST") => new XboxReplayError(message, {
        statusCode: 400,
        reason
      }),
      unauthorized: (message = "Unauthorized", reason = "UNAUTHORIZED") => new XboxReplayError(message, {
        statusCode: 401,
        reason
      }),
      forbidden: (message = "Forbidden", reason = "FORBIDDEN") => new XboxReplayError(message, {
        statusCode: 403,
        reason
      }),
      internal: (message = defaultMessage, reason = defaultDetails.reason) => new XboxReplayError(message, {
        statusCode: 500,
        reason
      }),
      build: (message = "", details = Object.assign({}, XboxReplayError.details)) => {
        if (typeof details === "string") {
          details = {
            reason: details,
            statusCode: defaultDetails.statusCode
          };
        }
        return new XboxReplayError(message, details);
      }
    };
  }
});

// ../node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "../node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// ../node_modules/axios/lib/utils.js
var require_utils8 = __commonJS({
  "../node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// ../node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "../node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils2.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils2.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils2.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils2.forEach(val, function parseValue(v) {
            if (utils2.isDate(v)) {
              v = v.toISOString();
            } else if (utils2.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// ../node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "../node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils2.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// ../node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "../node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils2.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// ../node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "../node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code2, request, response) {
      error.config = config;
      if (code2) {
        error.code = code2;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
  }
});

// ../node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "../node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code2, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code2, request, response);
    };
  }
});

// ../node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "../node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// ../node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "../node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    module2.exports = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// ../node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "../node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// ../node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "../node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// ../node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "../node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// ../node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "../node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils2.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils2.trim(line.substr(0, i)).toLowerCase();
        val = utils2.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// ../node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "../node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    module2.exports = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// ../node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "../node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        if (utils2.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve, reject, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils2.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils2.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// ../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol2 = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol2];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol2));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol2.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : this._currentUrl = this._options.path;
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError(cause));
        return;
      }
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (typeof beforeRedirect === "function") {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError(cause));
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol2 = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol2] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL2(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol: protocol2 };
          }
          if (typeof options === "function") {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          assert.equal(options.protocol, protocol2, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code2, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code2 + "]";
      CustomError.prototype.code = code2;
      return CustomError;
    }
    function abortRequest(request) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.abort();
    }
    function isSubdomain(subdomain, domain) {
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// ../node_modules/axios/package.json
var require_package2 = __commonJS({
  "../node_modules/axios/package.json"(exports2, module2) {
    module2.exports = {
      name: "axios",
      version: "0.21.4",
      description: "Promise based HTTP client for the browser and node.js",
      main: "index.js",
      scripts: {
        test: "grunt test",
        start: "node ./sandbox/server.js",
        build: "NODE_ENV=production grunt build",
        preversion: "npm test",
        version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
        postversion: "git push && git push --tags",
        examples: "node ./examples/server.js",
        coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
        fix: "eslint --fix lib/**/*.js"
      },
      repository: {
        type: "git",
        url: "https://github.com/axios/axios.git"
      },
      keywords: [
        "xhr",
        "http",
        "ajax",
        "promise",
        "node"
      ],
      author: "Matt Zabriskie",
      license: "MIT",
      bugs: {
        url: "https://github.com/axios/axios/issues"
      },
      homepage: "https://axios-http.com",
      devDependencies: {
        coveralls: "^3.0.0",
        "es6-promise": "^4.2.4",
        grunt: "^1.3.0",
        "grunt-banner": "^0.6.0",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-clean": "^1.1.0",
        "grunt-contrib-watch": "^1.0.0",
        "grunt-eslint": "^23.0.0",
        "grunt-karma": "^4.0.0",
        "grunt-mocha-test": "^0.13.3",
        "grunt-ts": "^6.0.0-beta.19",
        "grunt-webpack": "^4.0.2",
        "istanbul-instrumenter-loader": "^1.0.0",
        "jasmine-core": "^2.4.1",
        karma: "^6.3.2",
        "karma-chrome-launcher": "^3.1.0",
        "karma-firefox-launcher": "^2.1.0",
        "karma-jasmine": "^1.1.1",
        "karma-jasmine-ajax": "^0.1.13",
        "karma-safari-launcher": "^1.0.0",
        "karma-sauce-launcher": "^4.3.6",
        "karma-sinon": "^1.0.5",
        "karma-sourcemap-loader": "^0.3.8",
        "karma-webpack": "^4.0.2",
        "load-grunt-tasks": "^3.5.2",
        minimist: "^1.2.0",
        mocha: "^8.2.1",
        sinon: "^4.5.0",
        "terser-webpack-plugin": "^4.2.3",
        typescript: "^4.0.5",
        "url-search-params": "^0.10.0",
        webpack: "^4.44.2",
        "webpack-dev-server": "^3.11.0"
      },
      browser: {
        "./lib/adapters/http.js": "./lib/adapters/xhr.js"
      },
      jsdelivr: "dist/axios.min.js",
      unpkg: "dist/axios.min.js",
      typings: "./index.d.ts",
      dependencies: {
        "follow-redirects": "^1.14.0"
      },
      bundlesize: [
        {
          path: "./dist/axios.min.js",
          threshold: "5kB"
        }
      ]
    };
  }
});

// ../node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "../node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var pkg = require_package2();
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var resolve = function resolve2(value) {
          resolvePromise(value);
        };
        var reject = function reject2(value) {
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        if ("User-Agent" in headers || "user-agent" in headers) {
          if (!headers["User-Agent"] && !headers["user-agent"]) {
            delete headers["User-Agent"];
            delete headers["user-agent"];
          }
        } else {
          headers["User-Agent"] = "axios/" + pkg.version;
        }
        if (data && !utils2.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils2.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils2.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              config
            ));
          }
          headers["Content-Length"] = data.length;
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol2 = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth) {
          delete headers.Authorization;
        }
        var isHttpsRequest = isHttps.test(protocol2);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol2.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol2 + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                stream.destroy();
                reject(createError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  config,
                  null,
                  lastRequest
                ));
              }
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              var responseData = Buffer.concat(responseBuffer);
              if (config.responseType !== "arraybuffer") {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === "utf8") {
                  responseData = utils2.stripBOM(responseData);
                }
              }
              response.data = responseData;
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config, null, req));
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError(
              "error trying to parse `config.timeout` to int",
              config,
              "ERR_PARSE_TIMEOUT",
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            reject(createError(
              "timeout of " + timeout + "ms exceeded",
              config,
              config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              req
            ));
          });
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(cancel);
          });
        }
        if (utils2.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// ../node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "../node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils2.isUndefined(headers) && utils2.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils2.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils2.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils2.isFormData(data) || utils2.isArrayBuffer(data) || utils2.isBuffer(data) || utils2.isStream(data) || utils2.isFile(data) || utils2.isBlob(data)) {
          return data;
        }
        if (utils2.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils2.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils2.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils2.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils2.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils2.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// ../node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "../node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils2.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// ../node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "../node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// ../node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "../node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils2.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils2.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// ../node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "../node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils2.isPlainObject(target) && utils2.isPlainObject(source)) {
          return utils2.merge(target, source);
        } else if (utils2.isPlainObject(source)) {
          return utils2.merge({}, source);
        } else if (utils2.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils2.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils2.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils2.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils2.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils2.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
  }
});

// ../node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "../node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var pkg = require_package2();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split(".");
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
      var destVer = version.split(".");
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }
    validators.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);
      function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed in " + version));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      isOlderVersion,
      assertOptions,
      validators
    };
  }
});

// ../node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "../node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// ../node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "../node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// ../node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "../node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// ../node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "../node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// ../node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "../node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// ../node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "../node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils2 = require_utils8();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils2.extend(instance, Axios.prototype, context);
      utils2.extend(instance, context);
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// ../node_modules/axios/index.js
var require_axios2 = __commonJS({
  "../node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// ../node_modules/@xboxreplay/xboxlive-auth/dist/core/live/config.js
var require_config = __commonJS({
  "../node_modules/@xboxreplay/xboxlive-auth/dist/core/live/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CLIENT_IDS = {
      MY_XBOX_LIVE: "0000000048093EE3",
      XBOX_APP: "000000004C12AE6F"
    };
    exports2.default = {
      uris: {
        authorize: "https://login.live.com/oauth20_authorize.srf"
      },
      queries: {
        authorize: {
          client_id: CLIENT_IDS.XBOX_APP,
          redirect_uri: "https://login.live.com/oauth20_desktop.srf",
          scope: "service::user.auth.xboxlive.com::MBI_SSL",
          display: "touch",
          response_type: "token",
          locale: "en"
        }
      }
    };
  }
});

// ../node_modules/@xboxreplay/xboxlive-auth/dist/config.js
var require_config2 = __commonJS({
  "../node_modules/@xboxreplay/xboxlive-auth/dist/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.USER_AGENT = [
      "Mozilla/5.0 (XboxReplay; XboxLiveAuth/3.0)",
      "AppleWebKit/537.36 (KHTML, like Gecko)",
      "Chrome/71.0.3578.98 Safari/537.36"
    ].join(" ");
    exports2.default = {
      request: {
        baseHeaders: {
          "Accept-encoding": "gzip",
          "Accept-Language": "en-US",
          "User-Agent": exports2.USER_AGENT
        }
      },
      gitHubLinks: {
        createIssue: "https://bit.ly/xr-xbl-auth-create-issue",
        seeUserTokenIssue: "https://bit.ly/xr-xbl-auth-user-token-issue",
        twoFactorAuthenticationError: "https://bit.ly/xr-xbl-auth-err-2fa",
        unauthorizedActivityError: "https://bit.ly/xr-xbl-auth-err-activity"
      }
    };
  }
});

// ../node_modules/@xboxreplay/xboxlive-auth/dist/core/live/index.js
var require_live = __commonJS({
  "../node_modules/@xboxreplay/xboxlive-auth/dist/core/live/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_1 = __importDefault(require_dist2());
    var axios_1 = __importDefault(require_axios2());
    var config_1 = __importDefault(require_config());
    var config_2 = __importDefault(require_config2());
    var querystring_1 = require("querystring");
    var _getMatchForIndex = (entry, regex, index = 0) => {
      const match = entry.match(regex);
      return (match === null || match === void 0 ? void 0 : match[index]) || void 0;
    };
    var _requiresIdentityConfirmation = (body) => {
      const m1 = _getMatchForIndex(body, /id=\"fmHF\" action=\"(.*?)\"/, 1);
      const m2 = _getMatchForIndex(m1 || "", /identity\/confirm/, 0);
      return m2 !== null;
    };
    exports2.preAuth = () => axios_1.default.get(`${config_1.default.uris.authorize}?${querystring_1.stringify(Object.assign({}, config_1.default.queries.authorize))}`, { headers: config_2.default.request.baseHeaders }).then((response) => {
      if (response.status !== 200) {
        throw errors_1.default.internal("Pre-authentication failed.");
      }
      const body = response.data || "";
      const cookie = (response.headers["set-cookie"] || []).map((c) => c.split(";")[0]).join("; ");
      const matches = {
        PPFT: _getMatchForIndex(body, /sFTTag:'.*value=\"(.*)\"\/>'/, 1),
        urlPost: _getMatchForIndex(body, /urlPost:'(.+?(?=\'))/, 1)
      };
      if (matches.PPFT === void 0)
        throw errors_1.default.internal(`Could not match "PPFT" parameter, please fill an issue on ${config_2.default.gitHubLinks.createIssue}`);
      else if (matches.urlPost === void 0)
        throw errors_1.default.internal(`Could not match "urlPost" parameter, please fill an issue on ${config_2.default.gitHubLinks.createIssue}`);
      return {
        cookie,
        matches: {
          PPFT: matches.PPFT,
          urlPost: matches.urlPost
        }
      };
    }).catch((err) => {
      if (!!err.__XboxReplay__)
        throw err;
      else
        throw errors_1.default.internal(err.message);
    });
    exports2.logUser = (preAuthResponse, credentials) => axios_1.default.post(preAuthResponse.matches.urlPost, querystring_1.stringify({
      login: credentials.email,
      loginfmt: credentials.email,
      passwd: credentials.password,
      PPFT: preAuthResponse.matches.PPFT
    }), {
      maxRedirects: 1,
      headers: Object.assign(Object.assign({}, config_2.default.request.baseHeaders), { "Content-Type": "application/x-www-form-urlencoded", Cookie: preAuthResponse.cookie })
    }).then((response) => {
      var _a;
      if (response.status !== 200) {
        throw errors_1.default.internal(`Authentication failed.`);
      }
      const body = response.data || "";
      const { responseUrl = "" } = ((_a = response.request) === null || _a === void 0 ? void 0 : _a.res) || {};
      const hash = responseUrl.split("#")[1];
      if (responseUrl === preAuthResponse.matches.urlPost) {
        throw errors_1.default.unauthorized("Invalid credentials.");
      }
      if (hash === void 0) {
        const errorMessage = _requiresIdentityConfirmation(body) === true ? `Activity confirmation required, please refer to ${config_2.default.gitHubLinks.unauthorizedActivityError}` : `Invalid credentials or 2FA enabled, please refer to ${config_2.default.gitHubLinks.twoFactorAuthenticationError}`;
        throw errors_1.default.unauthorized(errorMessage);
      }
      const parseHash = querystring_1.parse(hash);
      parseHash.expires_in = Number(parseHash.expires_in);
      return parseHash;
    }).catch((err) => {
      if (!!err.__XboxReplay__)
        throw err;
      else
        throw errors_1.default.internal(err.message);
    });
  }
});

// ../node_modules/@xboxreplay/xboxlive-auth/dist/core/xboxlive/config.js
var require_config3 = __commonJS({
  "../node_modules/@xboxreplay/xboxlive-auth/dist/core/xboxlive/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = {
      uris: {
        userAuthenticate: "https://user.auth.xboxlive.com/user/authenticate",
        XSTSAuthorize: "https://xsts.auth.xboxlive.com/xsts/authorize"
      },
      defaultRelyingParty: "http://xboxlive.com"
    };
  }
});

// ../node_modules/@xboxreplay/xboxlive-auth/dist/core/xboxlive/index.js
var require_xboxlive = __commonJS({
  "../node_modules/@xboxreplay/xboxlive-auth/dist/core/xboxlive/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_1 = __importDefault(require_dist2());
    var axios_1 = __importDefault(require_axios2());
    var config_1 = __importDefault(require_config3());
    var config_2 = __importDefault(require_config2());
    exports2.exchangeRpsTicketForUserToken = (RpsTicket) => axios_1.default.post(config_1.default.uris.userAuthenticate, {
      RelyingParty: "http://auth.xboxlive.com",
      TokenType: "JWT",
      Properties: {
        AuthMethod: "RPS",
        SiteName: "user.auth.xboxlive.com",
        RpsTicket
      }
    }, {
      headers: Object.assign(Object.assign({}, config_2.default.request.baseHeaders), { Accept: "application/json", "x-xbl-contract-version": 0 })
    }).then((response) => {
      if (response.status !== 200)
        throw errors_1.default.internal('Could not exchange specified "RpsTicket"');
      else
        return response.data;
    }).catch((err) => {
      if (!!err.__XboxReplay__)
        throw err;
      else
        throw errors_1.default.internal(err.message);
    });
    exports2.exchangeTokensForXSTSIdentity = ({ userToken, deviceToken, titleToken }, { XSTSRelyingParty, optionalDisplayClaims, raw } = {}) => axios_1.default.post(config_1.default.uris.XSTSAuthorize, {
      RelyingParty: XSTSRelyingParty || config_1.default.defaultRelyingParty,
      TokenType: "JWT",
      Properties: {
        UserTokens: [userToken],
        DeviceToken: deviceToken,
        TitleToken: titleToken,
        OptionalDisplayClaims: optionalDisplayClaims,
        SandboxId: "RETAIL"
      }
    }, {
      headers: Object.assign(Object.assign({}, config_2.default.request.baseHeaders), { Accept: "application/json", "x-xbl-contract-version": 1 })
    }).then((response) => {
      if (response.status !== 200) {
        throw errors_1.default.internal('Could not exchange specified "userToken"');
      }
      if (raw !== true) {
        const body = response.data;
        return {
          userXUID: body.DisplayClaims.xui[0].xid || null,
          userHash: body.DisplayClaims.xui[0].uhs,
          XSTSToken: body.Token,
          expiresOn: body.NotAfter
        };
      } else
        return response.data;
    }).catch((err) => {
      var _a;
      if (!!err.__XboxReplay__)
        throw err;
      else if (((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 400) {
        const isDefaultRelyingParty = XSTSRelyingParty === config_1.default.defaultRelyingParty;
        const computedErrorMessage = [
          'Could not exchange "userToken", please',
          `refer to ${config_2.default.gitHubLinks.seeUserTokenIssue}`
        ];
        if (isDefaultRelyingParty === false)
          computedErrorMessage.splice(1, 0, 'double check the specified "XSTSRelyingParty" or');
        throw errors_1.default.internal(computedErrorMessage.join(" "));
      } else
        throw errors_1.default.internal(err.message);
    });
    exports2.exchangeUserTokenForXSTSIdentity = (userToken, options) => exports2.exchangeTokensForXSTSIdentity({ userToken }, options);
  }
});

// ../node_modules/@xboxreplay/xboxlive-auth/dist/index.js
var require_dist3 = __commonJS({
  "../node_modules/@xboxreplay/xboxlive-auth/dist/index.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var live_1 = require_live();
    exports2.preAuth = live_1.preAuth;
    exports2.logUser = live_1.logUser;
    var xboxlive_1 = require_xboxlive();
    exports2.exchangeRpsTicketForUserToken = xboxlive_1.exchangeRpsTicketForUserToken;
    exports2.exchangeUserTokenForXSTSIdentity = xboxlive_1.exchangeUserTokenForXSTSIdentity;
    exports2.exchangeTokensForXSTSIdentity = xboxlive_1.exchangeTokensForXSTSIdentity;
    exports2.authenticate = (email, password, options = {}) => __awaiter(void 0, void 0, void 0, function* () {
      const preAuthResponse = yield live_1.preAuth();
      const logUserResponse = yield live_1.logUser(preAuthResponse, { email, password });
      const exchangeRpsTicketForUserTokenResponse = yield xboxlive_1.exchangeRpsTicketForUserToken(logUserResponse.access_token);
      return xboxlive_1.exchangeUserTokenForXSTSIdentity(exchangeRpsTicketForUserTokenResponse.Token, { XSTSRelyingParty: options.XSTSRelyingParty, raw: false });
    });
  }
});

// ../node_modules/smart-buffer/build/utils.js
var require_utils9 = __commonJS({
  "../node_modules/smart-buffer/build/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports2.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports2.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports2.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports2.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports2.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports2.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports2.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// ../node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "../node_modules/smart-buffer/build/smartbuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils9();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class {
      constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (SmartBuffer.isSmartBufferOptions(options)) {
          if (options.encoding) {
            utils_1.checkEncoding(options.encoding);
            this._encoding = options.encoding;
          }
          if (options.size) {
            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
              this._buff = Buffer.allocUnsafe(options.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options.buff) {
            if (Buffer.isBuffer(options.buff)) {
              this._buff = options.buff;
              this.length = options.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      static fromOptions(options) {
        return new this(options);
      }
      static isSmartBufferOptions(options) {
        const castOptions = options;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      readBufferNT() {
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      remaining() {
        return this.length - this._readOffset;
      }
      get readOffset() {
        return this._readOffset;
      }
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      get writeOffset() {
        return this._writeOffset;
      }
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      get encoding() {
        return this._encoding;
      }
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      get internalBuffer() {
        return this._buff;
      }
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      destroy() {
        this.clear();
        return this;
      }
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports2.SmartBuffer = SmartBuffer;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/digest.js
var require_digest = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var digest = (algorithm, data) => (0, crypto_1.createHash)(algorithm).update(data).digest();
    exports2.default = digest;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/buffer_utils.js
var require_buffer_utils = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/buffer_utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatKdf = exports2.lengthAndInput = exports2.uint32be = exports2.uint64be = exports2.p2s = exports2.concat = exports2.decoder = exports2.encoder = void 0;
    var digest_js_1 = require_digest();
    exports2.encoder = new TextEncoder();
    exports2.decoder = new TextDecoder();
    var MAX_INT32 = 2 ** 32;
    function concat(...buffers) {
      const size = buffers.reduce((acc, { length }) => acc + length, 0);
      const buf = new Uint8Array(size);
      let i = 0;
      buffers.forEach((buffer) => {
        buf.set(buffer, i);
        i += buffer.length;
      });
      return buf;
    }
    exports2.concat = concat;
    function p2s(alg, p2sInput) {
      return concat(exports2.encoder.encode(alg), new Uint8Array([0]), p2sInput);
    }
    exports2.p2s = p2s;
    function writeUInt32BE(buf, value, offset) {
      if (value < 0 || value >= MAX_INT32) {
        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
      }
      buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
    }
    function uint64be(value) {
      const high = Math.floor(value / MAX_INT32);
      const low = value % MAX_INT32;
      const buf = new Uint8Array(8);
      writeUInt32BE(buf, high, 0);
      writeUInt32BE(buf, low, 4);
      return buf;
    }
    exports2.uint64be = uint64be;
    function uint32be(value) {
      const buf = new Uint8Array(4);
      writeUInt32BE(buf, value);
      return buf;
    }
    exports2.uint32be = uint32be;
    function lengthAndInput(input) {
      return concat(uint32be(input.length), input);
    }
    exports2.lengthAndInput = lengthAndInput;
    async function concatKdf(secret, bits, value) {
      const iterations = Math.ceil((bits >> 3) / 32);
      const res = new Uint8Array(iterations * 32);
      for (let iter = 0; iter < iterations; iter++) {
        const buf = new Uint8Array(4 + secret.length + value.length);
        buf.set(uint32be(iter + 1));
        buf.set(secret, 4);
        buf.set(value, 4 + secret.length);
        res.set(await (0, digest_js_1.default)("sha256", buf), iter * 32);
      }
      return res.slice(0, bits >> 3);
    }
    exports2.concatKdf = concatKdf;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/base64url.js
var require_base64url = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/base64url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = exports2.encodeBase64 = exports2.decodeBase64 = void 0;
    var buffer_1 = require("buffer");
    var buffer_utils_js_1 = require_buffer_utils();
    var encode;
    exports2.encode = encode;
    function normalize(input) {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = buffer_utils_js_1.decoder.decode(encoded);
      }
      return encoded;
    }
    if (buffer_1.Buffer.isEncoding("base64url")) {
      exports2.encode = encode = (input) => buffer_1.Buffer.from(input).toString("base64url");
    } else {
      exports2.encode = encode = (input) => buffer_1.Buffer.from(input).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    var decodeBase64 = (input) => buffer_1.Buffer.from(input, "base64");
    exports2.decodeBase64 = decodeBase64;
    var encodeBase64 = (input) => buffer_1.Buffer.from(input).toString("base64");
    exports2.encodeBase64 = encodeBase64;
    var decode = (input) => buffer_1.Buffer.from(normalize(input), "base64");
    exports2.decode = decode;
  }
});

// ../node_modules/jose/dist/node/cjs/util/errors.js
var require_errors3 = __commonJS({
  "../node_modules/jose/dist/node/cjs/util/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JWSSignatureVerificationFailed = exports2.JWKSTimeout = exports2.JWKSMultipleMatchingKeys = exports2.JWKSNoMatchingKey = exports2.JWKSInvalid = exports2.JWKInvalid = exports2.JWTInvalid = exports2.JWSInvalid = exports2.JWEInvalid = exports2.JWEDecryptionFailed = exports2.JOSENotSupported = exports2.JOSEAlgNotAllowed = exports2.JWTExpired = exports2.JWTClaimValidationFailed = exports2.JOSEError = void 0;
    var JOSEError = class extends Error {
      constructor(message) {
        var _a;
        super(message);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
      }
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
    };
    exports2.JOSEError = JOSEError;
    var JWTClaimValidationFailed = class extends JOSEError {
      constructor(message, claim = "unspecified", reason = "unspecified") {
        super(message);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
    };
    exports2.JWTClaimValidationFailed = JWTClaimValidationFailed;
    var JWTExpired = class extends JOSEError {
      constructor(message, claim = "unspecified", reason = "unspecified") {
        super(message);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
    };
    exports2.JWTExpired = JWTExpired;
    var JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    exports2.JOSEAlgNotAllowed = JOSEAlgNotAllowed;
    var JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    exports2.JOSENotSupported = JOSENotSupported;
    var JWEDecryptionFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    exports2.JWEDecryptionFailed = JWEDecryptionFailed;
    var JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    exports2.JWEInvalid = JWEInvalid;
    var JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    exports2.JWSInvalid = JWSInvalid;
    var JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    exports2.JWTInvalid = JWTInvalid;
    var JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    exports2.JWKInvalid = JWKInvalid;
    var JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    exports2.JWKSInvalid = JWKSInvalid;
    var JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    exports2.JWKSNoMatchingKey = JWKSNoMatchingKey;
    var JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    exports2.JWKSMultipleMatchingKeys = JWKSMultipleMatchingKeys;
    var JWKSTimeout = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    exports2.JWKSTimeout = JWKSTimeout;
    var JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
    exports2.JWSSignatureVerificationFailed = JWSSignatureVerificationFailed;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/random.js
var require_random = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/random.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = void 0;
    var crypto_1 = require("crypto");
    Object.defineProperty(exports2, "default", { enumerable: true, get: function() {
      return crypto_1.randomFillSync;
    } });
  }
});

// ../node_modules/jose/dist/node/cjs/lib/iv.js
var require_iv = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/iv.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bitLength = void 0;
    var errors_js_1 = require_errors3();
    var random_js_1 = require_random();
    function bitLength(alg) {
      switch (alg) {
        case "A128GCM":
        case "A128GCMKW":
        case "A192GCM":
        case "A192GCMKW":
        case "A256GCM":
        case "A256GCMKW":
          return 96;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          return 128;
        default:
          throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
      }
    }
    exports2.bitLength = bitLength;
    exports2.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
  }
});

// ../node_modules/jose/dist/node/cjs/lib/check_iv_length.js
var require_check_iv_length = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/check_iv_length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors3();
    var iv_js_1 = require_iv();
    var checkIvLength = (enc, iv) => {
      if (iv.length << 3 !== (0, iv_js_1.bitLength)(enc)) {
        throw new errors_js_1.JWEInvalid("Invalid Initialization Vector length");
      }
    };
    exports2.default = checkIvLength;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/is_key_object.js
var require_is_key_object = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/is_key_object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var util = require("util");
    exports2.default = util.types.isKeyObject ? (obj) => util.types.isKeyObject(obj) : (obj) => obj != null && obj instanceof crypto_1.KeyObject;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/check_cek_length.js
var require_check_cek_length = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/check_cek_length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors3();
    var is_key_object_js_1 = require_is_key_object();
    var checkCekLength = (enc, cek) => {
      let expected;
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          expected = parseInt(enc.slice(-3), 10);
          break;
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          expected = parseInt(enc.slice(1, 4), 10);
          break;
        default:
          throw new errors_js_1.JOSENotSupported(`Content Encryption Algorithm ${enc} is not supported either by JOSE or your javascript runtime`);
      }
      if (cek instanceof Uint8Array) {
        if (cek.length << 3 !== expected) {
          throw new errors_js_1.JWEInvalid("Invalid Content Encryption Key length");
        }
        return;
      }
      if ((0, is_key_object_js_1.default)(cek) && cek.type === "secret") {
        if (cek.symmetricKeySize << 3 !== expected) {
          throw new errors_js_1.JWEInvalid("Invalid Content Encryption Key length");
        }
        return;
      }
      throw new TypeError("Invalid Content Encryption Key type");
    };
    exports2.default = checkCekLength;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/timing_safe_equal.js
var require_timing_safe_equal = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/timing_safe_equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var timingSafeEqual = crypto_1.timingSafeEqual;
    exports2.default = timingSafeEqual;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/cbc_tag.js
var require_cbc_tag = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/cbc_tag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var buffer_utils_js_1 = require_buffer_utils();
    function cbcTag(aad, iv, ciphertext, macSize, macKey, keySize) {
      const macData = (0, buffer_utils_js_1.concat)(aad, iv, ciphertext, (0, buffer_utils_js_1.uint64be)(aad.length << 3));
      const hmac = (0, crypto_1.createHmac)(`sha${macSize}`, macKey);
      hmac.update(macData);
      return hmac.digest().slice(0, keySize >> 3);
    }
    exports2.default = cbcTag;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/webcrypto.js
var require_webcrypto = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/webcrypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCryptoKey = void 0;
    var crypto = require("crypto");
    var util = require("util");
    var webcrypto = crypto.webcrypto;
    exports2.default = webcrypto;
    exports2.isCryptoKey = util.types.isCryptoKey ? (key) => util.types.isCryptoKey(key) : (key) => false;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/env.js
var require_env = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCloudflareWorkers = void 0;
    function isCloudflareWorkers() {
      return false;
    }
    exports2.isCloudflareWorkers = isCloudflareWorkers;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/crypto_key.js
var require_crypto_key = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/crypto_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkEncCryptoKey = exports2.checkSigCryptoKey = void 0;
    var env_js_1 = require_env();
    function unusable(name, prop = "algorithm.name") {
      return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
    }
    function isAlgorithm(algorithm, name) {
      return algorithm.name === name;
    }
    function getHashLength(hash) {
      return parseInt(hash.name.slice(4), 10);
    }
    function getNamedCurve(alg) {
      switch (alg) {
        case "ES256":
          return "P-256";
        case "ES384":
          return "P-384";
        case "ES512":
          return "P-521";
        default:
          throw new Error("unreachable");
      }
    }
    function checkUsage(key, usages) {
      if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
        let msg = "CryptoKey does not support this operation, its usages must include ";
        if (usages.length > 2) {
          const last = usages.pop();
          msg += `one of ${usages.join(", ")}, or ${last}.`;
        } else if (usages.length === 2) {
          msg += `one of ${usages[0]} or ${usages[1]}.`;
        } else {
          msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
      }
    }
    function checkSigCryptoKey(key, alg, ...usages) {
      switch (alg) {
        case "HS256":
        case "HS384":
        case "HS512": {
          if (!isAlgorithm(key.algorithm, "HMAC"))
            throw unusable("HMAC");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case "RS256":
        case "RS384":
        case "RS512": {
          if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
            throw unusable("RSASSA-PKCS1-v1_5");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case "PS256":
        case "PS384":
        case "PS512": {
          if (!isAlgorithm(key.algorithm, "RSA-PSS"))
            throw unusable("RSA-PSS");
          const expected = parseInt(alg.slice(2), 10);
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        case ((0, env_js_1.isCloudflareWorkers)() && "EdDSA"): {
          if (!isAlgorithm(key.algorithm, "NODE-ED25519"))
            throw unusable("NODE-ED25519");
          break;
        }
        case "ES256":
        case "ES384":
        case "ES512": {
          if (!isAlgorithm(key.algorithm, "ECDSA"))
            throw unusable("ECDSA");
          const expected = getNamedCurve(alg);
          const actual = key.algorithm.namedCurve;
          if (actual !== expected)
            throw unusable(expected, "algorithm.namedCurve");
          break;
        }
        default:
          throw new TypeError("CryptoKey does not support this operation");
      }
      checkUsage(key, usages);
    }
    exports2.checkSigCryptoKey = checkSigCryptoKey;
    function checkEncCryptoKey(key, alg, ...usages) {
      switch (alg) {
        case "A128GCM":
        case "A192GCM":
        case "A256GCM": {
          if (!isAlgorithm(key.algorithm, "AES-GCM"))
            throw unusable("AES-GCM");
          const expected = parseInt(alg.slice(1, 4), 10);
          const actual = key.algorithm.length;
          if (actual !== expected)
            throw unusable(expected, "algorithm.length");
          break;
        }
        case "A128KW":
        case "A192KW":
        case "A256KW": {
          if (!isAlgorithm(key.algorithm, "AES-KW"))
            throw unusable("AES-KW");
          const expected = parseInt(alg.slice(1, 4), 10);
          const actual = key.algorithm.length;
          if (actual !== expected)
            throw unusable(expected, "algorithm.length");
          break;
        }
        case "ECDH":
          if (!isAlgorithm(key.algorithm, "ECDH"))
            throw unusable("ECDH");
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          if (!isAlgorithm(key.algorithm, "PBKDF2"))
            throw unusable("PBKDF2");
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512": {
          if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
            throw unusable("RSA-OAEP");
          const expected = parseInt(alg.slice(9), 10) || 1;
          const actual = getHashLength(key.algorithm.hash);
          if (actual !== expected)
            throw unusable(`SHA-${expected}`, "algorithm.hash");
          break;
        }
        default:
          throw new TypeError("CryptoKey does not support this operation");
      }
      checkUsage(key, usages);
    }
    exports2.checkEncCryptoKey = checkEncCryptoKey;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/invalid_key_input.js
var require_invalid_key_input = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/invalid_key_input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = (actual, ...types) => {
      let msg = "Key must be ";
      if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(", ")}, or ${last}.`;
      } else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
      } else {
        msg += `of type ${types[0]}.`;
      }
      if (actual == null) {
        msg += ` Received ${actual}`;
      } else if (typeof actual === "function" && actual.name) {
        msg += ` Received function ${actual.name}`;
      } else if (typeof actual === "object" && actual != null) {
        if (actual.constructor && actual.constructor.name) {
          msg += ` Received an instance of ${actual.constructor.name}`;
        }
      }
      return msg;
    };
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/ciphers.js
var require_ciphers = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/ciphers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var ciphers;
    exports2.default = (algorithm) => {
      ciphers || (ciphers = new Set((0, crypto_1.getCiphers)()));
      return ciphers.has(algorithm);
    };
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/is_key_like.js
var require_is_key_like = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/is_key_like.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.types = void 0;
    var webcrypto_js_1 = require_webcrypto();
    var is_key_object_js_1 = require_is_key_object();
    exports2.default = (key) => (0, is_key_object_js_1.default)(key) || (0, webcrypto_js_1.isCryptoKey)(key);
    var types = ["KeyObject"];
    exports2.types = types;
    if (parseInt(process.versions.node) >= 16) {
      types.push("CryptoKey");
    }
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/decrypt.js
var require_decrypt = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var check_iv_length_js_1 = require_check_iv_length();
    var check_cek_length_js_1 = require_check_cek_length();
    var buffer_utils_js_1 = require_buffer_utils();
    var errors_js_1 = require_errors3();
    var timing_safe_equal_js_1 = require_timing_safe_equal();
    var cbc_tag_js_1 = require_cbc_tag();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var ciphers_js_1 = require_ciphers();
    var is_key_like_js_1 = require_is_key_like();
    function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
      const keySize = parseInt(enc.slice(1, 4), 10);
      if ((0, is_key_object_js_1.default)(cek)) {
        cek = cek.export();
      }
      const encKey = cek.subarray(keySize >> 3);
      const macKey = cek.subarray(0, keySize >> 3);
      const macSize = parseInt(enc.slice(-3), 10);
      const algorithm = `aes-${keySize}-cbc`;
      if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
      }
      const expectedTag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
      let macCheckPassed;
      try {
        macCheckPassed = (0, timing_safe_equal_js_1.default)(tag, expectedTag);
      } catch {
      }
      if (!macCheckPassed) {
        throw new errors_js_1.JWEDecryptionFailed();
      }
      let plaintext;
      try {
        const decipher = (0, crypto_1.createDecipheriv)(algorithm, encKey, iv);
        plaintext = (0, buffer_utils_js_1.concat)(decipher.update(ciphertext), decipher.final());
      } catch {
      }
      if (!plaintext) {
        throw new errors_js_1.JWEDecryptionFailed();
      }
      return plaintext;
    }
    function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
      const keySize = parseInt(enc.slice(1, 4), 10);
      const algorithm = `aes-${keySize}-gcm`;
      if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
      }
      try {
        const decipher = (0, crypto_1.createDecipheriv)(algorithm, cek, iv, { authTagLength: 16 });
        decipher.setAuthTag(tag);
        if (aad.byteLength) {
          decipher.setAAD(aad, { plaintextLength: ciphertext.length });
        }
        const plaintext = decipher.update(ciphertext);
        decipher.final();
        return plaintext;
      } catch {
        throw new errors_js_1.JWEDecryptionFailed();
      }
    }
    var decrypt = (enc, cek, ciphertext, iv, tag, aad) => {
      let key;
      if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, "decrypt");
        key = crypto_1.KeyObject.from(cek);
      } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
        key = cek;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, "Uint8Array"));
      }
      (0, check_cek_length_js_1.default)(enc, key);
      (0, check_iv_length_js_1.default)(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          return cbcDecrypt(enc, key, ciphertext, iv, tag, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          return gcmDecrypt(enc, key, ciphertext, iv, tag, aad);
        default:
          throw new errors_js_1.JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    exports2.default = decrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/zlib.js
var require_zlib = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/zlib.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deflate = exports2.inflate = void 0;
    var util_1 = require("util");
    var zlib_1 = require("zlib");
    var inflateRaw = (0, util_1.promisify)(zlib_1.inflateRaw);
    var deflateRaw = (0, util_1.promisify)(zlib_1.deflateRaw);
    var inflate = (input) => inflateRaw(input);
    exports2.inflate = inflate;
    var deflate = (input) => deflateRaw(input);
    exports2.deflate = deflate;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/is_disjoint.js
var require_is_disjoint = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/is_disjoint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    exports2.default = isDisjoint;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/is_object.js
var require_is_object = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/is_object.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isObjectLike(value) {
      return typeof value === "object" && value !== null;
    }
    function isObject(input) {
      if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
        return false;
      }
      if (Object.getPrototypeOf(input) === null) {
        return true;
      }
      let proto = input;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(input) === proto;
    }
    exports2.default = isObject;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/aeskw.js
var require_aeskw = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/aeskw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unwrap = exports2.wrap = void 0;
    var buffer_1 = require("buffer");
    var crypto_1 = require("crypto");
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var ciphers_js_1 = require_ciphers();
    var is_key_like_js_1 = require_is_key_like();
    function checkKeySize(key, alg) {
      if (key.symmetricKeySize << 3 !== parseInt(alg.slice(1, 4), 10)) {
        throw new TypeError(`Invalid key size for alg: ${alg}`);
      }
    }
    function ensureKeyObject(key, alg, usage) {
      if ((0, is_key_object_js_1.default)(key)) {
        return key;
      }
      if (key instanceof Uint8Array) {
        return (0, crypto_1.createSecretKey)(key);
      }
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, usage);
        return crypto_1.KeyObject.from(key);
      }
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
    }
    var wrap = (alg, key, cek) => {
      const size = parseInt(alg.slice(1, 4), 10);
      const algorithm = `aes${size}-wrap`;
      if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
      const keyObject = ensureKeyObject(key, alg, "wrapKey");
      checkKeySize(keyObject, alg);
      const cipher = (0, crypto_1.createCipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 166));
      return (0, buffer_utils_js_1.concat)(cipher.update(cek), cipher.final());
    };
    exports2.wrap = wrap;
    var unwrap = (alg, key, encryptedKey) => {
      const size = parseInt(alg.slice(1, 4), 10);
      const algorithm = `aes${size}-wrap`;
      if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
      const keyObject = ensureKeyObject(key, alg, "unwrapKey");
      checkKeySize(keyObject, alg);
      const cipher = (0, crypto_1.createDecipheriv)(algorithm, keyObject, buffer_1.Buffer.alloc(8, 166));
      return (0, buffer_utils_js_1.concat)(cipher.update(encryptedKey), cipher.final());
    };
    exports2.unwrap = unwrap;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/get_named_curve.js
var require_get_named_curve = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/get_named_curve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setCurve = exports2.weakMap = void 0;
    var buffer_1 = require("buffer");
    var crypto_1 = require("crypto");
    var errors_js_1 = require_errors3();
    var webcrypto_js_1 = require_webcrypto();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var p256 = buffer_1.Buffer.from([42, 134, 72, 206, 61, 3, 1, 7]);
    var p384 = buffer_1.Buffer.from([43, 129, 4, 0, 34]);
    var p521 = buffer_1.Buffer.from([43, 129, 4, 0, 35]);
    var secp256k1 = buffer_1.Buffer.from([43, 129, 4, 0, 10]);
    exports2.weakMap = /* @__PURE__ */ new WeakMap();
    var namedCurveToJOSE = (namedCurve) => {
      switch (namedCurve) {
        case "prime256v1":
          return "P-256";
        case "secp384r1":
          return "P-384";
        case "secp521r1":
          return "P-521";
        case "secp256k1":
          return "secp256k1";
        default:
          throw new errors_js_1.JOSENotSupported("Unsupported key curve for this operation");
      }
    };
    var getNamedCurve = (kee, raw) => {
      var _a;
      let key;
      if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
        key = crypto_1.KeyObject.from(kee);
      } else if ((0, is_key_object_js_1.default)(kee)) {
        key = kee;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
      }
      if (key.type === "secret") {
        throw new TypeError('only "private" or "public" type keys can be used for this operation');
      }
      switch (key.asymmetricKeyType) {
        case "ed25519":
        case "ed448":
          return `Ed${key.asymmetricKeyType.slice(2)}`;
        case "x25519":
        case "x448":
          return `X${key.asymmetricKeyType.slice(1)}`;
        case "ec": {
          if (exports2.weakMap.has(key)) {
            return exports2.weakMap.get(key);
          }
          let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.namedCurve;
          if (!namedCurve && key.type === "private") {
            namedCurve = getNamedCurve((0, crypto_1.createPublicKey)(key), true);
          } else if (!namedCurve) {
            const buf = key.export({ format: "der", type: "spki" });
            const i = buf[1] < 128 ? 14 : 15;
            const len = buf[i];
            const curveOid = buf.slice(i + 1, i + 1 + len);
            if (curveOid.equals(p256)) {
              namedCurve = "prime256v1";
            } else if (curveOid.equals(p384)) {
              namedCurve = "secp384r1";
            } else if (curveOid.equals(p521)) {
              namedCurve = "secp521r1";
            } else if (curveOid.equals(secp256k1)) {
              namedCurve = "secp256k1";
            } else {
              throw new errors_js_1.JOSENotSupported("Unsupported key curve for this operation");
            }
          }
          if (raw)
            return namedCurve;
          const curve = namedCurveToJOSE(namedCurve);
          exports2.weakMap.set(key, curve);
          return curve;
        }
        default:
          throw new TypeError("Invalid asymmetric key type for this operation");
      }
    };
    function setCurve(keyObject, curve) {
      exports2.weakMap.set(keyObject, curve);
    }
    exports2.setCurve = setCurve;
    exports2.default = getNamedCurve;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/ecdhes.js
var require_ecdhes = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/ecdhes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ecdhAllowed = exports2.generateEpk = exports2.deriveKey = void 0;
    var crypto_1 = require("crypto");
    var util_1 = require("util");
    var get_named_curve_js_1 = require_get_named_curve();
    var buffer_utils_js_1 = require_buffer_utils();
    var errors_js_1 = require_errors3();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var generateKeyPair = (0, util_1.promisify)(crypto_1.generateKeyPair);
    async function deriveKey(publicKee, privateKee, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
      let publicKey;
      if ((0, webcrypto_js_1.isCryptoKey)(publicKee)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(publicKee, "ECDH");
        publicKey = crypto_1.KeyObject.from(publicKee);
      } else if ((0, is_key_object_js_1.default)(publicKee)) {
        publicKey = publicKee;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(publicKee, ...is_key_like_js_1.types));
      }
      let privateKey;
      if ((0, webcrypto_js_1.isCryptoKey)(privateKee)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(privateKee, "ECDH", "deriveBits");
        privateKey = crypto_1.KeyObject.from(privateKee);
      } else if ((0, is_key_object_js_1.default)(privateKee)) {
        privateKey = privateKee;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(privateKee, ...is_key_like_js_1.types));
      }
      const value = (0, buffer_utils_js_1.concat)((0, buffer_utils_js_1.lengthAndInput)(buffer_utils_js_1.encoder.encode(algorithm)), (0, buffer_utils_js_1.lengthAndInput)(apu), (0, buffer_utils_js_1.lengthAndInput)(apv), (0, buffer_utils_js_1.uint32be)(keyLength));
      const sharedSecret = (0, crypto_1.diffieHellman)({ privateKey, publicKey });
      return (0, buffer_utils_js_1.concatKdf)(sharedSecret, keyLength, value);
    }
    exports2.deriveKey = deriveKey;
    async function generateEpk(kee) {
      let key;
      if ((0, webcrypto_js_1.isCryptoKey)(kee)) {
        key = crypto_1.KeyObject.from(kee);
      } else if ((0, is_key_object_js_1.default)(kee)) {
        key = kee;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(kee, ...is_key_like_js_1.types));
      }
      switch (key.asymmetricKeyType) {
        case "x25519":
          return generateKeyPair("x25519");
        case "x448": {
          return generateKeyPair("x448");
        }
        case "ec": {
          const namedCurve = (0, get_named_curve_js_1.default)(key);
          return generateKeyPair("ec", { namedCurve });
        }
        default:
          throw new errors_js_1.JOSENotSupported("Invalid or unsupported EPK");
      }
    }
    exports2.generateEpk = generateEpk;
    var ecdhAllowed = (key) => ["P-256", "P-384", "P-521", "X25519", "X448"].includes((0, get_named_curve_js_1.default)(key));
    exports2.ecdhAllowed = ecdhAllowed;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/check_p2s.js
var require_check_p2s = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/check_p2s.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors3();
    function checkP2s(p2s) {
      if (!(p2s instanceof Uint8Array) || p2s.length < 8) {
        throw new errors_js_1.JWEInvalid("PBES2 Salt Input must be 8 or more octets");
      }
    }
    exports2.default = checkP2s;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/pbes2kw.js
var require_pbes2kw = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/pbes2kw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = void 0;
    var util_1 = require("util");
    var crypto_1 = require("crypto");
    var random_js_1 = require_random();
    var buffer_utils_js_1 = require_buffer_utils();
    var base64url_js_1 = require_base64url();
    var aeskw_js_1 = require_aeskw();
    var check_p2s_js_1 = require_check_p2s();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var pbkdf2 = (0, util_1.promisify)(crypto_1.pbkdf2);
    function getPassword(key, alg) {
      if ((0, is_key_object_js_1.default)(key)) {
        return key.export();
      }
      if (key instanceof Uint8Array) {
        return key;
      }
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, "deriveBits", "deriveKey");
        return crypto_1.KeyObject.from(key).export();
      }
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
    }
    var encrypt = async (alg, key, cek, p2c = 2048, p2s = (0, random_js_1.default)(new Uint8Array(16))) => {
      (0, check_p2s_js_1.default)(p2s);
      const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
      const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
      const password = getPassword(key, alg);
      const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
      const encryptedKey = await (0, aeskw_js_1.wrap)(alg.slice(-6), derivedKey, cek);
      return { encryptedKey, p2c, p2s: (0, base64url_js_1.encode)(p2s) };
    };
    exports2.encrypt = encrypt;
    var decrypt = async (alg, key, encryptedKey, p2c, p2s) => {
      (0, check_p2s_js_1.default)(p2s);
      const salt = (0, buffer_utils_js_1.p2s)(alg, p2s);
      const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
      const password = getPassword(key, alg);
      const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha${alg.slice(8, 11)}`);
      return (0, aeskw_js_1.unwrap)(alg.slice(-6), derivedKey, encryptedKey);
    };
    exports2.decrypt = decrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/check_modulus_length.js
var require_check_modulus_length = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/check_modulus_length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setModulusLength = exports2.weakMap = void 0;
    exports2.weakMap = /* @__PURE__ */ new WeakMap();
    var getLength = (buf, index) => {
      let len = buf.readUInt8(1);
      if ((len & 128) === 0) {
        if (index === 0) {
          return len;
        }
        return getLength(buf.subarray(2 + len), index - 1);
      }
      const num = len & 127;
      len = 0;
      for (let i = 0; i < num; i++) {
        len <<= 8;
        const j = buf.readUInt8(2 + i);
        len |= j;
      }
      if (index === 0) {
        return len;
      }
      return getLength(buf.subarray(2 + len), index - 1);
    };
    var getLengthOfSeqIndex = (sequence, index) => {
      const len = sequence.readUInt8(1);
      if ((len & 128) === 0) {
        return getLength(sequence.subarray(2), index);
      }
      const num = len & 127;
      return getLength(sequence.subarray(2 + num), index);
    };
    var getModulusLength = (key) => {
      var _a, _b;
      if (exports2.weakMap.has(key)) {
        return exports2.weakMap.get(key);
      }
      const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === void 0 ? void 0 : _a.modulusLength) !== null && _b !== void 0 ? _b : getLengthOfSeqIndex(key.export({ format: "der", type: "pkcs1" }), key.type === "private" ? 1 : 0) - 1 << 3;
      exports2.weakMap.set(key, modulusLength);
      return modulusLength;
    };
    var setModulusLength = (keyObject, modulusLength) => {
      exports2.weakMap.set(keyObject, modulusLength);
    };
    exports2.setModulusLength = setModulusLength;
    exports2.default = (key, alg) => {
      if (getModulusLength(key) < 2048) {
        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
      }
    };
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/rsaes.js
var require_rsaes = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/rsaes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decrypt = exports2.encrypt = void 0;
    var crypto_1 = require("crypto");
    var check_modulus_length_js_1 = require_check_modulus_length();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var checkKey = (key, alg) => {
      if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
      }
      (0, check_modulus_length_js_1.default)(key, alg);
    };
    var resolvePadding = (alg) => {
      switch (alg) {
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          return crypto_1.constants.RSA_PKCS1_OAEP_PADDING;
        case "RSA1_5":
          return crypto_1.constants.RSA_PKCS1_PADDING;
        default:
          return void 0;
      }
    };
    var resolveOaepHash = (alg) => {
      switch (alg) {
        case "RSA-OAEP":
          return "sha1";
        case "RSA-OAEP-256":
          return "sha256";
        case "RSA-OAEP-384":
          return "sha384";
        case "RSA-OAEP-512":
          return "sha512";
        default:
          return void 0;
      }
    };
    function ensureKeyObject(key, alg, ...usages) {
      if ((0, is_key_object_js_1.default)(key)) {
        return key;
      }
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(key, alg, ...usages);
        return crypto_1.KeyObject.from(key);
      }
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
    }
    var encrypt = (alg, key, cek) => {
      const padding = resolvePadding(alg);
      const oaepHash = resolveOaepHash(alg);
      const keyObject = ensureKeyObject(key, alg, "wrapKey", "encrypt");
      checkKey(keyObject, alg);
      return (0, crypto_1.publicEncrypt)({ key: keyObject, oaepHash, padding }, cek);
    };
    exports2.encrypt = encrypt;
    var decrypt = (alg, key, encryptedKey) => {
      const padding = resolvePadding(alg);
      const oaepHash = resolveOaepHash(alg);
      const keyObject = ensureKeyObject(key, alg, "unwrapKey", "decrypt");
      checkKey(keyObject, alg);
      return (0, crypto_1.privateDecrypt)({ key: keyObject, oaepHash, padding }, encryptedKey);
    };
    exports2.decrypt = decrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/cek.js
var require_cek = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/cek.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bitLength = void 0;
    var errors_js_1 = require_errors3();
    var random_js_1 = require_random();
    function bitLength(alg) {
      switch (alg) {
        case "A128GCM":
          return 128;
        case "A192GCM":
          return 192;
        case "A256GCM":
        case "A128CBC-HS256":
          return 256;
        case "A192CBC-HS384":
          return 384;
        case "A256CBC-HS512":
          return 512;
        default:
          throw new errors_js_1.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
      }
    }
    exports2.bitLength = bitLength;
    exports2.default = (alg) => (0, random_js_1.default)(new Uint8Array(bitLength(alg) >> 3));
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/asn1.js
var require_asn1 = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/asn1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromSPKI = exports2.fromPKCS8 = exports2.toPKCS8 = exports2.toSPKI = void 0;
    var crypto_1 = require("crypto");
    var buffer_1 = require("buffer");
    var webcrypto_js_1 = require_webcrypto();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var genericExport = (keyType, keyFormat, key) => {
      let keyObject;
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        if (!key.extractable) {
          throw new TypeError("CryptoKey is not extractable");
        }
        keyObject = crypto_1.KeyObject.from(key);
      } else if ((0, is_key_object_js_1.default)(key)) {
        keyObject = key;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
      }
      if (keyObject.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
      }
      return keyObject.export({ format: "pem", type: keyFormat });
    };
    var toSPKI = (key) => {
      return genericExport("public", "spki", key);
    };
    exports2.toSPKI = toSPKI;
    var toPKCS8 = (key) => {
      return genericExport("private", "pkcs8", key);
    };
    exports2.toPKCS8 = toPKCS8;
    var fromPKCS8 = (pem) => (0, crypto_1.createPrivateKey)({
      key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ""), "base64"),
      type: "pkcs8",
      format: "der"
    });
    exports2.fromPKCS8 = fromPKCS8;
    var fromSPKI = (pem) => (0, crypto_1.createPublicKey)({
      key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ""), "base64"),
      type: "spki",
      format: "der"
    });
    exports2.fromSPKI = fromSPKI;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/asn1_sequence_encoder.js
var require_asn1_sequence_encoder = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/asn1_sequence_encoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var errors_js_1 = require_errors3();
    var tagInteger = 2;
    var tagBitStr = 3;
    var tagOctStr = 4;
    var tagSequence = 48;
    var bZero = buffer_1.Buffer.from([0]);
    var bTagInteger = buffer_1.Buffer.from([tagInteger]);
    var bTagBitStr = buffer_1.Buffer.from([tagBitStr]);
    var bTagSequence = buffer_1.Buffer.from([tagSequence]);
    var bTagOctStr = buffer_1.Buffer.from([tagOctStr]);
    var encodeLength = (len) => {
      if (len < 128)
        return buffer_1.Buffer.from([len]);
      const buffer = buffer_1.Buffer.alloc(5);
      buffer.writeUInt32BE(len, 1);
      let offset = 1;
      while (buffer[offset] === 0)
        offset++;
      buffer[offset - 1] = 128 | 5 - offset;
      return buffer.slice(offset - 1);
    };
    var oids = /* @__PURE__ */ new Map([
      ["P-256", buffer_1.Buffer.from("06 08 2A 86 48 CE 3D 03 01 07".replace(/ /g, ""), "hex")],
      ["secp256k1", buffer_1.Buffer.from("06 05 2B 81 04 00 0A".replace(/ /g, ""), "hex")],
      ["P-384", buffer_1.Buffer.from("06 05 2B 81 04 00 22".replace(/ /g, ""), "hex")],
      ["P-521", buffer_1.Buffer.from("06 05 2B 81 04 00 23".replace(/ /g, ""), "hex")],
      ["ecPublicKey", buffer_1.Buffer.from("06 07 2A 86 48 CE 3D 02 01".replace(/ /g, ""), "hex")],
      ["X25519", buffer_1.Buffer.from("06 03 2B 65 6E".replace(/ /g, ""), "hex")],
      ["X448", buffer_1.Buffer.from("06 03 2B 65 6F".replace(/ /g, ""), "hex")],
      ["Ed25519", buffer_1.Buffer.from("06 03 2B 65 70".replace(/ /g, ""), "hex")],
      ["Ed448", buffer_1.Buffer.from("06 03 2B 65 71".replace(/ /g, ""), "hex")]
    ]);
    var DumbAsn1Encoder = class {
      constructor() {
        this.length = 0;
        this.elements = [];
      }
      oidFor(oid) {
        const bOid = oids.get(oid);
        if (!bOid) {
          throw new errors_js_1.JOSENotSupported("Invalid or unsupported OID");
        }
        this.elements.push(bOid);
        this.length += bOid.length;
      }
      zero() {
        this.elements.push(bTagInteger, buffer_1.Buffer.from([1]), bZero);
        this.length += 3;
      }
      one() {
        this.elements.push(bTagInteger, buffer_1.Buffer.from([1]), buffer_1.Buffer.from([1]));
        this.length += 3;
      }
      unsignedInteger(integer) {
        if (integer[0] & 128) {
          const len = encodeLength(integer.length + 1);
          this.elements.push(bTagInteger, len, bZero, integer);
          this.length += 2 + len.length + integer.length;
        } else {
          let i = 0;
          while (integer[i] === 0 && (integer[i + 1] & 128) === 0)
            i++;
          const len = encodeLength(integer.length - i);
          this.elements.push(bTagInteger, encodeLength(integer.length - i), integer.slice(i));
          this.length += 1 + len.length + integer.length - i;
        }
      }
      octStr(octStr) {
        const len = encodeLength(octStr.length);
        this.elements.push(bTagOctStr, encodeLength(octStr.length), octStr);
        this.length += 1 + len.length + octStr.length;
      }
      bitStr(bitS) {
        const len = encodeLength(bitS.length + 1);
        this.elements.push(bTagBitStr, encodeLength(bitS.length + 1), bZero, bitS);
        this.length += 1 + len.length + bitS.length + 1;
      }
      add(seq) {
        this.elements.push(seq);
        this.length += seq.length;
      }
      end(tag = bTagSequence) {
        const len = encodeLength(this.length);
        return buffer_1.Buffer.concat([tag, len, ...this.elements], 1 + len.length + this.length);
      }
    };
    exports2.default = DumbAsn1Encoder;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/jwk_to_key.js
var require_jwk_to_key = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/jwk_to_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var crypto_1 = require("crypto");
    var base64url_js_1 = require_base64url();
    var errors_js_1 = require_errors3();
    var get_named_curve_js_1 = require_get_named_curve();
    var check_modulus_length_js_1 = require_check_modulus_length();
    var asn1_sequence_encoder_js_1 = require_asn1_sequence_encoder();
    var [major, minor] = process.version.slice(1).split(".").map((str) => parseInt(str, 10));
    var jwkImportSupported = major >= 16 || major === 15 && minor >= 12;
    var parse = (jwk) => {
      if (jwkImportSupported && jwk.kty !== "oct") {
        return jwk.d ? (0, crypto_1.createPrivateKey)({ format: "jwk", key: jwk }) : (0, crypto_1.createPublicKey)({ format: "jwk", key: jwk });
      }
      switch (jwk.kty) {
        case "oct": {
          return (0, crypto_1.createSecretKey)((0, base64url_js_1.decode)(jwk.k));
        }
        case "RSA": {
          const enc = new asn1_sequence_encoder_js_1.default();
          const isPrivate = jwk.d !== void 0;
          const modulus = buffer_1.Buffer.from(jwk.n, "base64");
          const exponent = buffer_1.Buffer.from(jwk.e, "base64");
          if (isPrivate) {
            enc.zero();
            enc.unsignedInteger(modulus);
            enc.unsignedInteger(exponent);
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.d, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.p, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.q, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.dp, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.dq, "base64"));
            enc.unsignedInteger(buffer_1.Buffer.from(jwk.qi, "base64"));
          } else {
            enc.unsignedInteger(modulus);
            enc.unsignedInteger(exponent);
          }
          const der = enc.end();
          const createInput = {
            key: der,
            format: "der",
            type: "pkcs1"
          };
          const keyObject = isPrivate ? (0, crypto_1.createPrivateKey)(createInput) : (0, crypto_1.createPublicKey)(createInput);
          (0, check_modulus_length_js_1.setModulusLength)(keyObject, modulus.length << 3);
          return keyObject;
        }
        case "EC": {
          const enc = new asn1_sequence_encoder_js_1.default();
          const isPrivate = jwk.d !== void 0;
          const pub = buffer_1.Buffer.concat([
            buffer_1.Buffer.alloc(1, 4),
            buffer_1.Buffer.from(jwk.x, "base64"),
            buffer_1.Buffer.from(jwk.y, "base64")
          ]);
          if (isPrivate) {
            enc.zero();
            const enc$12 = new asn1_sequence_encoder_js_1.default();
            enc$12.oidFor("ecPublicKey");
            enc$12.oidFor(jwk.crv);
            enc.add(enc$12.end());
            const enc$2 = new asn1_sequence_encoder_js_1.default();
            enc$2.one();
            enc$2.octStr(buffer_1.Buffer.from(jwk.d, "base64"));
            const enc$3 = new asn1_sequence_encoder_js_1.default();
            enc$3.bitStr(pub);
            const f2 = enc$3.end(buffer_1.Buffer.from([161]));
            enc$2.add(f2);
            const f = enc$2.end();
            const enc$4 = new asn1_sequence_encoder_js_1.default();
            enc$4.add(f);
            const f3 = enc$4.end(buffer_1.Buffer.from([4]));
            enc.add(f3);
            const der2 = enc.end();
            const keyObject2 = (0, crypto_1.createPrivateKey)({ key: der2, format: "der", type: "pkcs8" });
            (0, get_named_curve_js_1.setCurve)(keyObject2, jwk.crv);
            return keyObject2;
          }
          const enc$1 = new asn1_sequence_encoder_js_1.default();
          enc$1.oidFor("ecPublicKey");
          enc$1.oidFor(jwk.crv);
          enc.add(enc$1.end());
          enc.bitStr(pub);
          const der = enc.end();
          const keyObject = (0, crypto_1.createPublicKey)({ key: der, format: "der", type: "spki" });
          (0, get_named_curve_js_1.setCurve)(keyObject, jwk.crv);
          return keyObject;
        }
        case "OKP": {
          const enc = new asn1_sequence_encoder_js_1.default();
          const isPrivate = jwk.d !== void 0;
          if (isPrivate) {
            enc.zero();
            const enc$12 = new asn1_sequence_encoder_js_1.default();
            enc$12.oidFor(jwk.crv);
            enc.add(enc$12.end());
            const enc$2 = new asn1_sequence_encoder_js_1.default();
            enc$2.octStr(buffer_1.Buffer.from(jwk.d, "base64"));
            const f = enc$2.end(buffer_1.Buffer.from([4]));
            enc.add(f);
            const der2 = enc.end();
            return (0, crypto_1.createPrivateKey)({ key: der2, format: "der", type: "pkcs8" });
          }
          const enc$1 = new asn1_sequence_encoder_js_1.default();
          enc$1.oidFor(jwk.crv);
          enc.add(enc$1.end());
          enc.bitStr(buffer_1.Buffer.from(jwk.x, "base64"));
          const der = enc.end();
          return (0, crypto_1.createPublicKey)({ key: der, format: "der", type: "spki" });
        }
        default:
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
      }
    };
    exports2.default = parse;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/format_pem.js
var require_format_pem = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/format_pem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = (b64, descriptor) => {
      const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
      return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
    };
  }
});

// ../node_modules/jose/dist/node/cjs/key/import.js
var require_import = __commonJS({
  "../node_modules/jose/dist/node/cjs/key/import.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.importJWK = exports2.importPKCS8 = exports2.importX509 = exports2.importSPKI = void 0;
    var base64url_js_1 = require_base64url();
    var asn1_js_1 = require_asn1();
    var asn1_js_2 = require_asn1();
    var jwk_to_key_js_1 = require_jwk_to_key();
    var errors_js_1 = require_errors3();
    var format_pem_js_1 = require_format_pem();
    var is_object_js_1 = require_is_object();
    function getElement(seq) {
      let result = [];
      let next = 0;
      while (next < seq.length) {
        let nextPart = parseElement(seq.subarray(next));
        result.push(nextPart);
        next += nextPart.byteLength;
      }
      return result;
    }
    function parseElement(bytes) {
      let position = 0;
      let tag = bytes[0] & 31;
      position++;
      if (tag === 31) {
        tag = 0;
        while (bytes[position] >= 128) {
          tag = tag * 128 + bytes[position] - 128;
          position++;
        }
        tag = tag * 128 + bytes[position] - 128;
        position++;
      }
      let length = 0;
      if (bytes[position] < 128) {
        length = bytes[position];
        position++;
      } else {
        let numberOfDigits = bytes[position] & 127;
        position++;
        length = 0;
        for (let i = 0; i < numberOfDigits; i++) {
          length = length * 256 + bytes[position];
          position++;
        }
      }
      if (length === 128) {
        length = 0;
        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {
          length++;
        }
        const byteLength2 = position + length + 2;
        return {
          byteLength: byteLength2,
          contents: bytes.subarray(position, position + length),
          raw: bytes.subarray(0, byteLength2)
        };
      }
      const byteLength = position + length;
      return {
        byteLength,
        contents: bytes.subarray(position, byteLength),
        raw: bytes.subarray(0, byteLength)
      };
    }
    function spkiFromX509(buf) {
      const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
      return (0, base64url_js_1.encodeBase64)(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
    }
    function getSPKI(x509) {
      const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
      const raw = (0, base64url_js_1.decodeBase64)(pem);
      return (0, format_pem_js_1.default)(spkiFromX509(raw), "PUBLIC KEY");
    }
    async function importSPKI(spki, alg, options) {
      if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
      }
      return (0, asn1_js_1.fromSPKI)(spki, alg, options);
    }
    exports2.importSPKI = importSPKI;
    async function importX509(x509, alg, options) {
      if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
        throw new TypeError('"x509" must be X.509 formatted string');
      }
      const spki = getSPKI(x509);
      return (0, asn1_js_1.fromSPKI)(spki, alg, options);
    }
    exports2.importX509 = importX509;
    async function importPKCS8(pkcs8, alg, options) {
      if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
        throw new TypeError('"pkcs8" must be PCKS8 formatted string');
      }
      return (0, asn1_js_2.fromPKCS8)(pkcs8, alg, options);
    }
    exports2.importPKCS8 = importPKCS8;
    async function importJWK(jwk, alg, octAsKeyObject) {
      if (!(0, is_object_js_1.default)(jwk)) {
        throw new TypeError("JWK must be an object");
      }
      alg || (alg = jwk.alg);
      if (typeof alg !== "string" || !alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      switch (jwk.kty) {
        case "oct":
          if (typeof jwk.k !== "string" || !jwk.k) {
            throw new TypeError('missing "k" (Key Value) Parameter value');
          }
          octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
          if (octAsKeyObject) {
            return (0, jwk_to_key_js_1.default)({ ...jwk, alg, ext: false });
          }
          return (0, base64url_js_1.decode)(jwk.k);
        case "RSA":
          if (jwk.oth !== void 0) {
            throw new errors_js_1.JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
          }
        case "EC":
        case "OKP":
          return (0, jwk_to_key_js_1.default)({ ...jwk, alg });
        default:
          throw new errors_js_1.JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
      }
    }
    exports2.importJWK = importJWK;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/check_key_type.js
var require_check_key_type = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/check_key_type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var symmetricTypeCheck = (key) => {
      if (key instanceof Uint8Array)
        return;
      if (!(0, is_key_like_js_1.default)(key)) {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    var asymmetricTypeCheck = (key, usage) => {
      if (!(0, is_key_like_js_1.default)(key)) {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${is_key_like_js_1.types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    var checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(key);
      } else {
        asymmetricTypeCheck(key, usage);
      }
    };
    exports2.default = checkKeyType;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/encrypt.js
var require_encrypt2 = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var check_iv_length_js_1 = require_check_iv_length();
    var check_cek_length_js_1 = require_check_cek_length();
    var buffer_utils_js_1 = require_buffer_utils();
    var cbc_tag_js_1 = require_cbc_tag();
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var errors_js_1 = require_errors3();
    var ciphers_js_1 = require_ciphers();
    var is_key_like_js_1 = require_is_key_like();
    function cbcEncrypt(enc, plaintext, cek, iv, aad) {
      const keySize = parseInt(enc.slice(1, 4), 10);
      if ((0, is_key_object_js_1.default)(cek)) {
        cek = cek.export();
      }
      const encKey = cek.subarray(keySize >> 3);
      const macKey = cek.subarray(0, keySize >> 3);
      const algorithm = `aes-${keySize}-cbc`;
      if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
      }
      const cipher = (0, crypto_1.createCipheriv)(algorithm, encKey, iv);
      const ciphertext = (0, buffer_utils_js_1.concat)(cipher.update(plaintext), cipher.final());
      const macSize = parseInt(enc.slice(-3), 10);
      const tag = (0, cbc_tag_js_1.default)(aad, iv, ciphertext, macSize, macKey, keySize);
      return { ciphertext, tag };
    }
    function gcmEncrypt(enc, plaintext, cek, iv, aad) {
      const keySize = parseInt(enc.slice(1, 4), 10);
      const algorithm = `aes-${keySize}-gcm`;
      if (!(0, ciphers_js_1.default)(algorithm)) {
        throw new errors_js_1.JOSENotSupported(`alg ${enc} is not supported by your javascript runtime`);
      }
      const cipher = (0, crypto_1.createCipheriv)(algorithm, cek, iv, { authTagLength: 16 });
      if (aad.byteLength) {
        cipher.setAAD(aad, { plaintextLength: plaintext.length });
      }
      const ciphertext = cipher.update(plaintext);
      cipher.final();
      const tag = cipher.getAuthTag();
      return { ciphertext, tag };
    }
    var encrypt = (enc, plaintext, cek, iv, aad) => {
      let key;
      if ((0, webcrypto_js_1.isCryptoKey)(cek)) {
        (0, crypto_key_js_1.checkEncCryptoKey)(cek, enc, "encrypt");
        key = crypto_1.KeyObject.from(cek);
      } else if (cek instanceof Uint8Array || (0, is_key_object_js_1.default)(cek)) {
        key = cek;
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(cek, ...is_key_like_js_1.types, "Uint8Array"));
      }
      (0, check_cek_length_js_1.default)(enc, key);
      (0, check_iv_length_js_1.default)(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          return cbcEncrypt(enc, plaintext, key, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          return gcmEncrypt(enc, plaintext, key, iv, aad);
        default:
          throw new errors_js_1.JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    exports2.default = encrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/aesgcmkw.js
var require_aesgcmkw = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/aesgcmkw.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unwrap = exports2.wrap = void 0;
    var encrypt_js_1 = require_encrypt2();
    var decrypt_js_1 = require_decrypt();
    var iv_js_1 = require_iv();
    var base64url_js_1 = require_base64url();
    async function wrap(alg, key, cek, iv) {
      const jweAlgorithm = alg.slice(0, 7);
      iv || (iv = (0, iv_js_1.default)(jweAlgorithm));
      const { ciphertext: encryptedKey, tag } = await (0, encrypt_js_1.default)(jweAlgorithm, cek, key, iv, new Uint8Array(0));
      return { encryptedKey, iv: (0, base64url_js_1.encode)(iv), tag: (0, base64url_js_1.encode)(tag) };
    }
    exports2.wrap = wrap;
    async function unwrap(alg, key, encryptedKey, iv, tag) {
      const jweAlgorithm = alg.slice(0, 7);
      return (0, decrypt_js_1.default)(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
    }
    exports2.unwrap = unwrap;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/decrypt_key_management.js
var require_decrypt_key_management = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/decrypt_key_management.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var aeskw_js_1 = require_aeskw();
    var ECDH = require_ecdhes();
    var pbes2kw_js_1 = require_pbes2kw();
    var rsaes_js_1 = require_rsaes();
    var base64url_js_1 = require_base64url();
    var errors_js_1 = require_errors3();
    var cek_js_1 = require_cek();
    var import_js_1 = require_import();
    var check_key_type_js_1 = require_check_key_type();
    var is_object_js_1 = require_is_object();
    var aesgcmkw_js_1 = require_aesgcmkw();
    async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
      (0, check_key_type_js_1.default)(alg, key, "decrypt");
      switch (alg) {
        case "dir": {
          if (encryptedKey !== void 0)
            throw new errors_js_1.JWEInvalid("Encountered unexpected JWE Encrypted Key");
          return key;
        }
        case "ECDH-ES":
          if (encryptedKey !== void 0)
            throw new errors_js_1.JWEInvalid("Encountered unexpected JWE Encrypted Key");
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          if (!(0, is_object_js_1.default)(joseHeader.epk))
            throw new errors_js_1.JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
          if (!ECDH.ecdhAllowed(key))
            throw new errors_js_1.JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
          const epk = await (0, import_js_1.importJWK)(joseHeader.epk, alg);
          let partyUInfo;
          let partyVInfo;
          if (joseHeader.apu !== void 0) {
            if (typeof joseHeader.apu !== "string")
              throw new errors_js_1.JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
            partyUInfo = (0, base64url_js_1.decode)(joseHeader.apu);
          }
          if (joseHeader.apv !== void 0) {
            if (typeof joseHeader.apv !== "string")
              throw new errors_js_1.JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
            partyVInfo = (0, base64url_js_1.decode)(joseHeader.apv);
          }
          const sharedSecret = await ECDH.deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? (0, cek_js_1.bitLength)(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
          if (alg === "ECDH-ES")
            return sharedSecret;
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          return (0, aeskw_js_1.unwrap)(alg.slice(-6), sharedSecret, encryptedKey);
        }
        case "RSA1_5":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512": {
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          return (0, rsaes_js_1.decrypt)(alg, key, encryptedKey);
        }
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW": {
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          if (typeof joseHeader.p2c !== "number")
            throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
          const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 1e4;
          if (joseHeader.p2c > p2cLimit)
            throw new errors_js_1.JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
          if (typeof joseHeader.p2s !== "string")
            throw new errors_js_1.JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
          return (0, pbes2kw_js_1.decrypt)(alg, key, encryptedKey, joseHeader.p2c, (0, base64url_js_1.decode)(joseHeader.p2s));
        }
        case "A128KW":
        case "A192KW":
        case "A256KW": {
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          return (0, aeskw_js_1.unwrap)(alg, key, encryptedKey);
        }
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW": {
          if (encryptedKey === void 0)
            throw new errors_js_1.JWEInvalid("JWE Encrypted Key missing");
          if (typeof joseHeader.iv !== "string")
            throw new errors_js_1.JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
          if (typeof joseHeader.tag !== "string")
            throw new errors_js_1.JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
          const iv = (0, base64url_js_1.decode)(joseHeader.iv);
          const tag = (0, base64url_js_1.decode)(joseHeader.tag);
          return (0, aesgcmkw_js_1.unwrap)(alg, key, encryptedKey, iv, tag);
        }
        default: {
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
        }
      }
    }
    exports2.default = decryptKeyManagement;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/validate_crit.js
var require_validate_crit = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/validate_crit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors3();
    function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
      if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
      }
      if (!protectedHeader || protectedHeader.crit === void 0) {
        return /* @__PURE__ */ new Set();
      }
      if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
      }
      let recognized;
      if (recognizedOption !== void 0) {
        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
      } else {
        recognized = recognizedDefault;
      }
      for (const parameter of protectedHeader.crit) {
        if (!recognized.has(parameter)) {
          throw new errors_js_1.JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === void 0) {
          throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
          throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
      }
      return new Set(protectedHeader.crit);
    }
    exports2.default = validateCrit;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/validate_algorithms.js
var require_validate_algorithms = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/validate_algorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    exports2.default = validateAlgorithms;
  }
});

// ../node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js
var require_decrypt2 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwe/flattened/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flattenedDecrypt = void 0;
    var base64url_js_1 = require_base64url();
    var decrypt_js_1 = require_decrypt();
    var zlib_js_1 = require_zlib();
    var errors_js_1 = require_errors3();
    var is_disjoint_js_1 = require_is_disjoint();
    var is_object_js_1 = require_is_object();
    var decrypt_key_management_js_1 = require_decrypt_key_management();
    var buffer_utils_js_1 = require_buffer_utils();
    var cek_js_1 = require_cek();
    var validate_crit_js_1 = require_validate_crit();
    var validate_algorithms_js_1 = require_validate_algorithms();
    async function flattenedDecrypt(jwe, key, options) {
      var _a;
      if (!(0, is_object_js_1.default)(jwe)) {
        throw new errors_js_1.JWEInvalid("Flattened JWE must be an object");
      }
      if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
        throw new errors_js_1.JWEInvalid("JOSE Header missing");
      }
      if (typeof jwe.iv !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Initialization Vector missing or incorrect type");
      }
      if (typeof jwe.ciphertext !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Ciphertext missing or incorrect type");
      }
      if (typeof jwe.tag !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Authentication Tag missing or incorrect type");
      }
      if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Protected Header incorrect type");
      }
      if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
        throw new errors_js_1.JWEInvalid("JWE Encrypted Key incorrect type");
      }
      if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
        throw new errors_js_1.JWEInvalid("JWE AAD incorrect type");
      }
      if (jwe.header !== void 0 && !(0, is_object_js_1.default)(jwe.header)) {
        throw new errors_js_1.JWEInvalid("JWE Shared Unprotected Header incorrect type");
      }
      if (jwe.unprotected !== void 0 && !(0, is_object_js_1.default)(jwe.unprotected)) {
        throw new errors_js_1.JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
      }
      let parsedProt;
      if (jwe.protected) {
        try {
          const protectedHeader2 = (0, base64url_js_1.decode)(jwe.protected);
          parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader2));
        } catch {
          throw new errors_js_1.JWEInvalid("JWE Protected Header is invalid");
        }
      }
      if (!(0, is_disjoint_js_1.default)(parsedProt, jwe.header, jwe.unprotected)) {
        throw new errors_js_1.JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
      }
      const joseHeader = {
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected
      };
      (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
      if (joseHeader.zip !== void 0) {
        if (!parsedProt || !parsedProt.zip) {
          throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
        }
        if (joseHeader.zip !== "DEF") {
          throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
        }
      }
      const { alg, enc } = joseHeader;
      if (typeof alg !== "string" || !alg) {
        throw new errors_js_1.JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
      }
      if (typeof enc !== "string" || !enc) {
        throw new errors_js_1.JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
      }
      const keyManagementAlgorithms = options && (0, validate_algorithms_js_1.default)("keyManagementAlgorithms", options.keyManagementAlgorithms);
      const contentEncryptionAlgorithms = options && (0, validate_algorithms_js_1.default)("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
      if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
      }
      if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
      }
      let encryptedKey;
      if (jwe.encrypted_key !== void 0) {
        encryptedKey = (0, base64url_js_1.decode)(jwe.encrypted_key);
      }
      let resolvedKey = false;
      if (typeof key === "function") {
        key = await key(parsedProt, jwe);
        resolvedKey = true;
      }
      let cek;
      try {
        cek = await (0, decrypt_key_management_js_1.default)(alg, key, encryptedKey, joseHeader, options);
      } catch (err) {
        if (err instanceof TypeError || err instanceof errors_js_1.JWEInvalid || err instanceof errors_js_1.JOSENotSupported) {
          throw err;
        }
        cek = (0, cek_js_1.default)(enc);
      }
      const iv = (0, base64url_js_1.decode)(jwe.iv);
      const tag = (0, base64url_js_1.decode)(jwe.tag);
      const protectedHeader = buffer_utils_js_1.encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : "");
      let additionalData;
      if (jwe.aad !== void 0) {
        additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), buffer_utils_js_1.encoder.encode(jwe.aad));
      } else {
        additionalData = protectedHeader;
      }
      let plaintext = await (0, decrypt_js_1.default)(enc, cek, (0, base64url_js_1.decode)(jwe.ciphertext), iv, tag, additionalData);
      if (joseHeader.zip === "DEF") {
        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || zlib_js_1.inflate)(plaintext);
      }
      const result = { plaintext };
      if (jwe.protected !== void 0) {
        result.protectedHeader = parsedProt;
      }
      if (jwe.aad !== void 0) {
        result.additionalAuthenticatedData = (0, base64url_js_1.decode)(jwe.aad);
      }
      if (jwe.unprotected !== void 0) {
        result.sharedUnprotectedHeader = jwe.unprotected;
      }
      if (jwe.header !== void 0) {
        result.unprotectedHeader = jwe.header;
      }
      if (resolvedKey) {
        return { ...result, key };
      }
      return result;
    }
    exports2.flattenedDecrypt = flattenedDecrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js
var require_decrypt3 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwe/compact/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compactDecrypt = void 0;
    var decrypt_js_1 = require_decrypt2();
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    async function compactDecrypt(jwe, key, options) {
      if (jwe instanceof Uint8Array) {
        jwe = buffer_utils_js_1.decoder.decode(jwe);
      }
      if (typeof jwe !== "string") {
        throw new errors_js_1.JWEInvalid("Compact JWE must be a string or Uint8Array");
      }
      const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split(".");
      if (length !== 5) {
        throw new errors_js_1.JWEInvalid("Invalid Compact JWE");
      }
      const decrypted = await (0, decrypt_js_1.flattenedDecrypt)({
        ciphertext,
        iv: iv || void 0,
        protected: protectedHeader || void 0,
        tag: tag || void 0,
        encrypted_key: encryptedKey || void 0
      }, key, options);
      const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: decrypted.key };
      }
      return result;
    }
    exports2.compactDecrypt = compactDecrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/jwe/general/decrypt.js
var require_decrypt4 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwe/general/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generalDecrypt = void 0;
    var decrypt_js_1 = require_decrypt2();
    var errors_js_1 = require_errors3();
    var is_object_js_1 = require_is_object();
    async function generalDecrypt(jwe, key, options) {
      if (!(0, is_object_js_1.default)(jwe)) {
        throw new errors_js_1.JWEInvalid("General JWE must be an object");
      }
      if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(is_object_js_1.default)) {
        throw new errors_js_1.JWEInvalid("JWE Recipients missing or incorrect type");
      }
      if (!jwe.recipients.length) {
        throw new errors_js_1.JWEInvalid("JWE Recipients has no members");
      }
      for (const recipient of jwe.recipients) {
        try {
          return await (0, decrypt_js_1.flattenedDecrypt)({
            aad: jwe.aad,
            ciphertext: jwe.ciphertext,
            encrypted_key: recipient.encrypted_key,
            header: recipient.header,
            iv: jwe.iv,
            protected: jwe.protected,
            tag: jwe.tag,
            unprotected: jwe.unprotected
          }, key, options);
        } catch {
        }
      }
      throw new errors_js_1.JWEDecryptionFailed();
    }
    exports2.generalDecrypt = generalDecrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/asn1_sequence_decoder.js
var require_asn1_sequence_decoder = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/asn1_sequence_decoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tagInteger = 2;
    var tagSequence = 48;
    var Asn1SequenceDecoder = class {
      constructor(buffer) {
        if (buffer[0] !== tagSequence) {
          throw new TypeError();
        }
        this.buffer = buffer;
        this.offset = 1;
        const len = this.decodeLength();
        if (len !== buffer.length - this.offset) {
          throw new TypeError();
        }
      }
      decodeLength() {
        let length = this.buffer[this.offset++];
        if (length & 128) {
          const nBytes = length & ~128;
          length = 0;
          for (let i = 0; i < nBytes; i++)
            length = length << 8 | this.buffer[this.offset + i];
          this.offset += nBytes;
        }
        return length;
      }
      unsignedInteger() {
        if (this.buffer[this.offset++] !== tagInteger) {
          throw new TypeError();
        }
        let length = this.decodeLength();
        if (this.buffer[this.offset] === 0) {
          this.offset++;
          length--;
        }
        const result = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return result;
      }
      end() {
        if (this.offset !== this.buffer.length) {
          throw new TypeError();
        }
      }
    };
    exports2.default = Asn1SequenceDecoder;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/key_to_jwk.js
var require_key_to_jwk = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/key_to_jwk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var base64url_js_1 = require_base64url();
    var asn1_sequence_decoder_js_1 = require_asn1_sequence_decoder();
    var errors_js_1 = require_errors3();
    var get_named_curve_js_1 = require_get_named_curve();
    var webcrypto_js_1 = require_webcrypto();
    var is_key_object_js_1 = require_is_key_object();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    var [major, minor] = process.version.slice(1).split(".").map((str) => parseInt(str, 10));
    var jwkExportSupported = major >= 16 || major === 15 && minor >= 9;
    var keyToJWK = (key) => {
      let keyObject;
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        if (!key.extractable) {
          throw new TypeError("CryptoKey is not extractable");
        }
        keyObject = crypto_1.KeyObject.from(key);
      } else if ((0, is_key_object_js_1.default)(key)) {
        keyObject = key;
      } else if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: (0, base64url_js_1.encode)(key)
        };
      } else {
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
      }
      if (jwkExportSupported) {
        if (keyObject.type !== "secret" && !["rsa", "ec", "ed25519", "x25519", "ed448", "x448"].includes(keyObject.asymmetricKeyType)) {
          throw new errors_js_1.JOSENotSupported("Unsupported key asymmetricKeyType");
        }
        return keyObject.export({ format: "jwk" });
      }
      switch (keyObject.type) {
        case "secret":
          return {
            kty: "oct",
            k: (0, base64url_js_1.encode)(keyObject.export())
          };
        case "private":
        case "public": {
          switch (keyObject.asymmetricKeyType) {
            case "rsa": {
              const der = keyObject.export({ format: "der", type: "pkcs1" });
              const dec = new asn1_sequence_decoder_js_1.default(der);
              if (keyObject.type === "private") {
                dec.unsignedInteger();
              }
              const n = (0, base64url_js_1.encode)(dec.unsignedInteger());
              const e = (0, base64url_js_1.encode)(dec.unsignedInteger());
              let jwk;
              if (keyObject.type === "private") {
                jwk = {
                  d: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  p: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  q: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  dp: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  dq: (0, base64url_js_1.encode)(dec.unsignedInteger()),
                  qi: (0, base64url_js_1.encode)(dec.unsignedInteger())
                };
              }
              dec.end();
              return { kty: "RSA", n, e, ...jwk };
            }
            case "ec": {
              const crv = (0, get_named_curve_js_1.default)(keyObject);
              let len;
              let offset;
              let correction;
              switch (crv) {
                case "secp256k1":
                  len = 64;
                  offset = 31 + 2;
                  correction = -1;
                  break;
                case "P-256":
                  len = 64;
                  offset = 34 + 2;
                  correction = -1;
                  break;
                case "P-384":
                  len = 96;
                  offset = 33 + 2;
                  correction = -3;
                  break;
                case "P-521":
                  len = 132;
                  offset = 33 + 2;
                  correction = -3;
                  break;
                default:
                  throw new errors_js_1.JOSENotSupported("Unsupported curve");
              }
              if (keyObject.type === "public") {
                const der2 = keyObject.export({ type: "spki", format: "der" });
                return {
                  kty: "EC",
                  crv,
                  x: (0, base64url_js_1.encode)(der2.subarray(-len, -len / 2)),
                  y: (0, base64url_js_1.encode)(der2.subarray(-len / 2))
                };
              }
              const der = keyObject.export({ type: "pkcs8", format: "der" });
              if (der.length < 100) {
                offset += correction;
              }
              return {
                ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                d: (0, base64url_js_1.encode)(der.subarray(offset, offset + len / 2))
              };
            }
            case "ed25519":
            case "x25519": {
              const crv = (0, get_named_curve_js_1.default)(keyObject);
              if (keyObject.type === "public") {
                const der2 = keyObject.export({ type: "spki", format: "der" });
                return {
                  kty: "OKP",
                  crv,
                  x: (0, base64url_js_1.encode)(der2.subarray(-32))
                };
              }
              const der = keyObject.export({ type: "pkcs8", format: "der" });
              return {
                ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                d: (0, base64url_js_1.encode)(der.subarray(-32))
              };
            }
            case "ed448":
            case "x448": {
              const crv = (0, get_named_curve_js_1.default)(keyObject);
              if (keyObject.type === "public") {
                const der2 = keyObject.export({ type: "spki", format: "der" });
                return {
                  kty: "OKP",
                  crv,
                  x: (0, base64url_js_1.encode)(der2.subarray(crv === "Ed448" ? -57 : -56))
                };
              }
              const der = keyObject.export({ type: "pkcs8", format: "der" });
              return {
                ...keyToJWK((0, crypto_1.createPublicKey)(keyObject)),
                d: (0, base64url_js_1.encode)(der.subarray(crv === "Ed448" ? -57 : -56))
              };
            }
            default:
              throw new errors_js_1.JOSENotSupported("Unsupported key asymmetricKeyType");
          }
        }
        default:
          throw new errors_js_1.JOSENotSupported("Unsupported key type");
      }
    };
    exports2.default = keyToJWK;
  }
});

// ../node_modules/jose/dist/node/cjs/key/export.js
var require_export = __commonJS({
  "../node_modules/jose/dist/node/cjs/key/export.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exportJWK = exports2.exportPKCS8 = exports2.exportSPKI = void 0;
    var asn1_js_1 = require_asn1();
    var asn1_js_2 = require_asn1();
    var key_to_jwk_js_1 = require_key_to_jwk();
    async function exportSPKI(key) {
      return (0, asn1_js_1.toSPKI)(key);
    }
    exports2.exportSPKI = exportSPKI;
    async function exportPKCS8(key) {
      return (0, asn1_js_2.toPKCS8)(key);
    }
    exports2.exportPKCS8 = exportPKCS8;
    async function exportJWK(key) {
      return (0, key_to_jwk_js_1.default)(key);
    }
    exports2.exportJWK = exportJWK;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js
var require_encrypt_key_management = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/encrypt_key_management.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var aeskw_js_1 = require_aeskw();
    var ECDH = require_ecdhes();
    var pbes2kw_js_1 = require_pbes2kw();
    var rsaes_js_1 = require_rsaes();
    var base64url_js_1 = require_base64url();
    var cek_js_1 = require_cek();
    var errors_js_1 = require_errors3();
    var export_js_1 = require_export();
    var check_key_type_js_1 = require_check_key_type();
    var aesgcmkw_js_1 = require_aesgcmkw();
    async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
      let encryptedKey;
      let parameters;
      let cek;
      (0, check_key_type_js_1.default)(alg, key, "encrypt");
      switch (alg) {
        case "dir": {
          cek = key;
          break;
        }
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          if (!ECDH.ecdhAllowed(key)) {
            throw new errors_js_1.JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
          }
          const { apu, apv } = providedParameters;
          let { epk: ephemeralKey } = providedParameters;
          ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);
          const { x, y, crv, kty } = await (0, export_js_1.exportJWK)(ephemeralKey);
          const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? (0, cek_js_1.bitLength)(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
          parameters = { epk: { x, crv, kty } };
          if (kty === "EC")
            parameters.epk.y = y;
          if (apu)
            parameters.apu = (0, base64url_js_1.encode)(apu);
          if (apv)
            parameters.apv = (0, base64url_js_1.encode)(apv);
          if (alg === "ECDH-ES") {
            cek = sharedSecret;
            break;
          }
          cek = providedCek || (0, cek_js_1.default)(enc);
          const kwAlg = alg.slice(-6);
          encryptedKey = await (0, aeskw_js_1.wrap)(kwAlg, sharedSecret, cek);
          break;
        }
        case "RSA1_5":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512": {
          cek = providedCek || (0, cek_js_1.default)(enc);
          encryptedKey = await (0, rsaes_js_1.encrypt)(alg, key, cek);
          break;
        }
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW": {
          cek = providedCek || (0, cek_js_1.default)(enc);
          const { p2c, p2s } = providedParameters;
          ({ encryptedKey, ...parameters } = await (0, pbes2kw_js_1.encrypt)(alg, key, cek, p2c, p2s));
          break;
        }
        case "A128KW":
        case "A192KW":
        case "A256KW": {
          cek = providedCek || (0, cek_js_1.default)(enc);
          encryptedKey = await (0, aeskw_js_1.wrap)(alg, key, cek);
          break;
        }
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW": {
          cek = providedCek || (0, cek_js_1.default)(enc);
          const { iv } = providedParameters;
          ({ encryptedKey, ...parameters } = await (0, aesgcmkw_js_1.wrap)(alg, key, cek, iv));
          break;
        }
        default: {
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
        }
      }
      return { cek, encryptedKey, parameters };
    }
    exports2.default = encryptKeyManagement;
  }
});

// ../node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js
var require_encrypt3 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwe/flattened/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FlattenedEncrypt = exports2.unprotected = void 0;
    var base64url_js_1 = require_base64url();
    var encrypt_js_1 = require_encrypt2();
    var zlib_js_1 = require_zlib();
    var iv_js_1 = require_iv();
    var encrypt_key_management_js_1 = require_encrypt_key_management();
    var errors_js_1 = require_errors3();
    var is_disjoint_js_1 = require_is_disjoint();
    var buffer_utils_js_1 = require_buffer_utils();
    var validate_crit_js_1 = require_validate_crit();
    exports2.unprotected = Symbol();
    var FlattenedEncrypt = class {
      constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
          throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
          throw new errors_js_1.JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
          throw new errors_js_1.JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...this._sharedUnprotectedHeader
        };
        (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== void 0) {
          if (!this._protectedHeader || !this._protectedHeader.zip) {
            throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          }
          if (joseHeader.zip !== "DEF") {
            throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
          throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
          }
        } else if (alg === "ECDH-ES") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
          }
        }
        let cek;
        {
          let parameters;
          ({ cek, encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(alg, enc, key, this._cek, this._keyManagementParameters));
          if (parameters) {
            if (options && exports2.unprotected in options) {
              if (!this._unprotectedHeader) {
                this.setUnprotectedHeader(parameters);
              } else {
                this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
              }
            } else {
              if (!this._protectedHeader) {
                this.setProtectedHeader(parameters);
              } else {
                this._protectedHeader = { ...this._protectedHeader, ...parameters };
              }
            }
          }
        }
        this._iv || (this._iv = (0, iv_js_1.default)(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
          protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = buffer_utils_js_1.encoder.encode("");
        }
        if (this._aad) {
          aadMember = (0, base64url_js_1.encode)(this._aad);
          additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), buffer_utils_js_1.encoder.encode(aadMember));
        } else {
          additionalData = protectedHeader;
        }
        let ciphertext;
        let tag;
        if (joseHeader.zip === "DEF") {
          const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || zlib_js_1.deflate)(this._plaintext);
          ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, deflated, cek, this._iv, additionalData));
        } else {
          ;
          ({ ciphertext, tag } = await (0, encrypt_js_1.default)(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
          ciphertext: (0, base64url_js_1.encode)(ciphertext),
          iv: (0, base64url_js_1.encode)(this._iv),
          tag: (0, base64url_js_1.encode)(tag)
        };
        if (encryptedKey) {
          jwe.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
        }
        if (aadMember) {
          jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
          jwe.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
          jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
          jwe.header = this._unprotectedHeader;
        }
        return jwe;
      }
    };
    exports2.FlattenedEncrypt = FlattenedEncrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/jwe/general/encrypt.js
var require_encrypt4 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwe/general/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GeneralEncrypt = void 0;
    var encrypt_js_1 = require_encrypt3();
    var errors_js_1 = require_errors3();
    var cek_js_1 = require_cek();
    var is_disjoint_js_1 = require_is_disjoint();
    var encrypt_key_management_js_1 = require_encrypt_key_management();
    var base64url_js_1 = require_base64url();
    var validate_crit_js_1 = require_validate_crit();
    var IndividualRecipient = class {
      constructor(enc, key, options) {
        this.parent = enc;
        this.key = key;
        this.options = options;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addRecipient(...args) {
        return this.parent.addRecipient(...args);
      }
      encrypt(...args) {
        return this.parent.encrypt(...args);
      }
      done() {
        return this.parent;
      }
    };
    var GeneralEncrypt = class {
      constructor(plaintext) {
        this._recipients = [];
        this._plaintext = plaintext;
      }
      addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      async encrypt(options) {
        var _a, _b, _c;
        if (!this._recipients.length) {
          throw new errors_js_1.JWEInvalid("at least one recipient must be added");
        }
        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
        if (this._recipients.length === 1) {
          const [recipient] = this._recipients;
          const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
          let jwe2 = {
            ciphertext: flattened.ciphertext,
            iv: flattened.iv,
            recipients: [{}],
            tag: flattened.tag
          };
          if (flattened.aad)
            jwe2.aad = flattened.aad;
          if (flattened.protected)
            jwe2.protected = flattened.protected;
          if (flattened.unprotected)
            jwe2.unprotected = flattened.unprotected;
          if (flattened.encrypted_key)
            jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            jwe2.recipients[0].header = flattened.header;
          return jwe2;
        }
        let enc;
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
            throw new errors_js_1.JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          }
          if (alg === "dir" || alg === "ECDH-ES") {
            throw new errors_js_1.JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          }
          if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
            throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          }
          if (!enc) {
            enc = joseHeader.enc;
          } else if (enc !== joseHeader.enc) {
            throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          }
          (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
          if (joseHeader.zip !== void 0) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
              throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
          }
        }
        const cek = (0, cek_js_1.default)(enc);
        let jwe = {
          ciphertext: "",
          iv: "",
          recipients: [],
          tag: ""
        };
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          const target = {};
          jwe.recipients.push(target);
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : void 0;
          if (i === 0) {
            const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
              ...recipient.options,
              ...options,
              [encrypt_js_1.unprotected]: true
            });
            jwe.ciphertext = flattened.ciphertext;
            jwe.iv = flattened.iv;
            jwe.tag = flattened.tag;
            if (flattened.aad)
              jwe.aad = flattened.aad;
            if (flattened.protected)
              jwe.protected = flattened.protected;
            if (flattened.unprotected)
              jwe.unprotected = flattened.unprotected;
            target.encrypted_key = flattened.encrypted_key;
            if (flattened.header)
              target.header = flattened.header;
            continue;
          }
          const { encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
          target.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
          if (recipient.unprotectedHeader || parameters)
            target.header = { ...recipient.unprotectedHeader, ...parameters };
        }
        return jwe;
      }
    };
    exports2.GeneralEncrypt = GeneralEncrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/dsa_digest.js
var require_dsa_digest = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/dsa_digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors3();
    function dsaDigest(alg) {
      switch (alg) {
        case "PS256":
        case "RS256":
        case "ES256":
        case "ES256K":
          return "sha256";
        case "PS384":
        case "RS384":
        case "ES384":
          return "sha384";
        case "PS512":
        case "RS512":
        case "ES512":
          return "sha512";
        case "EdDSA":
          return void 0;
        default:
          throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
    }
    exports2.default = dsaDigest;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/node_key.js
var require_node_key = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/node_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var get_named_curve_js_1 = require_get_named_curve();
    var errors_js_1 = require_errors3();
    var check_modulus_length_js_1 = require_check_modulus_length();
    var [major, minor] = process.version.slice(1).split(".").map((str) => parseInt(str, 10));
    var electron = "electron" in process.versions;
    var rsaPssParams = !electron && (major >= 17 || major === 16 && minor >= 9);
    var PSS = {
      padding: crypto_1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto_1.constants.RSA_PSS_SALTLEN_DIGEST
    };
    var ecCurveAlgMap = /* @__PURE__ */ new Map([
      ["ES256", "P-256"],
      ["ES256K", "secp256k1"],
      ["ES384", "P-384"],
      ["ES512", "P-521"]
    ]);
    function keyForCrypto(alg, key) {
      switch (alg) {
        case "EdDSA":
          if (!["ed25519", "ed448"].includes(key.asymmetricKeyType)) {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");
          }
          return key;
        case "RS256":
        case "RS384":
        case "RS512":
          if (key.asymmetricKeyType !== "rsa") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
          }
          (0, check_modulus_length_js_1.default)(key, alg);
          return key;
        case (rsaPssParams && "PS256"):
        case (rsaPssParams && "PS384"):
        case (rsaPssParams && "PS512"):
          if (key.asymmetricKeyType === "rsa-pss") {
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            const length = parseInt(alg.slice(-3), 10);
            if (hashAlgorithm !== void 0 && (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
              throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
            }
            if (saltLength !== void 0 && saltLength > length >> 3) {
              throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
            }
          } else if (key.asymmetricKeyType !== "rsa") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");
          }
          (0, check_modulus_length_js_1.default)(key, alg);
          return { key, ...PSS };
        case (!rsaPssParams && "PS256"):
        case (!rsaPssParams && "PS384"):
        case (!rsaPssParams && "PS512"):
          if (key.asymmetricKeyType !== "rsa") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
          }
          (0, check_modulus_length_js_1.default)(key, alg);
          return { key, ...PSS };
        case "ES256":
        case "ES256K":
        case "ES384":
        case "ES512": {
          if (key.asymmetricKeyType !== "ec") {
            throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");
          }
          const actual = (0, get_named_curve_js_1.default)(key);
          const expected = ecCurveAlgMap.get(alg);
          if (actual !== expected) {
            throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
          }
          return { dsaEncoding: "ieee-p1363", key };
        }
        default:
          throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
    }
    exports2.default = keyForCrypto;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/hmac_digest.js
var require_hmac_digest = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/hmac_digest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors3();
    function hmacDigest(alg) {
      switch (alg) {
        case "HS256":
          return "sha256";
        case "HS384":
          return "sha384";
        case "HS512":
          return "sha512";
        default:
          throw new errors_js_1.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
      }
    }
    exports2.default = hmacDigest;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js
var require_get_sign_verify_key = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/get_sign_verify_key.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var webcrypto_js_1 = require_webcrypto();
    var crypto_key_js_1 = require_crypto_key();
    var invalid_key_input_js_1 = require_invalid_key_input();
    var is_key_like_js_1 = require_is_key_like();
    function getSignVerifyKey(alg, key, usage) {
      if (key instanceof Uint8Array) {
        if (!alg.startsWith("HS")) {
          throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
        }
        return (0, crypto_1.createSecretKey)(key);
      }
      if (key instanceof crypto_1.KeyObject) {
        return key;
      }
      if ((0, webcrypto_js_1.isCryptoKey)(key)) {
        (0, crypto_key_js_1.checkSigCryptoKey)(key, alg, usage);
        return crypto_1.KeyObject.from(key);
      }
      throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types, "Uint8Array"));
    }
    exports2.default = getSignVerifyKey;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/sign.js
var require_sign = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto = require("crypto");
    var util_1 = require("util");
    var dsa_digest_js_1 = require_dsa_digest();
    var hmac_digest_js_1 = require_hmac_digest();
    var node_key_js_1 = require_node_key();
    var get_sign_verify_key_js_1 = require_get_sign_verify_key();
    var oneShotSign;
    if (crypto.sign.length > 3) {
      oneShotSign = (0, util_1.promisify)(crypto.sign);
    } else {
      oneShotSign = crypto.sign;
    }
    var sign = async (alg, key, data) => {
      const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, "sign");
      if (alg.startsWith("HS")) {
        const hmac = crypto.createHmac((0, hmac_digest_js_1.default)(alg), keyObject);
        hmac.update(data);
        return hmac.digest();
      }
      return oneShotSign((0, dsa_digest_js_1.default)(alg), data, (0, node_key_js_1.default)(alg, keyObject));
    };
    exports2.default = sign;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/verify.js
var require_verify = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto = require("crypto");
    var util_1 = require("util");
    var dsa_digest_js_1 = require_dsa_digest();
    var node_key_js_1 = require_node_key();
    var sign_js_1 = require_sign();
    var get_sign_verify_key_js_1 = require_get_sign_verify_key();
    var [major, minor] = process.version.slice(1).split(".").map((str) => parseInt(str, 10));
    var oneShotCallbackSupported = major >= 16 || major === 15 && minor >= 13;
    var oneShotVerify;
    if (crypto.verify.length > 4 && oneShotCallbackSupported) {
      oneShotVerify = (0, util_1.promisify)(crypto.verify);
    } else {
      oneShotVerify = crypto.verify;
    }
    var verify = async (alg, key, signature, data) => {
      const keyObject = (0, get_sign_verify_key_js_1.default)(alg, key, "verify");
      if (alg.startsWith("HS")) {
        const expected = await (0, sign_js_1.default)(alg, keyObject, data);
        const actual = signature;
        try {
          return crypto.timingSafeEqual(actual, expected);
        } catch {
          return false;
        }
      }
      const algorithm = (0, dsa_digest_js_1.default)(alg);
      const keyInput = (0, node_key_js_1.default)(alg, keyObject);
      try {
        return await oneShotVerify(algorithm, data, keyInput, signature);
      } catch {
        return false;
      }
    };
    exports2.default = verify;
  }
});

// ../node_modules/jose/dist/node/cjs/jws/flattened/verify.js
var require_verify2 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jws/flattened/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flattenedVerify = void 0;
    var base64url_js_1 = require_base64url();
    var verify_js_1 = require_verify();
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    var is_disjoint_js_1 = require_is_disjoint();
    var is_object_js_1 = require_is_object();
    var check_key_type_js_1 = require_check_key_type();
    var validate_crit_js_1 = require_validate_crit();
    var validate_algorithms_js_1 = require_validate_algorithms();
    async function flattenedVerify(jws, key, options) {
      var _a;
      if (!(0, is_object_js_1.default)(jws)) {
        throw new errors_js_1.JWSInvalid("Flattened JWS must be an object");
      }
      if (jws.protected === void 0 && jws.header === void 0) {
        throw new errors_js_1.JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
      }
      if (jws.protected !== void 0 && typeof jws.protected !== "string") {
        throw new errors_js_1.JWSInvalid("JWS Protected Header incorrect type");
      }
      if (jws.payload === void 0) {
        throw new errors_js_1.JWSInvalid("JWS Payload missing");
      }
      if (typeof jws.signature !== "string") {
        throw new errors_js_1.JWSInvalid("JWS Signature missing or incorrect type");
      }
      if (jws.header !== void 0 && !(0, is_object_js_1.default)(jws.header)) {
        throw new errors_js_1.JWSInvalid("JWS Unprotected Header incorrect type");
      }
      let parsedProt = {};
      if (jws.protected) {
        try {
          const protectedHeader = (0, base64url_js_1.decode)(jws.protected);
          parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
        } catch {
          throw new errors_js_1.JWSInvalid("JWS Protected Header is invalid");
        }
      }
      if (!(0, is_disjoint_js_1.default)(parsedProt, jws.header)) {
        throw new errors_js_1.JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
      }
      const joseHeader = {
        ...parsedProt,
        ...jws.header
      };
      const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
      let b64 = true;
      if (extensions.has("b64")) {
        b64 = parsedProt.b64;
        if (typeof b64 !== "boolean") {
          throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
      }
      const { alg } = joseHeader;
      if (typeof alg !== "string" || !alg) {
        throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
      }
      const algorithms = options && (0, validate_algorithms_js_1.default)("algorithms", options.algorithms);
      if (algorithms && !algorithms.has(alg)) {
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
      }
      if (b64) {
        if (typeof jws.payload !== "string") {
          throw new errors_js_1.JWSInvalid("JWS Payload must be a string");
        }
      } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
        throw new errors_js_1.JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
      }
      let resolvedKey = false;
      if (typeof key === "function") {
        key = await key(parsedProt, jws);
        resolvedKey = true;
      }
      (0, check_key_type_js_1.default)(alg, key, "verify");
      const data = (0, buffer_utils_js_1.concat)(buffer_utils_js_1.encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), buffer_utils_js_1.encoder.encode("."), typeof jws.payload === "string" ? buffer_utils_js_1.encoder.encode(jws.payload) : jws.payload);
      const signature = (0, base64url_js_1.decode)(jws.signature);
      const verified = await (0, verify_js_1.default)(alg, key, signature, data);
      if (!verified) {
        throw new errors_js_1.JWSSignatureVerificationFailed();
      }
      let payload;
      if (b64) {
        payload = (0, base64url_js_1.decode)(jws.payload);
      } else if (typeof jws.payload === "string") {
        payload = buffer_utils_js_1.encoder.encode(jws.payload);
      } else {
        payload = jws.payload;
      }
      const result = { payload };
      if (jws.protected !== void 0) {
        result.protectedHeader = parsedProt;
      }
      if (jws.header !== void 0) {
        result.unprotectedHeader = jws.header;
      }
      if (resolvedKey) {
        return { ...result, key };
      }
      return result;
    }
    exports2.flattenedVerify = flattenedVerify;
  }
});

// ../node_modules/jose/dist/node/cjs/jws/compact/verify.js
var require_verify3 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jws/compact/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compactVerify = void 0;
    var verify_js_1 = require_verify2();
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    async function compactVerify(jws, key, options) {
      if (jws instanceof Uint8Array) {
        jws = buffer_utils_js_1.decoder.decode(jws);
      }
      if (typeof jws !== "string") {
        throw new errors_js_1.JWSInvalid("Compact JWS must be a string or Uint8Array");
      }
      const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
      if (length !== 3) {
        throw new errors_js_1.JWSInvalid("Invalid Compact JWS");
      }
      const verified = await (0, verify_js_1.flattenedVerify)({ payload, protected: protectedHeader, signature }, key, options);
      const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: verified.key };
      }
      return result;
    }
    exports2.compactVerify = compactVerify;
  }
});

// ../node_modules/jose/dist/node/cjs/jws/general/verify.js
var require_verify4 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jws/general/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generalVerify = void 0;
    var verify_js_1 = require_verify2();
    var errors_js_1 = require_errors3();
    var is_object_js_1 = require_is_object();
    async function generalVerify(jws, key, options) {
      if (!(0, is_object_js_1.default)(jws)) {
        throw new errors_js_1.JWSInvalid("General JWS must be an object");
      }
      if (!Array.isArray(jws.signatures) || !jws.signatures.every(is_object_js_1.default)) {
        throw new errors_js_1.JWSInvalid("JWS Signatures missing or incorrect type");
      }
      for (const signature of jws.signatures) {
        try {
          return await (0, verify_js_1.flattenedVerify)({
            header: signature.header,
            payload: jws.payload,
            protected: signature.protected,
            signature: signature.signature
          }, key, options);
        } catch {
        }
      }
      throw new errors_js_1.JWSSignatureVerificationFailed();
    }
    exports2.generalVerify = generalVerify;
  }
});

// ../node_modules/jose/dist/node/cjs/lib/epoch.js
var require_epoch = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/epoch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = (date) => Math.floor(date.getTime() / 1e3);
  }
});

// ../node_modules/jose/dist/node/cjs/lib/secs.js
var require_secs = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/secs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var minute = 60;
    var hour = minute * 60;
    var day = hour * 24;
    var week = day * 7;
    var year = day * 365.25;
    var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
    exports2.default = (str) => {
      const matched = REGEX.exec(str);
      if (!matched) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[1]);
      const unit = matched[2].toLowerCase();
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
          return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
          return Math.round(value * week);
        default:
          return Math.round(value * year);
      }
    };
  }
});

// ../node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js
var require_jwt_claims_set = __commonJS({
  "../node_modules/jose/dist/node/cjs/lib/jwt_claims_set.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    var epoch_js_1 = require_epoch();
    var secs_js_1 = require_secs();
    var is_object_js_1 = require_is_object();
    var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    var checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    exports2.default = (protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(buffer_utils_js_1.decoder.decode(encodedPayload));
      } catch {
      }
      if (!(0, is_object_js_1.default)(payload)) {
        throw new errors_js_1.JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { issuer } = options;
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      const { subject } = options;
      if (subject && payload.sub !== subject) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      const { audience } = options;
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = (0, secs_js_1.default)(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now = (0, epoch_js_1.default)(currentDate || new Date());
      if ((payload.iat !== void 0 || options.maxTokenAge) && typeof payload.iat !== "number") {
        throw new errors_js_1.JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
          throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new errors_js_1.JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
          throw new errors_js_1.JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (options.maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof options.maxTokenAge === "number" ? options.maxTokenAge : (0, secs_js_1.default)(options.maxTokenAge);
        if (age - tolerance > max) {
          throw new errors_js_1.JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});

// ../node_modules/jose/dist/node/cjs/jwt/verify.js
var require_verify5 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwt/verify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jwtVerify = void 0;
    var verify_js_1 = require_verify3();
    var jwt_claims_set_js_1 = require_jwt_claims_set();
    var errors_js_1 = require_errors3();
    async function jwtVerify(jwt, key, options) {
      var _a;
      const verified = await (0, verify_js_1.compactVerify)(jwt, key, options);
      if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
        throw new errors_js_1.JWTInvalid("JWTs MUST NOT use unencoded payload");
      }
      const payload = (0, jwt_claims_set_js_1.default)(verified.protectedHeader, verified.payload, options);
      const result = { payload, protectedHeader: verified.protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: verified.key };
      }
      return result;
    }
    exports2.jwtVerify = jwtVerify;
  }
});

// ../node_modules/jose/dist/node/cjs/jwt/decrypt.js
var require_decrypt5 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwt/decrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jwtDecrypt = void 0;
    var decrypt_js_1 = require_decrypt3();
    var jwt_claims_set_js_1 = require_jwt_claims_set();
    var errors_js_1 = require_errors3();
    async function jwtDecrypt(jwt, key, options) {
      const decrypted = await (0, decrypt_js_1.compactDecrypt)(jwt, key, options);
      const payload = (0, jwt_claims_set_js_1.default)(decrypted.protectedHeader, decrypted.plaintext, options);
      const { protectedHeader } = decrypted;
      if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
      }
      if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
      }
      if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
        throw new errors_js_1.JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
      }
      const result = { payload, protectedHeader };
      if (typeof key === "function") {
        return { ...result, key: decrypted.key };
      }
      return result;
    }
    exports2.jwtDecrypt = jwtDecrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js
var require_encrypt5 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwe/compact/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompactEncrypt = void 0;
    var encrypt_js_1 = require_encrypt3();
    var CompactEncrypt = class {
      constructor(plaintext) {
        this._flattened = new encrypt_js_1.FlattenedEncrypt(plaintext);
      }
      setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
      }
      setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
      }
      async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
      }
    };
    exports2.CompactEncrypt = CompactEncrypt;
  }
});

// ../node_modules/jose/dist/node/cjs/jws/flattened/sign.js
var require_sign2 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jws/flattened/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FlattenedSign = void 0;
    var base64url_js_1 = require_base64url();
    var sign_js_1 = require_sign();
    var is_disjoint_js_1 = require_is_disjoint();
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    var check_key_type_js_1 = require_check_key_type();
    var validate_crit_js_1 = require_validate_crit();
    var FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new errors_js_1.JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader)) {
          throw new errors_js_1.JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        (0, check_key_type_js_1.default)(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = buffer_utils_js_1.encoder.encode("");
        }
        const data = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode("."), payload);
        const signature = await (0, sign_js_1.default)(alg, key, data);
        const jws = {
          signature: (0, base64url_js_1.encode)(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = buffer_utils_js_1.decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
        }
        return jws;
      }
    };
    exports2.FlattenedSign = FlattenedSign;
  }
});

// ../node_modules/jose/dist/node/cjs/jws/compact/sign.js
var require_sign3 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jws/compact/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompactSign = void 0;
    var sign_js_1 = require_sign2();
    var CompactSign = class {
      constructor(payload) {
        this._flattened = new sign_js_1.FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
    exports2.CompactSign = CompactSign;
  }
});

// ../node_modules/jose/dist/node/cjs/jws/general/sign.js
var require_sign4 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jws/general/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GeneralSign = void 0;
    var sign_js_1 = require_sign2();
    var errors_js_1 = require_errors3();
    var IndividualSignature = class {
      constructor(sig, key, options) {
        this.parent = sig;
        this.key = key;
        this.options = options;
      }
      setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addSignature(...args) {
        return this.parent.addSignature(...args);
      }
      sign(...args) {
        return this.parent.sign(...args);
      }
      done() {
        return this.parent;
      }
    };
    var GeneralSign = class {
      constructor(payload) {
        this._signatures = [];
        this._payload = payload;
      }
      addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
      }
      async sign() {
        if (!this._signatures.length) {
          throw new errors_js_1.JWSInvalid("at least one signature must be added");
        }
        const jws = {
          signatures: [],
          payload: ""
        };
        for (let i = 0; i < this._signatures.length; i++) {
          const signature = this._signatures[i];
          const flattened = new sign_js_1.FlattenedSign(this._payload);
          flattened.setProtectedHeader(signature.protectedHeader);
          flattened.setUnprotectedHeader(signature.unprotectedHeader);
          const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
          if (i === 0) {
            jws.payload = payload;
          } else if (jws.payload !== payload) {
            throw new errors_js_1.JWSInvalid("inconsistent use of JWS Unencoded Payload Option (RFC7797)");
          }
          jws.signatures.push(rest);
        }
        return jws;
      }
    };
    exports2.GeneralSign = GeneralSign;
  }
});

// ../node_modules/jose/dist/node/cjs/jwt/produce.js
var require_produce = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwt/produce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProduceJWT = void 0;
    var epoch_js_1 = require_epoch();
    var is_object_js_1 = require_is_object();
    var secs_js_1 = require_secs();
    var ProduceJWT = class {
      constructor(payload) {
        if (!(0, is_object_js_1.default)(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, nbf: input };
        } else {
          this._payload = { ...this._payload, nbf: (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input) };
        }
        return this;
      }
      setExpirationTime(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, exp: input };
        } else {
          this._payload = { ...this._payload, exp: (0, epoch_js_1.default)(new Date()) + (0, secs_js_1.default)(input) };
        }
        return this;
      }
      setIssuedAt(input) {
        if (typeof input === "undefined") {
          this._payload = { ...this._payload, iat: (0, epoch_js_1.default)(new Date()) };
        } else {
          this._payload = { ...this._payload, iat: input };
        }
        return this;
      }
    };
    exports2.ProduceJWT = ProduceJWT;
  }
});

// ../node_modules/jose/dist/node/cjs/jwt/sign.js
var require_sign5 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwt/sign.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignJWT = void 0;
    var sign_js_1 = require_sign3();
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    var produce_js_1 = require_produce();
    var SignJWT = class extends produce_js_1.ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a;
        const sig = new sign_js_1.CompactSign(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new errors_js_1.JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
    exports2.SignJWT = SignJWT;
  }
});

// ../node_modules/jose/dist/node/cjs/jwt/encrypt.js
var require_encrypt6 = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwt/encrypt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EncryptJWT = void 0;
    var encrypt_js_1 = require_encrypt5();
    var buffer_utils_js_1 = require_buffer_utils();
    var produce_js_1 = require_produce();
    var EncryptJWT = class extends produce_js_1.ProduceJWT {
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
      }
      replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
      }
      replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
      }
      async encrypt(key, options) {
        const enc = new encrypt_js_1.CompactEncrypt(buffer_utils_js_1.encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
          enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
          enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
          enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
      }
    };
    exports2.EncryptJWT = EncryptJWT;
  }
});

// ../node_modules/jose/dist/node/cjs/jwk/thumbprint.js
var require_thumbprint = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwk/thumbprint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateJwkThumbprintUri = exports2.calculateJwkThumbprint = void 0;
    var digest_js_1 = require_digest();
    var base64url_js_1 = require_base64url();
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    var is_object_js_1 = require_is_object();
    var check = (value, description) => {
      if (typeof value !== "string" || !value) {
        throw new errors_js_1.JWKInvalid(`${description} missing or invalid`);
      }
    };
    async function calculateJwkThumbprint(jwk, digestAlgorithm) {
      if (!(0, is_object_js_1.default)(jwk)) {
        throw new TypeError("JWK must be an object");
      }
      digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
      if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
        throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
      }
      let components;
      switch (jwk.kty) {
        case "EC":
          check(jwk.crv, '"crv" (Curve) Parameter');
          check(jwk.x, '"x" (X Coordinate) Parameter');
          check(jwk.y, '"y" (Y Coordinate) Parameter');
          components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
          break;
        case "OKP":
          check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
          check(jwk.x, '"x" (Public Key) Parameter');
          components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
          break;
        case "RSA":
          check(jwk.e, '"e" (Exponent) Parameter');
          check(jwk.n, '"n" (Modulus) Parameter');
          components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
          break;
        case "oct":
          check(jwk.k, '"k" (Key Value) Parameter');
          components = { k: jwk.k, kty: jwk.kty };
          break;
        default:
          throw new errors_js_1.JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
      }
      const data = buffer_utils_js_1.encoder.encode(JSON.stringify(components));
      return (0, base64url_js_1.encode)(await (0, digest_js_1.default)(digestAlgorithm, data));
    }
    exports2.calculateJwkThumbprint = calculateJwkThumbprint;
    async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
      digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
      const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
      return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
    }
    exports2.calculateJwkThumbprintUri = calculateJwkThumbprintUri;
  }
});

// ../node_modules/jose/dist/node/cjs/jwk/embedded.js
var require_embedded = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwk/embedded.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmbeddedJWK = void 0;
    var import_js_1 = require_import();
    var is_object_js_1 = require_is_object();
    var errors_js_1 = require_errors3();
    async function EmbeddedJWK(protectedHeader, token) {
      const joseHeader = {
        ...protectedHeader,
        ...token.header
      };
      if (!(0, is_object_js_1.default)(joseHeader.jwk)) {
        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
      }
      const key = await (0, import_js_1.importJWK)({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
      if (key instanceof Uint8Array || key.type !== "public") {
        throw new errors_js_1.JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
      }
      return key;
    }
    exports2.EmbeddedJWK = EmbeddedJWK;
  }
});

// ../node_modules/jose/dist/node/cjs/jwks/local.js
var require_local = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwks/local.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLocalJWKSet = exports2.LocalJWKSet = exports2.isJWKSLike = void 0;
    var import_js_1 = require_import();
    var errors_js_1 = require_errors3();
    var is_object_js_1 = require_is_object();
    function getKtyFromAlg(alg) {
      switch (typeof alg === "string" && alg.slice(0, 2)) {
        case "RS":
        case "PS":
          return "RSA";
        case "ES":
          return "EC";
        case "Ed":
          return "OKP";
        default:
          throw new errors_js_1.JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
      }
    }
    function isJWKSLike(jwks) {
      return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
    }
    exports2.isJWKSLike = isJWKSLike;
    function isJWKLike(key) {
      return (0, is_object_js_1.default)(key);
    }
    function clone(obj) {
      if (typeof structuredClone === "function") {
        return structuredClone(obj);
      }
      return JSON.parse(JSON.stringify(obj));
    }
    var LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new errors_js_1.JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new errors_js_1.JWKSNoMatchingKey();
        } else if (length !== 1) {
          throw new errors_js_1.JWKSMultipleMatchingKeys();
        }
        const cached = this._cached.get(jwk) || this._cached.set(jwk, {}).get(jwk);
        if (cached[alg] === void 0) {
          const keyObject = await (0, import_js_1.importJWK)({ ...jwk, ext: true }, alg);
          if (keyObject instanceof Uint8Array || keyObject.type !== "public") {
            throw new errors_js_1.JWKSInvalid("JSON Web Key Set members must be public keys");
          }
          cached[alg] = keyObject;
        }
        return cached[alg];
      }
    };
    exports2.LocalJWKSet = LocalJWKSet;
    function createLocalJWKSet(jwks) {
      return LocalJWKSet.prototype.getKey.bind(new LocalJWKSet(jwks));
    }
    exports2.createLocalJWKSet = createLocalJWKSet;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/fetch_jwks.js
var require_fetch_jwks = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/fetch_jwks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var http = require("http");
    var https = require("https");
    var events_1 = require("events");
    var errors_js_1 = require_errors3();
    var buffer_utils_js_1 = require_buffer_utils();
    var fetchJwks = async (url, timeout, options) => {
      let get;
      switch (url.protocol) {
        case "https:":
          get = https.get;
          break;
        case "http:":
          get = http.get;
          break;
        default:
          throw new TypeError("Unsupported URL protocol.");
      }
      const { agent, headers } = options;
      const req = get(url.href, {
        agent,
        timeout,
        headers
      });
      const [response] = await Promise.race([(0, events_1.once)(req, "response"), (0, events_1.once)(req, "timeout")]);
      if (!response) {
        req.destroy();
        throw new errors_js_1.JWKSTimeout();
      }
      if (response.statusCode !== 200) {
        throw new errors_js_1.JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      const parts = [];
      for await (const part of response) {
        parts.push(part);
      }
      try {
        return JSON.parse(buffer_utils_js_1.decoder.decode((0, buffer_utils_js_1.concat)(...parts)));
      } catch {
        throw new errors_js_1.JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    exports2.default = fetchJwks;
  }
});

// ../node_modules/jose/dist/node/cjs/jwks/remote.js
var require_remote = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwks/remote.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRemoteJWKSet = void 0;
    var fetch_jwks_js_1 = require_fetch_jwks();
    var env_js_1 = require_env();
    var errors_js_1 = require_errors3();
    var local_js_1 = require_local();
    var RemoteJWKSet = class extends local_js_1.LocalJWKSet {
      constructor(url, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof errors_js_1.JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && (0, env_js_1.isCloudflareWorkers)()) {
          return new Promise((resolve) => {
            const isDone = () => {
              if (this._pendingFetch === void 0) {
                resolve();
              } else {
                setTimeout(isDone, 5);
              }
            };
            isDone();
          });
        }
        if (!this._pendingFetch) {
          this._pendingFetch = (0, fetch_jwks_js_1.default)(this._url, this._timeoutDuration, this._options).then((json) => {
            if (!(0, local_js_1.isJWKSLike)(json)) {
              throw new errors_js_1.JWKSInvalid("JSON Web Key Set malformed");
            }
            this._jwks = { keys: json.keys };
            this._jwksTimestamp = Date.now();
            this._pendingFetch = void 0;
          }).catch((err) => {
            this._pendingFetch = void 0;
            throw err;
          });
        }
        await this._pendingFetch;
      }
    };
    function createRemoteJWKSet(url, options) {
      return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(url, options));
    }
    exports2.createRemoteJWKSet = createRemoteJWKSet;
  }
});

// ../node_modules/jose/dist/node/cjs/jwt/unsecured.js
var require_unsecured = __commonJS({
  "../node_modules/jose/dist/node/cjs/jwt/unsecured.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsecuredJWT = void 0;
    var base64url = require_base64url();
    var buffer_utils_js_1 = require_buffer_utils();
    var errors_js_1 = require_errors3();
    var jwt_claims_set_js_1 = require_jwt_claims_set();
    var produce_js_1 = require_produce();
    var UnsecuredJWT = class extends produce_js_1.ProduceJWT {
      encode() {
        const header = base64url.encode(JSON.stringify({ alg: "none" }));
        const payload = base64url.encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
      }
      static decode(jwt, options) {
        if (typeof jwt !== "string") {
          throw new errors_js_1.JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split(".");
        if (length !== 3 || signature !== "") {
          throw new errors_js_1.JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
          header = JSON.parse(buffer_utils_js_1.decoder.decode(base64url.decode(encodedHeader)));
          if (header.alg !== "none")
            throw new Error();
        } catch {
          throw new errors_js_1.JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = (0, jwt_claims_set_js_1.default)(header, base64url.decode(encodedPayload), options);
        return { payload, header };
      }
    };
    exports2.UnsecuredJWT = UnsecuredJWT;
  }
});

// ../node_modules/jose/dist/node/cjs/util/base64url.js
var require_base64url2 = __commonJS({
  "../node_modules/jose/dist/node/cjs/util/base64url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode = exports2.encode = void 0;
    var base64url = require_base64url();
    exports2.encode = base64url.encode;
    exports2.decode = base64url.decode;
  }
});

// ../node_modules/jose/dist/node/cjs/util/decode_protected_header.js
var require_decode_protected_header = __commonJS({
  "../node_modules/jose/dist/node/cjs/util/decode_protected_header.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeProtectedHeader = void 0;
    var base64url_js_1 = require_base64url2();
    var buffer_utils_js_1 = require_buffer_utils();
    var is_object_js_1 = require_is_object();
    function decodeProtectedHeader(token) {
      let protectedB64u;
      if (typeof token === "string") {
        const parts = token.split(".");
        if (parts.length === 3 || parts.length === 5) {
          ;
          [protectedB64u] = parts;
        }
      } else if (typeof token === "object" && token) {
        if ("protected" in token) {
          protectedB64u = token.protected;
        } else {
          throw new TypeError("Token does not contain a Protected Header");
        }
      }
      try {
        if (typeof protectedB64u !== "string" || !protectedB64u) {
          throw new Error();
        }
        const result = JSON.parse(buffer_utils_js_1.decoder.decode((0, base64url_js_1.decode)(protectedB64u)));
        if (!(0, is_object_js_1.default)(result)) {
          throw new Error();
        }
        return result;
      } catch {
        throw new TypeError("Invalid Token or Protected Header formatting");
      }
    }
    exports2.decodeProtectedHeader = decodeProtectedHeader;
  }
});

// ../node_modules/jose/dist/node/cjs/util/decode_jwt.js
var require_decode_jwt = __commonJS({
  "../node_modules/jose/dist/node/cjs/util/decode_jwt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeJwt = void 0;
    var base64url_js_1 = require_base64url2();
    var buffer_utils_js_1 = require_buffer_utils();
    var is_object_js_1 = require_is_object();
    var errors_js_1 = require_errors3();
    function decodeJwt(jwt) {
      if (typeof jwt !== "string")
        throw new errors_js_1.JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
      const { 1: payload, length } = jwt.split(".");
      if (length === 5)
        throw new errors_js_1.JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
      if (length !== 3)
        throw new errors_js_1.JWTInvalid("Invalid JWT");
      if (!payload)
        throw new errors_js_1.JWTInvalid("JWTs must contain a payload");
      let decoded;
      try {
        decoded = (0, base64url_js_1.decode)(payload);
      } catch {
        throw new errors_js_1.JWTInvalid("Failed to parse the base64url encoded payload");
      }
      let result;
      try {
        result = JSON.parse(buffer_utils_js_1.decoder.decode(decoded));
      } catch {
        throw new errors_js_1.JWTInvalid("Failed to parse the decoded payload as JSON");
      }
      if (!(0, is_object_js_1.default)(result))
        throw new errors_js_1.JWTInvalid("Invalid JWT Claims Set");
      return result;
    }
    exports2.decodeJwt = decodeJwt;
  }
});

// ../node_modules/jose/dist/node/cjs/runtime/generate.js
var require_generate = __commonJS({
  "../node_modules/jose/dist/node/cjs/runtime/generate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateKeyPair = exports2.generateSecret = void 0;
    var crypto_1 = require("crypto");
    var util_1 = require("util");
    var random_js_1 = require_random();
    var check_modulus_length_js_1 = require_check_modulus_length();
    var errors_js_1 = require_errors3();
    var generate = (0, util_1.promisify)(crypto_1.generateKeyPair);
    async function generateSecret(alg, options) {
      let length;
      switch (alg) {
        case "HS256":
        case "HS384":
        case "HS512":
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          length = parseInt(alg.slice(-3), 10);
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          length = parseInt(alg.slice(1, 4), 10);
          break;
        default:
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      return (0, crypto_1.createSecretKey)((0, random_js_1.default)(new Uint8Array(length >> 3)));
    }
    exports2.generateSecret = generateSecret;
    async function generateKeyPair(alg, options) {
      var _a, _b;
      switch (alg) {
        case "RS256":
        case "RS384":
        case "RS512":
        case "PS256":
        case "PS384":
        case "PS512":
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
        case "RSA1_5": {
          const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
          if (typeof modulusLength !== "number" || modulusLength < 2048) {
            throw new errors_js_1.JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
          }
          const keypair = await generate("rsa", {
            modulusLength,
            publicExponent: 65537
          });
          (0, check_modulus_length_js_1.setModulusLength)(keypair.privateKey, modulusLength);
          (0, check_modulus_length_js_1.setModulusLength)(keypair.publicKey, modulusLength);
          return keypair;
        }
        case "ES256":
          return generate("ec", { namedCurve: "P-256" });
        case "ES256K":
          return generate("ec", { namedCurve: "secp256k1" });
        case "ES384":
          return generate("ec", { namedCurve: "P-384" });
        case "ES512":
          return generate("ec", { namedCurve: "P-521" });
        case "EdDSA": {
          switch (options === null || options === void 0 ? void 0 : options.crv) {
            case void 0:
            case "Ed25519":
              return generate("ed25519");
            case "Ed448":
              return generate("ed448");
            default:
              throw new errors_js_1.JOSENotSupported("Invalid or unsupported crv option provided, supported values are Ed25519 and Ed448");
          }
        }
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          const crv = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : "P-256";
          switch (crv) {
            case void 0:
            case "P-256":
            case "P-384":
            case "P-521":
              return generate("ec", { namedCurve: crv });
            case "X25519":
              return generate("x25519");
            case "X448":
              return generate("x448");
            default:
              throw new errors_js_1.JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
          }
        default:
          throw new errors_js_1.JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
    }
    exports2.generateKeyPair = generateKeyPair;
  }
});

// ../node_modules/jose/dist/node/cjs/key/generate_key_pair.js
var require_generate_key_pair = __commonJS({
  "../node_modules/jose/dist/node/cjs/key/generate_key_pair.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateKeyPair = void 0;
    var generate_js_1 = require_generate();
    async function generateKeyPair(alg, options) {
      return (0, generate_js_1.generateKeyPair)(alg, options);
    }
    exports2.generateKeyPair = generateKeyPair;
  }
});

// ../node_modules/jose/dist/node/cjs/key/generate_secret.js
var require_generate_secret = __commonJS({
  "../node_modules/jose/dist/node/cjs/key/generate_secret.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateSecret = void 0;
    var generate_js_1 = require_generate();
    async function generateSecret(alg, options) {
      return (0, generate_js_1.generateSecret)(alg, options);
    }
    exports2.generateSecret = generateSecret;
  }
});

// ../node_modules/jose/dist/node/cjs/index.js
var require_cjs = __commonJS({
  "../node_modules/jose/dist/node/cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.base64url = exports2.generateSecret = exports2.generateKeyPair = exports2.errors = exports2.decodeJwt = exports2.decodeProtectedHeader = exports2.importJWK = exports2.importX509 = exports2.importPKCS8 = exports2.importSPKI = exports2.exportJWK = exports2.exportSPKI = exports2.exportPKCS8 = exports2.UnsecuredJWT = exports2.createRemoteJWKSet = exports2.createLocalJWKSet = exports2.EmbeddedJWK = exports2.calculateJwkThumbprintUri = exports2.calculateJwkThumbprint = exports2.EncryptJWT = exports2.SignJWT = exports2.GeneralSign = exports2.FlattenedSign = exports2.CompactSign = exports2.FlattenedEncrypt = exports2.CompactEncrypt = exports2.jwtDecrypt = exports2.jwtVerify = exports2.generalVerify = exports2.flattenedVerify = exports2.compactVerify = exports2.GeneralEncrypt = exports2.generalDecrypt = exports2.flattenedDecrypt = exports2.compactDecrypt = void 0;
    var decrypt_js_1 = require_decrypt3();
    Object.defineProperty(exports2, "compactDecrypt", { enumerable: true, get: function() {
      return decrypt_js_1.compactDecrypt;
    } });
    var decrypt_js_2 = require_decrypt2();
    Object.defineProperty(exports2, "flattenedDecrypt", { enumerable: true, get: function() {
      return decrypt_js_2.flattenedDecrypt;
    } });
    var decrypt_js_3 = require_decrypt4();
    Object.defineProperty(exports2, "generalDecrypt", { enumerable: true, get: function() {
      return decrypt_js_3.generalDecrypt;
    } });
    var encrypt_js_1 = require_encrypt4();
    Object.defineProperty(exports2, "GeneralEncrypt", { enumerable: true, get: function() {
      return encrypt_js_1.GeneralEncrypt;
    } });
    var verify_js_1 = require_verify3();
    Object.defineProperty(exports2, "compactVerify", { enumerable: true, get: function() {
      return verify_js_1.compactVerify;
    } });
    var verify_js_2 = require_verify2();
    Object.defineProperty(exports2, "flattenedVerify", { enumerable: true, get: function() {
      return verify_js_2.flattenedVerify;
    } });
    var verify_js_3 = require_verify4();
    Object.defineProperty(exports2, "generalVerify", { enumerable: true, get: function() {
      return verify_js_3.generalVerify;
    } });
    var verify_js_4 = require_verify5();
    Object.defineProperty(exports2, "jwtVerify", { enumerable: true, get: function() {
      return verify_js_4.jwtVerify;
    } });
    var decrypt_js_4 = require_decrypt5();
    Object.defineProperty(exports2, "jwtDecrypt", { enumerable: true, get: function() {
      return decrypt_js_4.jwtDecrypt;
    } });
    var encrypt_js_2 = require_encrypt5();
    Object.defineProperty(exports2, "CompactEncrypt", { enumerable: true, get: function() {
      return encrypt_js_2.CompactEncrypt;
    } });
    var encrypt_js_3 = require_encrypt3();
    Object.defineProperty(exports2, "FlattenedEncrypt", { enumerable: true, get: function() {
      return encrypt_js_3.FlattenedEncrypt;
    } });
    var sign_js_1 = require_sign3();
    Object.defineProperty(exports2, "CompactSign", { enumerable: true, get: function() {
      return sign_js_1.CompactSign;
    } });
    var sign_js_2 = require_sign2();
    Object.defineProperty(exports2, "FlattenedSign", { enumerable: true, get: function() {
      return sign_js_2.FlattenedSign;
    } });
    var sign_js_3 = require_sign4();
    Object.defineProperty(exports2, "GeneralSign", { enumerable: true, get: function() {
      return sign_js_3.GeneralSign;
    } });
    var sign_js_4 = require_sign5();
    Object.defineProperty(exports2, "SignJWT", { enumerable: true, get: function() {
      return sign_js_4.SignJWT;
    } });
    var encrypt_js_4 = require_encrypt6();
    Object.defineProperty(exports2, "EncryptJWT", { enumerable: true, get: function() {
      return encrypt_js_4.EncryptJWT;
    } });
    var thumbprint_js_1 = require_thumbprint();
    Object.defineProperty(exports2, "calculateJwkThumbprint", { enumerable: true, get: function() {
      return thumbprint_js_1.calculateJwkThumbprint;
    } });
    Object.defineProperty(exports2, "calculateJwkThumbprintUri", { enumerable: true, get: function() {
      return thumbprint_js_1.calculateJwkThumbprintUri;
    } });
    var embedded_js_1 = require_embedded();
    Object.defineProperty(exports2, "EmbeddedJWK", { enumerable: true, get: function() {
      return embedded_js_1.EmbeddedJWK;
    } });
    var local_js_1 = require_local();
    Object.defineProperty(exports2, "createLocalJWKSet", { enumerable: true, get: function() {
      return local_js_1.createLocalJWKSet;
    } });
    var remote_js_1 = require_remote();
    Object.defineProperty(exports2, "createRemoteJWKSet", { enumerable: true, get: function() {
      return remote_js_1.createRemoteJWKSet;
    } });
    var unsecured_js_1 = require_unsecured();
    Object.defineProperty(exports2, "UnsecuredJWT", { enumerable: true, get: function() {
      return unsecured_js_1.UnsecuredJWT;
    } });
    var export_js_1 = require_export();
    Object.defineProperty(exports2, "exportPKCS8", { enumerable: true, get: function() {
      return export_js_1.exportPKCS8;
    } });
    Object.defineProperty(exports2, "exportSPKI", { enumerable: true, get: function() {
      return export_js_1.exportSPKI;
    } });
    Object.defineProperty(exports2, "exportJWK", { enumerable: true, get: function() {
      return export_js_1.exportJWK;
    } });
    var import_js_1 = require_import();
    Object.defineProperty(exports2, "importSPKI", { enumerable: true, get: function() {
      return import_js_1.importSPKI;
    } });
    Object.defineProperty(exports2, "importPKCS8", { enumerable: true, get: function() {
      return import_js_1.importPKCS8;
    } });
    Object.defineProperty(exports2, "importX509", { enumerable: true, get: function() {
      return import_js_1.importX509;
    } });
    Object.defineProperty(exports2, "importJWK", { enumerable: true, get: function() {
      return import_js_1.importJWK;
    } });
    var decode_protected_header_js_1 = require_decode_protected_header();
    Object.defineProperty(exports2, "decodeProtectedHeader", { enumerable: true, get: function() {
      return decode_protected_header_js_1.decodeProtectedHeader;
    } });
    var decode_jwt_js_1 = require_decode_jwt();
    Object.defineProperty(exports2, "decodeJwt", { enumerable: true, get: function() {
      return decode_jwt_js_1.decodeJwt;
    } });
    exports2.errors = require_errors3();
    var generate_key_pair_js_1 = require_generate_key_pair();
    Object.defineProperty(exports2, "generateKeyPair", { enumerable: true, get: function() {
      return generate_key_pair_js_1.generateKeyPair;
    } });
    var generate_secret_js_1 = require_generate_secret();
    Object.defineProperty(exports2, "generateSecret", { enumerable: true, get: function() {
      return generate_secret_js_1.generateSecret;
    } });
    exports2.base64url = require_base64url2();
  }
});

// ../node_modules/prismarine-auth/src/TokenManagers/XboxTokenManager.js
var require_XboxTokenManager = __commonJS({
  "../node_modules/prismarine-auth/src/TokenManagers/XboxTokenManager.js"(exports2, module2) {
    var crypto = require("crypto");
    var XboxLiveAuth = require_dist3();
    var debug = require_src()("prismarine-auth");
    var { SmartBuffer } = require_smartbuffer();
    var { exportJWK } = require_cjs();
    var fetch = require_lib2();
    var { Endpoints, xboxLiveErrors } = require_Constants();
    var { checkStatus, createHash } = require_Util();
    var UUID = require_uuid_1345();
    var nextUUID = () => UUID.v3({ namespace: "6ba7b811-9dad-11d1-80b4-00c04fd430c8", name: Date.now().toString() });
    var XboxTokenManager = class {
      constructor(ecKey, cache) {
        this.key = ecKey;
        exportJWK(ecKey.publicKey).then((jwk) => {
          this.jwk = { ...jwk, alg: "ES256", use: "sig" };
        });
        this.cache = cache;
        this.headers = { "Cache-Control": "no-store, must-revalidate, no-cache", "x-xbl-contract-version": 1 };
      }
      async getCachedUserToken() {
        const { userToken: token } = await this.cache.getCached();
        if (!token)
          return;
        const until = new Date(token.NotAfter);
        const dn = Date.now();
        const remainingMs = until - dn;
        const valid = remainingMs > 1e3;
        return { valid, token: token.Token, data: token };
      }
      async getCachedXstsToken(relyingParty) {
        const key = createHash(relyingParty);
        const { [key]: token } = await this.cache.getCached();
        if (!token)
          return;
        const until = new Date(token.expiresOn);
        const dn = Date.now();
        const remainingMs = until - dn;
        const valid = remainingMs > 1e3;
        return { valid, token: token.XSTSToken, data: token };
      }
      async setCachedUserToken(data) {
        await this.cache.setCachedPartial({ userToken: data });
      }
      async setCachedXstsToken(data, relyingParty) {
        const key = createHash(relyingParty);
        await this.cache.setCachedPartial({ [key]: data });
      }
      checkTokenError(errorCode, response) {
        if (errorCode in xboxLiveErrors)
          throw new Error(xboxLiveErrors[errorCode]);
        else
          throw new Error(`Xbox Live authentication failed to obtain a XSTS token. XErr: ${errorCode}
${JSON.stringify(response)}`);
      }
      async verifyTokens(relyingParty) {
        const ut = await this.getCachedUserToken();
        const xt = await this.getCachedXstsToken(relyingParty);
        if (!ut || !xt || this.forceRefresh) {
          return false;
        }
        debug("[xbl] have user, xsts", ut, xt);
        if (ut.valid && xt.valid) {
          return true;
        } else if (ut.valid && !xt.valid) {
          try {
            await this.getXSTSToken({ userToken: ut.token }, { relyingParty });
            return true;
          } catch (e) {
            return false;
          }
        }
        return false;
      }
      async getUserToken(accessToken, azure) {
        debug("[xbl] obtaining xbox token with ms token", accessToken);
        const preamble = azure ? "d=" : "t=";
        const payload = {
          RelyingParty: "http://auth.xboxlive.com",
          TokenType: "JWT",
          Properties: {
            AuthMethod: "RPS",
            SiteName: "user.auth.xboxlive.com",
            RpsTicket: `${preamble}${accessToken}`
          }
        };
        const body = JSON.stringify(payload);
        const signature = this.sign(Endpoints.XboxUserAuth, "", body).toString("base64");
        const headers = { ...this.headers, signature, "Content-Type": "application/json", accept: "application/json", "x-xbl-contract-version": "2" };
        const ret = await fetch(Endpoints.XboxUserAuth, { method: "post", headers, body }).then(checkStatus);
        await this.setCachedUserToken(ret);
        debug("[xbl] user token:", ret);
        return ret.Token;
      }
      sign(url, authorizationToken, payload) {
        const windowsTimestamp = (BigInt(Date.now() / 1e3 | 0) + 11644473600n) * 10000000n;
        const pathAndQuery = new URL(url).pathname;
        const allocSize = 5 + 9 + 5 + pathAndQuery.length + 1 + authorizationToken.length + 1 + payload.length + 1;
        const buf = SmartBuffer.fromSize(allocSize);
        buf.writeInt32BE(1);
        buf.writeUInt8(0);
        buf.writeBigUInt64BE(windowsTimestamp);
        buf.writeUInt8(0);
        buf.writeStringNT("POST");
        buf.writeStringNT(pathAndQuery);
        buf.writeStringNT(authorizationToken);
        buf.writeStringNT(payload);
        const signature = crypto.sign("SHA256", buf.toBuffer(), { key: this.key.privateKey, dsaEncoding: "ieee-p1363" });
        const header = SmartBuffer.fromSize(signature.length + 12);
        header.writeInt32BE(1);
        header.writeBigUInt64BE(windowsTimestamp);
        header.writeBuffer(signature);
        return header.toBuffer();
      }
      async doReplayAuth(email, password, options = {}) {
        try {
          const preAuthResponse = await XboxLiveAuth.preAuth();
          const logUserResponse = await XboxLiveAuth.logUser(preAuthResponse, { email, password });
          const xblUserToken = await XboxLiveAuth.exchangeRpsTicketForUserToken(logUserResponse.access_token);
          await this.setCachedUserToken(xblUserToken);
          debug("[xbl] user token:", xblUserToken);
          const xsts = await this.getXSTSToken({ userToken: xblUserToken.Token }, options);
          return xsts;
        } catch (error) {
          debug("Authentication using a password has failed.");
          debug(error);
          throw error;
        }
      }
      async doSisuAuth(accessToken, deviceToken, options = {}) {
        const payload = {
          AccessToken: "t=" + accessToken,
          AppId: options.authTitle,
          DeviceToken: deviceToken,
          Sandbox: "RETAIL",
          UseModernGamertag: true,
          SiteName: "user.auth.xboxlive.com",
          RelyingParty: options.relyingParty,
          ProofKey: this.jwk
        };
        const body = JSON.stringify(payload);
        const signature = this.sign(Endpoints.SisuAuthorize, "", body).toString("base64");
        const headers = { Signature: signature };
        const req = await fetch(Endpoints.SisuAuthorize, { method: "post", headers, body });
        const ret = await req.json();
        if (!req.ok)
          this.checkTokenError(parseInt(req.headers.get("x-err")), ret);
        debug("Sisu Auth Response", ret);
        const xsts = {
          userXUID: ret.AuthorizationToken.DisplayClaims.xui[0].xid || null,
          userHash: ret.AuthorizationToken.DisplayClaims.xui[0].uhs,
          XSTSToken: ret.AuthorizationToken.Token,
          expiresOn: ret.AuthorizationToken.NotAfter
        };
        await this.setCachedXstsToken(xsts, options.relyingParty);
        debug("[xbl] xsts", xsts);
        return xsts;
      }
      async getXSTSToken(tokens, options = {}) {
        debug("[xbl] obtaining xsts token", { userToken: tokens.userToken, deviceToken: tokens.deviceToken, titleToken: tokens.titleToken });
        const payload = {
          RelyingParty: options.relyingParty,
          TokenType: "JWT",
          Properties: {
            UserTokens: [tokens.userToken],
            DeviceToken: tokens.deviceToken,
            TitleToken: tokens.titleToken,
            OptionalDisplayClaims: options.optionalDisplayClaims,
            ProofKey: this.jwk,
            SandboxId: "RETAIL"
          }
        };
        const body = JSON.stringify(payload);
        const signature = this.sign(Endpoints.XstsAuthorize, "", body).toString("base64");
        const headers = { ...this.headers, Signature: signature };
        const req = await fetch(Endpoints.XstsAuthorize, { method: "post", headers, body });
        const ret = await req.json();
        if (!req.ok)
          this.checkTokenError(ret.XErr, ret);
        const xsts = {
          userXUID: ret.DisplayClaims.xui[0].xid || null,
          userHash: ret.DisplayClaims.xui[0].uhs,
          XSTSToken: ret.Token,
          expiresOn: ret.NotAfter
        };
        await this.setCachedXstsToken(xsts, options.relyingParty);
        debug("[xbl] xsts", xsts);
        return xsts;
      }
      async getDeviceToken(asDevice) {
        const payload = {
          Properties: {
            AuthMethod: "ProofOfPossession",
            Id: `{${nextUUID()}}`,
            DeviceType: asDevice.deviceType || "Nintendo",
            SerialNumber: `{${nextUUID()}}`,
            Version: asDevice.deviceVersion || "0.0.0",
            ProofKey: this.jwk
          },
          RelyingParty: "http://auth.xboxlive.com",
          TokenType: "JWT"
        };
        const body = JSON.stringify(payload);
        const signature = this.sign(Endpoints.XboxDeviceAuth, "", body).toString("base64");
        const headers = { ...this.headers, Signature: signature };
        const ret = await fetch(Endpoints.XboxDeviceAuth, { method: "post", headers, body }).then(checkStatus);
        debug("Xbox Device Token", ret);
        return ret.Token;
      }
      async getTitleToken(msaAccessToken, deviceToken) {
        const payload = {
          Properties: {
            AuthMethod: "RPS",
            DeviceToken: deviceToken,
            RpsTicket: "t=" + msaAccessToken,
            SiteName: "user.auth.xboxlive.com",
            ProofKey: this.jwk
          },
          RelyingParty: "http://auth.xboxlive.com",
          TokenType: "JWT"
        };
        const body = JSON.stringify(payload);
        const signature = this.sign(Endpoints.XboxTitleAuth, "", body).toString("base64");
        const headers = { ...this.headers, Signature: signature };
        const ret = await fetch(Endpoints.XboxTitleAuth, { method: "post", headers, body }).then(checkStatus);
        debug("Xbox Title Token", ret);
        return ret.Token;
      }
    };
    module2.exports = XboxTokenManager;
  }
});

// ../node_modules/@azure/msal-common/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "../node_modules/@azure/msal-common/dist/index.cjs.js"(exports2) {
    "use strict";
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }
    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    }
    var Constants = {
      LIBRARY_NAME: "MSAL.JS",
      SKU: "msal.js.common",
      CACHE_PREFIX: "msal",
      DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
      DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
      DEFAULT_COMMON_TENANT: "common",
      ADFS: "adfs",
      AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
      RESOURCE_DELIM: "|",
      NO_ACCOUNT: "NO_ACCOUNT",
      CLAIMS: "claims",
      CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
      OPENID_SCOPE: "openid",
      PROFILE_SCOPE: "profile",
      OFFLINE_ACCESS_SCOPE: "offline_access",
      EMAIL_SCOPE: "email",
      CODE_RESPONSE_TYPE: "code",
      CODE_GRANT_TYPE: "authorization_code",
      RT_GRANT_TYPE: "refresh_token",
      FRAGMENT_RESPONSE_MODE: "fragment",
      S256_CODE_CHALLENGE_METHOD: "S256",
      URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
      AUTHORIZATION_PENDING: "authorization_pending",
      NOT_DEFINED: "not_defined",
      EMPTY_STRING: "",
      FORWARD_SLASH: "/",
      IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
      IMDS_VERSION: "2020-06-01",
      IMDS_TIMEOUT: 2e3,
      AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
      REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
      KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"],
      TOKEN_RESPONSE_TYPE: "token",
      ID_TOKEN_RESPONSE_TYPE: "id_token",
      SHR_NONCE_VALIDITY: 240
    };
    var OIDC_DEFAULT_SCOPES = [
      Constants.OPENID_SCOPE,
      Constants.PROFILE_SCOPE,
      Constants.OFFLINE_ACCESS_SCOPE
    ];
    var OIDC_SCOPES = __spreadArrays(OIDC_DEFAULT_SCOPES, [
      Constants.EMAIL_SCOPE
    ]);
    var HeaderNames;
    (function(HeaderNames2) {
      HeaderNames2["CONTENT_TYPE"] = "Content-Type";
      HeaderNames2["RETRY_AFTER"] = "Retry-After";
      HeaderNames2["CCS_HEADER"] = "X-AnchorMailbox";
      HeaderNames2["WWWAuthenticate"] = "WWW-Authenticate";
      HeaderNames2["AuthenticationInfo"] = "Authentication-Info";
    })(HeaderNames || (HeaderNames = {}));
    exports2.PersistentCacheKeys = void 0;
    (function(PersistentCacheKeys) {
      PersistentCacheKeys["ID_TOKEN"] = "idtoken";
      PersistentCacheKeys["CLIENT_INFO"] = "client.info";
      PersistentCacheKeys["ADAL_ID_TOKEN"] = "adal.idtoken";
      PersistentCacheKeys["ERROR"] = "error";
      PersistentCacheKeys["ERROR_DESC"] = "error.description";
      PersistentCacheKeys["ACTIVE_ACCOUNT"] = "active-account";
      PersistentCacheKeys["ACTIVE_ACCOUNT_FILTERS"] = "active-account-filters";
    })(exports2.PersistentCacheKeys || (exports2.PersistentCacheKeys = {}));
    var AADAuthorityConstants;
    (function(AADAuthorityConstants2) {
      AADAuthorityConstants2["COMMON"] = "common";
      AADAuthorityConstants2["ORGANIZATIONS"] = "organizations";
      AADAuthorityConstants2["CONSUMERS"] = "consumers";
    })(AADAuthorityConstants || (AADAuthorityConstants = {}));
    var AADServerParamKeys;
    (function(AADServerParamKeys2) {
      AADServerParamKeys2["CLIENT_ID"] = "client_id";
      AADServerParamKeys2["REDIRECT_URI"] = "redirect_uri";
      AADServerParamKeys2["RESPONSE_TYPE"] = "response_type";
      AADServerParamKeys2["RESPONSE_MODE"] = "response_mode";
      AADServerParamKeys2["GRANT_TYPE"] = "grant_type";
      AADServerParamKeys2["CLAIMS"] = "claims";
      AADServerParamKeys2["SCOPE"] = "scope";
      AADServerParamKeys2["ERROR"] = "error";
      AADServerParamKeys2["ERROR_DESCRIPTION"] = "error_description";
      AADServerParamKeys2["ACCESS_TOKEN"] = "access_token";
      AADServerParamKeys2["ID_TOKEN"] = "id_token";
      AADServerParamKeys2["REFRESH_TOKEN"] = "refresh_token";
      AADServerParamKeys2["EXPIRES_IN"] = "expires_in";
      AADServerParamKeys2["STATE"] = "state";
      AADServerParamKeys2["NONCE"] = "nonce";
      AADServerParamKeys2["PROMPT"] = "prompt";
      AADServerParamKeys2["SESSION_STATE"] = "session_state";
      AADServerParamKeys2["CLIENT_INFO"] = "client_info";
      AADServerParamKeys2["CODE"] = "code";
      AADServerParamKeys2["CODE_CHALLENGE"] = "code_challenge";
      AADServerParamKeys2["CODE_CHALLENGE_METHOD"] = "code_challenge_method";
      AADServerParamKeys2["CODE_VERIFIER"] = "code_verifier";
      AADServerParamKeys2["CLIENT_REQUEST_ID"] = "client-request-id";
      AADServerParamKeys2["X_CLIENT_SKU"] = "x-client-SKU";
      AADServerParamKeys2["X_CLIENT_VER"] = "x-client-VER";
      AADServerParamKeys2["X_CLIENT_OS"] = "x-client-OS";
      AADServerParamKeys2["X_CLIENT_CPU"] = "x-client-CPU";
      AADServerParamKeys2["X_CLIENT_CURR_TELEM"] = "x-client-current-telemetry";
      AADServerParamKeys2["X_CLIENT_LAST_TELEM"] = "x-client-last-telemetry";
      AADServerParamKeys2["X_MS_LIB_CAPABILITY"] = "x-ms-lib-capability";
      AADServerParamKeys2["X_APP_NAME"] = "x-app-name";
      AADServerParamKeys2["X_APP_VER"] = "x-app-ver";
      AADServerParamKeys2["POST_LOGOUT_URI"] = "post_logout_redirect_uri";
      AADServerParamKeys2["ID_TOKEN_HINT"] = "id_token_hint";
      AADServerParamKeys2["DEVICE_CODE"] = "device_code";
      AADServerParamKeys2["CLIENT_SECRET"] = "client_secret";
      AADServerParamKeys2["CLIENT_ASSERTION"] = "client_assertion";
      AADServerParamKeys2["CLIENT_ASSERTION_TYPE"] = "client_assertion_type";
      AADServerParamKeys2["TOKEN_TYPE"] = "token_type";
      AADServerParamKeys2["REQ_CNF"] = "req_cnf";
      AADServerParamKeys2["OBO_ASSERTION"] = "assertion";
      AADServerParamKeys2["REQUESTED_TOKEN_USE"] = "requested_token_use";
      AADServerParamKeys2["ON_BEHALF_OF"] = "on_behalf_of";
      AADServerParamKeys2["FOCI"] = "foci";
      AADServerParamKeys2["CCS_HEADER"] = "X-AnchorMailbox";
      AADServerParamKeys2["RETURN_SPA_CODE"] = "return_spa_code";
      AADServerParamKeys2["NATIVE_BROKER"] = "nativebroker";
      AADServerParamKeys2["LOGOUT_HINT"] = "logout_hint";
    })(AADServerParamKeys || (AADServerParamKeys = {}));
    var ClaimsRequestKeys;
    (function(ClaimsRequestKeys2) {
      ClaimsRequestKeys2["ACCESS_TOKEN"] = "access_token";
      ClaimsRequestKeys2["XMS_CC"] = "xms_cc";
    })(ClaimsRequestKeys || (ClaimsRequestKeys = {}));
    var PromptValue = {
      LOGIN: "login",
      SELECT_ACCOUNT: "select_account",
      CONSENT: "consent",
      NONE: "none",
      CREATE: "create"
    };
    var SSOTypes;
    (function(SSOTypes2) {
      SSOTypes2["ACCOUNT"] = "account";
      SSOTypes2["SID"] = "sid";
      SSOTypes2["LOGIN_HINT"] = "login_hint";
      SSOTypes2["ID_TOKEN"] = "id_token";
      SSOTypes2["DOMAIN_HINT"] = "domain_hint";
      SSOTypes2["ORGANIZATIONS"] = "organizations";
      SSOTypes2["CONSUMERS"] = "consumers";
      SSOTypes2["ACCOUNT_ID"] = "accountIdentifier";
      SSOTypes2["HOMEACCOUNT_ID"] = "homeAccountIdentifier";
    })(SSOTypes || (SSOTypes = {}));
    [
      SSOTypes.SID,
      SSOTypes.LOGIN_HINT
    ];
    var CodeChallengeMethodValues = {
      PLAIN: "plain",
      S256: "S256"
    };
    [
      CodeChallengeMethodValues.PLAIN,
      CodeChallengeMethodValues.S256
    ];
    exports2.ResponseMode = void 0;
    (function(ResponseMode) {
      ResponseMode["QUERY"] = "query";
      ResponseMode["FRAGMENT"] = "fragment";
      ResponseMode["FORM_POST"] = "form_post";
    })(exports2.ResponseMode || (exports2.ResponseMode = {}));
    var GrantType;
    (function(GrantType2) {
      GrantType2["IMPLICIT_GRANT"] = "implicit";
      GrantType2["AUTHORIZATION_CODE_GRANT"] = "authorization_code";
      GrantType2["CLIENT_CREDENTIALS_GRANT"] = "client_credentials";
      GrantType2["RESOURCE_OWNER_PASSWORD_GRANT"] = "password";
      GrantType2["REFRESH_TOKEN_GRANT"] = "refresh_token";
      GrantType2["DEVICE_CODE_GRANT"] = "device_code";
      GrantType2["JWT_BEARER"] = "urn:ietf:params:oauth:grant-type:jwt-bearer";
    })(GrantType || (GrantType = {}));
    exports2.CacheAccountType = void 0;
    (function(CacheAccountType) {
      CacheAccountType["MSSTS_ACCOUNT_TYPE"] = "MSSTS";
      CacheAccountType["ADFS_ACCOUNT_TYPE"] = "ADFS";
      CacheAccountType["MSAV1_ACCOUNT_TYPE"] = "MSA";
      CacheAccountType["GENERIC_ACCOUNT_TYPE"] = "Generic";
    })(exports2.CacheAccountType || (exports2.CacheAccountType = {}));
    var Separators;
    (function(Separators2) {
      Separators2["CACHE_KEY_SEPARATOR"] = "-";
      Separators2["CLIENT_INFO_SEPARATOR"] = ".";
    })(Separators || (Separators = {}));
    exports2.CredentialType = void 0;
    (function(CredentialType) {
      CredentialType["ID_TOKEN"] = "IdToken";
      CredentialType["ACCESS_TOKEN"] = "AccessToken";
      CredentialType["ACCESS_TOKEN_WITH_AUTH_SCHEME"] = "AccessToken_With_AuthScheme";
      CredentialType["REFRESH_TOKEN"] = "RefreshToken";
    })(exports2.CredentialType || (exports2.CredentialType = {}));
    exports2.CacheSchemaType = void 0;
    (function(CacheSchemaType) {
      CacheSchemaType["ACCOUNT"] = "Account";
      CacheSchemaType["CREDENTIAL"] = "Credential";
      CacheSchemaType["ID_TOKEN"] = "IdToken";
      CacheSchemaType["ACCESS_TOKEN"] = "AccessToken";
      CacheSchemaType["REFRESH_TOKEN"] = "RefreshToken";
      CacheSchemaType["APP_METADATA"] = "AppMetadata";
      CacheSchemaType["TEMPORARY"] = "TempCache";
      CacheSchemaType["TELEMETRY"] = "Telemetry";
      CacheSchemaType["UNDEFINED"] = "Undefined";
      CacheSchemaType["THROTTLING"] = "Throttling";
    })(exports2.CacheSchemaType || (exports2.CacheSchemaType = {}));
    exports2.CacheType = void 0;
    (function(CacheType) {
      CacheType[CacheType["ADFS"] = 1001] = "ADFS";
      CacheType[CacheType["MSA"] = 1002] = "MSA";
      CacheType[CacheType["MSSTS"] = 1003] = "MSSTS";
      CacheType[CacheType["GENERIC"] = 1004] = "GENERIC";
      CacheType[CacheType["ACCESS_TOKEN"] = 2001] = "ACCESS_TOKEN";
      CacheType[CacheType["REFRESH_TOKEN"] = 2002] = "REFRESH_TOKEN";
      CacheType[CacheType["ID_TOKEN"] = 2003] = "ID_TOKEN";
      CacheType[CacheType["APP_METADATA"] = 3001] = "APP_METADATA";
      CacheType[CacheType["UNDEFINED"] = 9999] = "UNDEFINED";
    })(exports2.CacheType || (exports2.CacheType = {}));
    var APP_METADATA = "appmetadata";
    var CLIENT_INFO = "client_info";
    var THE_FAMILY_ID = "1";
    var AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: "authority-metadata",
      REFRESH_TIME_SECONDS: 3600 * 24
    };
    var AuthorityMetadataSource;
    (function(AuthorityMetadataSource2) {
      AuthorityMetadataSource2["CONFIG"] = "config";
      AuthorityMetadataSource2["CACHE"] = "cache";
      AuthorityMetadataSource2["NETWORK"] = "network";
      AuthorityMetadataSource2["HARDCODED_VALUES"] = "hardcoded_values";
    })(AuthorityMetadataSource || (AuthorityMetadataSource = {}));
    var SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5,
      MAX_CUR_HEADER_BYTES: 80,
      MAX_LAST_HEADER_BYTES: 330,
      MAX_CACHED_ERRORS: 50,
      CACHE_KEY: "server-telemetry",
      CATEGORY_SEPARATOR: "|",
      VALUE_SEPARATOR: ",",
      OVERFLOW_TRUE: "1",
      OVERFLOW_FALSE: "0",
      UNKNOWN_ERROR: "unknown_error"
    };
    exports2.AuthenticationScheme = void 0;
    (function(AuthenticationScheme) {
      AuthenticationScheme["BEARER"] = "Bearer";
      AuthenticationScheme["POP"] = "pop";
      AuthenticationScheme["SSH"] = "ssh-cert";
    })(exports2.AuthenticationScheme || (exports2.AuthenticationScheme = {}));
    var ThrottlingConstants = {
      DEFAULT_THROTTLE_TIME_SECONDS: 60,
      DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
      THROTTLING_PREFIX: "throttling",
      X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
    };
    var Errors = {
      INVALID_GRANT_ERROR: "invalid_grant",
      CLIENT_MISMATCH_ERROR: "client_mismatch"
    };
    var PasswordGrantConstants;
    (function(PasswordGrantConstants2) {
      PasswordGrantConstants2["username"] = "username";
      PasswordGrantConstants2["password"] = "password";
    })(PasswordGrantConstants || (PasswordGrantConstants = {}));
    var ResponseCodes;
    (function(ResponseCodes2) {
      ResponseCodes2[ResponseCodes2["httpSuccess"] = 200] = "httpSuccess";
      ResponseCodes2[ResponseCodes2["httpBadRequest"] = 400] = "httpBadRequest";
    })(ResponseCodes || (ResponseCodes = {}));
    var RegionDiscoverySources;
    (function(RegionDiscoverySources2) {
      RegionDiscoverySources2["FAILED_AUTO_DETECTION"] = "1";
      RegionDiscoverySources2["INTERNAL_CACHE"] = "2";
      RegionDiscoverySources2["ENVIRONMENT_VARIABLE"] = "3";
      RegionDiscoverySources2["IMDS"] = "4";
    })(RegionDiscoverySources || (RegionDiscoverySources = {}));
    var RegionDiscoveryOutcomes;
    (function(RegionDiscoveryOutcomes2) {
      RegionDiscoveryOutcomes2["CONFIGURED_MATCHES_DETECTED"] = "1";
      RegionDiscoveryOutcomes2["CONFIGURED_NO_AUTO_DETECTION"] = "2";
      RegionDiscoveryOutcomes2["CONFIGURED_NOT_DETECTED"] = "3";
      RegionDiscoveryOutcomes2["AUTO_DETECTION_REQUESTED_SUCCESSFUL"] = "4";
      RegionDiscoveryOutcomes2["AUTO_DETECTION_REQUESTED_FAILED"] = "5";
    })(RegionDiscoveryOutcomes || (RegionDiscoveryOutcomes = {}));
    var CacheOutcome;
    (function(CacheOutcome2) {
      CacheOutcome2["NO_CACHE_HIT"] = "0";
      CacheOutcome2["FORCE_REFRESH"] = "1";
      CacheOutcome2["NO_CACHED_ACCESS_TOKEN"] = "2";
      CacheOutcome2["CACHED_ACCESS_TOKEN_EXPIRED"] = "3";
      CacheOutcome2["REFRESH_CACHED_ACCESS_TOKEN"] = "4";
    })(CacheOutcome || (CacheOutcome = {}));
    var JsonTypes;
    (function(JsonTypes2) {
      JsonTypes2["Jwt"] = "JWT";
      JsonTypes2["Jwk"] = "JWK";
    })(JsonTypes || (JsonTypes = {}));
    var AuthErrorMessage = {
      unexpectedError: {
        code: "unexpected_error",
        desc: "Unexpected error in authentication."
      },
      postRequestFailed: {
        code: "post_request_failed",
        desc: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
      }
    };
    var AuthError = function(_super) {
      __extends(AuthError2, _super);
      function AuthError2(errorCode, errorMessage, suberror) {
        var _this = this;
        var errorString = errorMessage ? errorCode + ": " + errorMessage : errorCode;
        _this = _super.call(this, errorString) || this;
        Object.setPrototypeOf(_this, AuthError2.prototype);
        _this.errorCode = errorCode || Constants.EMPTY_STRING;
        _this.errorMessage = errorMessage || Constants.EMPTY_STRING;
        _this.subError = suberror || Constants.EMPTY_STRING;
        _this.name = "AuthError";
        return _this;
      }
      AuthError2.prototype.setCorrelationId = function(correlationId) {
        this.correlationId = correlationId;
      };
      AuthError2.createUnexpectedError = function(errDesc) {
        return new AuthError2(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
      };
      AuthError2.createPostRequestFailed = function(errDesc) {
        return new AuthError2(AuthErrorMessage.postRequestFailed.code, AuthErrorMessage.postRequestFailed.desc + ": " + errDesc);
      };
      return AuthError2;
    }(Error);
    var DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: function() {
        var notImplErr = "Crypto interface - createNewGuid() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      },
      base64Decode: function() {
        var notImplErr = "Crypto interface - base64Decode() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      },
      base64Encode: function() {
        var notImplErr = "Crypto interface - base64Encode() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      },
      generatePkceCodes: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Crypto interface - generatePkceCodes() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      getPublicKeyThumbprint: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Crypto interface - getPublicKeyThumbprint() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      removeTokenBindingKey: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Crypto interface - removeTokenBindingKey() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      clearKeystore: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Crypto interface - clearKeystore() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      signJwt: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Crypto interface - signJwt() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      hashString: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Crypto interface - hashString() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      }
    };
    var ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: "client_info_decoding_error",
        desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
      },
      clientInfoEmptyError: {
        code: "client_info_empty_error",
        desc: "The client info was empty. Please review the trace to determine the root cause."
      },
      tokenParsingError: {
        code: "token_parsing_error",
        desc: "Token cannot be parsed. Please review stack trace to determine root cause."
      },
      nullOrEmptyToken: {
        code: "null_or_empty_token",
        desc: "The token is null or empty. Please review the trace to determine the root cause."
      },
      endpointResolutionError: {
        code: "endpoints_resolution_error",
        desc: "Error: could not resolve endpoints. Please check network and try again."
      },
      networkError: {
        code: "network_error",
        desc: "Network request failed. Please check network trace to determine root cause."
      },
      unableToGetOpenidConfigError: {
        code: "openid_config_error",
        desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
      },
      hashNotDeserialized: {
        code: "hash_not_deserialized",
        desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
      },
      blankGuidGenerated: {
        code: "blank_guid_generated",
        desc: "The guid generated was blank. Please review the trace to determine the root cause."
      },
      invalidStateError: {
        code: "invalid_state",
        desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
      },
      stateMismatchError: {
        code: "state_mismatch",
        desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
      },
      stateNotFoundError: {
        code: "state_not_found",
        desc: "State not found"
      },
      nonceMismatchError: {
        code: "nonce_mismatch",
        desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
      },
      nonceNotFoundError: {
        code: "nonce_not_found",
        desc: "nonce not found"
      },
      noTokensFoundError: {
        code: "no_tokens_found",
        desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
      },
      multipleMatchingTokens: {
        code: "multiple_matching_tokens",
        desc: "The cache contains multiple tokens satisfying the requirements. Call AcquireToken again providing more requirements such as authority or account."
      },
      multipleMatchingAccounts: {
        code: "multiple_matching_accounts",
        desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
      },
      multipleMatchingAppMetadata: {
        code: "multiple_matching_appMetadata",
        desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
      },
      tokenRequestCannotBeMade: {
        code: "request_cannot_be_made",
        desc: "Token request cannot be made without authorization code or refresh token."
      },
      appendEmptyScopeError: {
        code: "cannot_append_empty_scope",
        desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
      },
      removeEmptyScopeError: {
        code: "cannot_remove_empty_scope",
        desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
      },
      appendScopeSetError: {
        code: "cannot_append_scopeset",
        desc: "Cannot append ScopeSet due to error."
      },
      emptyInputScopeSetError: {
        code: "empty_input_scopeset",
        desc: "Empty input ScopeSet cannot be processed."
      },
      DeviceCodePollingCancelled: {
        code: "device_code_polling_cancelled",
        desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
      },
      DeviceCodeExpired: {
        code: "device_code_expired",
        desc: "Device code is expired."
      },
      DeviceCodeUnknownError: {
        code: "device_code_unknown_error",
        desc: "Device code stopped polling for unknown reasons."
      },
      NoAccountInSilentRequest: {
        code: "no_account_in_silent_request",
        desc: "Please pass an account object, silent flow is not supported without account information"
      },
      invalidCacheRecord: {
        code: "invalid_cache_record",
        desc: "Cache record object was null or undefined."
      },
      invalidCacheEnvironment: {
        code: "invalid_cache_environment",
        desc: "Invalid environment when attempting to create cache entry"
      },
      noAccountFound: {
        code: "no_account_found",
        desc: "No account found in cache for given key."
      },
      CachePluginError: {
        code: "no cache plugin set on CacheManager",
        desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
      },
      noCryptoObj: {
        code: "no_crypto_object",
        desc: "No crypto object detected. This is required for the following operation: "
      },
      invalidCacheType: {
        code: "invalid_cache_type",
        desc: "Invalid cache type"
      },
      unexpectedAccountType: {
        code: "unexpected_account_type",
        desc: "Unexpected account type."
      },
      unexpectedCredentialType: {
        code: "unexpected_credential_type",
        desc: "Unexpected credential type."
      },
      invalidAssertion: {
        code: "invalid_assertion",
        desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
      },
      invalidClientCredential: {
        code: "invalid_client_credential",
        desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
      },
      tokenRefreshRequired: {
        code: "token_refresh_required",
        desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
      },
      userTimeoutReached: {
        code: "user_timeout_reached",
        desc: "User defined timeout for device code polling reached"
      },
      tokenClaimsRequired: {
        code: "token_claims_cnf_required_for_signedjwt",
        desc: "Cannot generate a POP jwt if the token_claims are not populated"
      },
      noAuthorizationCodeFromServer: {
        code: "authorization_code_missing_from_server_response",
        desc: "Server response does not contain an authorization code to proceed"
      },
      noAzureRegionDetected: {
        code: "no_azure_region_detected",
        desc: "No azure region was detected and no fallback was made available"
      },
      accessTokenEntityNullError: {
        code: "access_token_entity_null",
        desc: "Access token entity is null, please check logs and cache to ensure a valid access token is present."
      },
      bindingKeyNotRemovedError: {
        code: "binding_key_not_removed",
        desc: "Could not remove the credential's binding key from storage."
      },
      logoutNotSupported: {
        code: "end_session_endpoint_not_supported",
        desc: "Provided authority does not support logout."
      },
      keyIdMissing: {
        code: "key_id_missing",
        desc: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key."
      }
    };
    var ClientAuthError = function(_super) {
      __extends(ClientAuthError2, _super);
      function ClientAuthError2(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientAuthError";
        Object.setPrototypeOf(_this, ClientAuthError2.prototype);
        return _this;
      }
      ClientAuthError2.createClientInfoDecodingError = function(caughtError) {
        return new ClientAuthError2(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError);
      };
      ClientAuthError2.createClientInfoEmptyError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.clientInfoEmptyError.code, "" + ClientAuthErrorMessage.clientInfoEmptyError.desc);
      };
      ClientAuthError2.createTokenParsingError = function(caughtExtractionError) {
        return new ClientAuthError2(ClientAuthErrorMessage.tokenParsingError.code, ClientAuthErrorMessage.tokenParsingError.desc + " Failed with error: " + caughtExtractionError);
      };
      ClientAuthError2.createTokenNullOrEmptyError = function(invalidRawTokenString) {
        return new ClientAuthError2(ClientAuthErrorMessage.nullOrEmptyToken.code, ClientAuthErrorMessage.nullOrEmptyToken.desc + " Raw Token Value: " + invalidRawTokenString);
      };
      ClientAuthError2.createEndpointDiscoveryIncompleteError = function(errDetail) {
        return new ClientAuthError2(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + errDetail);
      };
      ClientAuthError2.createNetworkError = function(endpoint, errDetail) {
        return new ClientAuthError2(ClientAuthErrorMessage.networkError.code, ClientAuthErrorMessage.networkError.desc + " | Fetch client threw: " + errDetail + " | Attempted to reach: " + endpoint.split("?")[0]);
      };
      ClientAuthError2.createUnableToGetOpenidConfigError = function(errDetail) {
        return new ClientAuthError2(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, ClientAuthErrorMessage.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + errDetail);
      };
      ClientAuthError2.createHashNotDeserializedError = function(hashParamObj) {
        return new ClientAuthError2(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + hashParamObj);
      };
      ClientAuthError2.createInvalidStateError = function(invalidState, errorString) {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " Invalid State: " + invalidState + ", Root Err: " + errorString);
      };
      ClientAuthError2.createStateMismatchError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);
      };
      ClientAuthError2.createStateNotFoundError = function(missingState) {
        return new ClientAuthError2(ClientAuthErrorMessage.stateNotFoundError.code, ClientAuthErrorMessage.stateNotFoundError.desc + ":  " + missingState);
      };
      ClientAuthError2.createNonceMismatchError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);
      };
      ClientAuthError2.createNonceNotFoundError = function(missingNonce) {
        return new ClientAuthError2(ClientAuthErrorMessage.nonceNotFoundError.code, ClientAuthErrorMessage.nonceNotFoundError.desc + ":  " + missingNonce);
      };
      ClientAuthError2.createMultipleMatchingTokensInCacheError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingTokens.code, ClientAuthErrorMessage.multipleMatchingTokens.desc + ".");
      };
      ClientAuthError2.createMultipleMatchingAccountsInCacheError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc);
      };
      ClientAuthError2.createMultipleMatchingAppMetadataInCacheError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc);
      };
      ClientAuthError2.createTokenRequestCannotBeMadeError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);
      };
      ClientAuthError2.createAppendEmptyScopeToSetError = function(givenScope) {
        return new ClientAuthError2(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + givenScope);
      };
      ClientAuthError2.createRemoveEmptyScopeFromSetError = function(givenScope) {
        return new ClientAuthError2(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + givenScope);
      };
      ClientAuthError2.createAppendScopeSetError = function(appendError) {
        return new ClientAuthError2(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + appendError);
      };
      ClientAuthError2.createEmptyInputScopeSetError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.emptyInputScopeSetError.code, "" + ClientAuthErrorMessage.emptyInputScopeSetError.desc);
      };
      ClientAuthError2.createDeviceCodeCancelledError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, "" + ClientAuthErrorMessage.DeviceCodePollingCancelled.desc);
      };
      ClientAuthError2.createDeviceCodeExpiredError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodeExpired.code, "" + ClientAuthErrorMessage.DeviceCodeExpired.desc);
      };
      ClientAuthError2.createDeviceCodeUnknownError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.DeviceCodeUnknownError.code, "" + ClientAuthErrorMessage.DeviceCodeUnknownError.desc);
      };
      ClientAuthError2.createNoAccountInSilentRequestError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.NoAccountInSilentRequest.code, "" + ClientAuthErrorMessage.NoAccountInSilentRequest.desc);
      };
      ClientAuthError2.createNullOrUndefinedCacheRecord = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);
      };
      ClientAuthError2.createInvalidCacheEnvironmentError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);
      };
      ClientAuthError2.createNoAccountFoundError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);
      };
      ClientAuthError2.createCachePluginError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.CachePluginError.code, "" + ClientAuthErrorMessage.CachePluginError.desc);
      };
      ClientAuthError2.createNoCryptoObjectError = function(operationName) {
        return new ClientAuthError2(ClientAuthErrorMessage.noCryptoObj.code, "" + ClientAuthErrorMessage.noCryptoObj.desc + operationName);
      };
      ClientAuthError2.createInvalidCacheTypeError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidCacheType.code, "" + ClientAuthErrorMessage.invalidCacheType.desc);
      };
      ClientAuthError2.createUnexpectedAccountTypeError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.unexpectedAccountType.code, "" + ClientAuthErrorMessage.unexpectedAccountType.desc);
      };
      ClientAuthError2.createUnexpectedCredentialTypeError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.unexpectedCredentialType.code, "" + ClientAuthErrorMessage.unexpectedCredentialType.desc);
      };
      ClientAuthError2.createInvalidAssertionError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidAssertion.code, "" + ClientAuthErrorMessage.invalidAssertion.desc);
      };
      ClientAuthError2.createInvalidCredentialError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.invalidClientCredential.code, "" + ClientAuthErrorMessage.invalidClientCredential.desc);
      };
      ClientAuthError2.createRefreshRequiredError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc);
      };
      ClientAuthError2.createUserTimeoutReachedError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc);
      };
      ClientAuthError2.createTokenClaimsRequiredError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc);
      };
      ClientAuthError2.createNoAuthCodeInServerResponseError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc);
      };
      ClientAuthError2.createBindingKeyNotRemovedError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc);
      };
      ClientAuthError2.createLogoutNotSupportedError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc);
      };
      ClientAuthError2.createKeyIdMissingError = function() {
        return new ClientAuthError2(ClientAuthErrorMessage.keyIdMissing.code, ClientAuthErrorMessage.keyIdMissing.desc);
      };
      return ClientAuthError2;
    }(AuthError);
    var StringUtils = function() {
      function StringUtils2() {
      }
      StringUtils2.decodeAuthToken = function(authToken) {
        if (StringUtils2.isEmpty(authToken)) {
          throw ClientAuthError.createTokenNullOrEmptyError(authToken);
        }
        var tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
        var matches = tokenPartsRegex.exec(authToken);
        if (!matches || matches.length < 4) {
          throw ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(authToken));
        }
        var crackedToken = {
          header: matches[1],
          JWSPayload: matches[2],
          JWSSig: matches[3]
        };
        return crackedToken;
      };
      StringUtils2.isEmpty = function(str) {
        return typeof str === "undefined" || !str || 0 === str.length;
      };
      StringUtils2.isEmptyObj = function(strObj) {
        if (strObj && !StringUtils2.isEmpty(strObj)) {
          try {
            var obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0;
          } catch (e) {
          }
        }
        return true;
      };
      StringUtils2.startsWith = function(str, search) {
        return str.indexOf(search) === 0;
      };
      StringUtils2.endsWith = function(str, search) {
        return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;
      };
      StringUtils2.queryStringToObject = function(query) {
        var obj = {};
        var params = query.split("&");
        var decode = function(s) {
          return decodeURIComponent(s.replace(/\+/g, " "));
        };
        params.forEach(function(pair) {
          if (pair.trim()) {
            var _a = pair.split(/=(.+)/g, 2), key = _a[0], value = _a[1];
            if (key && value) {
              obj[decode(key)] = decode(value);
            }
          }
        });
        return obj;
      };
      StringUtils2.trimArrayEntries = function(arr) {
        return arr.map(function(entry) {
          return entry.trim();
        });
      };
      StringUtils2.removeEmptyStringsFromArray = function(arr) {
        return arr.filter(function(entry) {
          return !StringUtils2.isEmpty(entry);
        });
      };
      StringUtils2.jsonParseHelper = function(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return null;
        }
      };
      StringUtils2.matchPattern = function(pattern, input) {
        var regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\?"));
        return regex.test(input);
      };
      return StringUtils2;
    }();
    exports2.LogLevel = void 0;
    (function(LogLevel) {
      LogLevel[LogLevel["Error"] = 0] = "Error";
      LogLevel[LogLevel["Warning"] = 1] = "Warning";
      LogLevel[LogLevel["Info"] = 2] = "Info";
      LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
      LogLevel[LogLevel["Trace"] = 4] = "Trace";
    })(exports2.LogLevel || (exports2.LogLevel = {}));
    var Logger = function() {
      function Logger2(loggerOptions, packageName, packageVersion) {
        this.level = exports2.LogLevel.Info;
        var defaultLoggerCallback = function() {
          return;
        };
        this.localCallback = loggerOptions.loggerCallback || defaultLoggerCallback;
        this.piiLoggingEnabled = loggerOptions.piiLoggingEnabled || false;
        this.level = typeof loggerOptions.logLevel === "number" ? loggerOptions.logLevel : exports2.LogLevel.Info;
        this.correlationId = loggerOptions.correlationId || Constants.EMPTY_STRING;
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
      }
      Logger2.prototype.clone = function(packageName, packageVersion, correlationId) {
        return new Logger2({ loggerCallback: this.localCallback, piiLoggingEnabled: this.piiLoggingEnabled, logLevel: this.level, correlationId: correlationId || this.correlationId }, packageName, packageVersion);
      };
      Logger2.prototype.logMessage = function(logMessage, options) {
        if (options.logLevel > this.level || !this.piiLoggingEnabled && options.containsPii) {
          return;
        }
        var timestamp = new Date().toUTCString();
        var logHeader;
        if (!StringUtils.isEmpty(options.correlationId)) {
          logHeader = "[" + timestamp + "] : [" + options.correlationId + "]";
        } else if (!StringUtils.isEmpty(this.correlationId)) {
          logHeader = "[" + timestamp + "] : [" + this.correlationId + "]";
        } else {
          logHeader = "[" + timestamp + "]";
        }
        var log = logHeader + " : " + this.packageName + "@" + this.packageVersion + " : " + exports2.LogLevel[options.logLevel] + " - " + logMessage;
        this.executeCallback(options.logLevel, log, options.containsPii || false);
      };
      Logger2.prototype.executeCallback = function(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii);
        }
      };
      Logger2.prototype.error = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Error,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.errorPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Error,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.warning = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Warning,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.warningPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Warning,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.info = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Info,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.infoPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Info,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.verbose = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Verbose,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.verbosePii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Verbose,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.trace = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Trace,
          containsPii: false,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.tracePii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports2.LogLevel.Trace,
          containsPii: true,
          correlationId: correlationId || Constants.EMPTY_STRING
        });
      };
      Logger2.prototype.isPiiLoggingEnabled = function() {
        return this.piiLoggingEnabled || false;
      };
      return Logger2;
    }();
    var name = "@azure/msal-common";
    var version = "7.4.0";
    exports2.AzureCloudInstance = void 0;
    (function(AzureCloudInstance) {
      AzureCloudInstance[AzureCloudInstance["None"] = 0] = "None";
      AzureCloudInstance["AzurePublic"] = "https://login.microsoftonline.com";
      AzureCloudInstance["AzurePpe"] = "https://login.windows-ppe.net";
      AzureCloudInstance["AzureChina"] = "https://login.chinacloudapi.cn";
      AzureCloudInstance["AzureGermany"] = "https://login.microsoftonline.de";
      AzureCloudInstance["AzureUsGovernment"] = "https://login.microsoftonline.us";
    })(exports2.AzureCloudInstance || (exports2.AzureCloudInstance = {}));
    var CredentialEntity = function() {
      function CredentialEntity2() {
      }
      CredentialEntity2.prototype.generateAccountId = function() {
        return CredentialEntity2.generateAccountIdForCacheKey(this.homeAccountId, this.environment);
      };
      CredentialEntity2.prototype.generateCredentialId = function() {
        return CredentialEntity2.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);
      };
      CredentialEntity2.prototype.generateTarget = function() {
        return CredentialEntity2.generateTargetForCacheKey(this.target);
      };
      CredentialEntity2.prototype.generateCredentialKey = function() {
        return CredentialEntity2.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);
      };
      CredentialEntity2.prototype.generateType = function() {
        switch (this.credentialType) {
          case exports2.CredentialType.ID_TOKEN:
            return exports2.CacheType.ID_TOKEN;
          case exports2.CredentialType.ACCESS_TOKEN:
          case exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
            return exports2.CacheType.ACCESS_TOKEN;
          case exports2.CredentialType.REFRESH_TOKEN:
            return exports2.CacheType.REFRESH_TOKEN;
          default: {
            throw ClientAuthError.createUnexpectedCredentialTypeError();
          }
        }
      };
      CredentialEntity2.getCredentialType = function(key) {
        if (key.indexOf(exports2.CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {
          if (key.indexOf(exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {
            return exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
          }
          return exports2.CredentialType.ACCESS_TOKEN;
        } else if (key.indexOf(exports2.CredentialType.ID_TOKEN.toLowerCase()) !== -1) {
          return exports2.CredentialType.ID_TOKEN;
        } else if (key.indexOf(exports2.CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {
          return exports2.CredentialType.REFRESH_TOKEN;
        }
        return Constants.NOT_DEFINED;
      };
      CredentialEntity2.generateCredentialCacheKey = function(homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {
        var credentialKey = [
          this.generateAccountIdForCacheKey(homeAccountId, environment),
          this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),
          this.generateTargetForCacheKey(target),
          this.generateClaimsHashForCacheKey(requestedClaimsHash),
          this.generateSchemeForCacheKey(tokenType)
        ];
        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      CredentialEntity2.generateAccountIdForCacheKey = function(homeAccountId, environment) {
        var accountId = [homeAccountId, environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      CredentialEntity2.generateCredentialIdForCacheKey = function(credentialType, clientId, realm, familyId) {
        var clientOrFamilyId = credentialType === exports2.CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;
        var credentialId = [
          credentialType,
          clientOrFamilyId,
          realm || Constants.EMPTY_STRING
        ];
        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      CredentialEntity2.generateTargetForCacheKey = function(scopes) {
        return (scopes || Constants.EMPTY_STRING).toLowerCase();
      };
      CredentialEntity2.generateClaimsHashForCacheKey = function(requestedClaimsHash) {
        return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();
      };
      CredentialEntity2.generateSchemeForCacheKey = function(tokenType) {
        return tokenType && tokenType.toLowerCase() !== exports2.AuthenticationScheme.BEARER.toLowerCase() ? tokenType.toLowerCase() : Constants.EMPTY_STRING;
      };
      return CredentialEntity2;
    }();
    var ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: "redirect_uri_empty",
        desc: "A redirect URI is required for all calls, and none has been set."
      },
      postLogoutUriNotSet: {
        code: "post_logout_uri_empty",
        desc: "A post logout redirect has not been set."
      },
      claimsRequestParsingError: {
        code: "claims_request_parsing_error",
        desc: "Could not parse the given claims request object."
      },
      authorityUriInsecure: {
        code: "authority_uri_insecure",
        desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
      },
      urlParseError: {
        code: "url_parse_error",
        desc: "URL could not be parsed into appropriate segments."
      },
      urlEmptyError: {
        code: "empty_url_error",
        desc: "URL was empty or null."
      },
      emptyScopesError: {
        code: "empty_input_scopes_error",
        desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
      },
      nonArrayScopesError: {
        code: "nonarray_input_scopes_error",
        desc: "Scopes cannot be passed as non-array."
      },
      clientIdSingleScopeError: {
        code: "clientid_input_scopes_error",
        desc: "Client ID can only be provided as a single scope."
      },
      invalidPrompt: {
        code: "invalid_prompt_value",
        desc: "Supported prompt values are 'login', 'select_account', 'consent', 'create' and 'none'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest"
      },
      invalidClaimsRequest: {
        code: "invalid_claims",
        desc: "Given claims parameter must be a stringified JSON object."
      },
      tokenRequestEmptyError: {
        code: "token_request_empty",
        desc: "Token request was empty and not found in cache."
      },
      logoutRequestEmptyError: {
        code: "logout_request_empty",
        desc: "The logout request was null or undefined."
      },
      invalidCodeChallengeMethod: {
        code: "invalid_code_challenge_method",
        desc: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".'
      },
      invalidCodeChallengeParams: {
        code: "pkce_params_missing",
        desc: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request"
      },
      invalidCloudDiscoveryMetadata: {
        code: "invalid_cloud_discovery_metadata",
        desc: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields"
      },
      invalidAuthorityMetadata: {
        code: "invalid_authority_metadata",
        desc: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields."
      },
      untrustedAuthority: {
        code: "untrusted_authority",
        desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter."
      },
      invalidAzureCloudInstance: {
        code: "invalid_azure_cloud_instance",
        desc: "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values"
      },
      missingSshJwk: {
        code: "missing_ssh_jwk",
        desc: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme."
      },
      missingSshKid: {
        code: "missing_ssh_kid",
        desc: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme."
      },
      missingNonceAuthenticationHeader: {
        code: "missing_nonce_authentication_header",
        desc: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce."
      },
      invalidAuthenticationHeader: {
        code: "invalid_authentication_header",
        desc: "Invalid authentication header provided"
      }
    };
    var ClientConfigurationError = function(_super) {
      __extends(ClientConfigurationError2, _super);
      function ClientConfigurationError2(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientConfigurationError";
        Object.setPrototypeOf(_this, ClientConfigurationError2.prototype);
        return _this;
      }
      ClientConfigurationError2.createRedirectUriEmptyError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc);
      };
      ClientConfigurationError2.createPostLogoutRedirectUriEmptyError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);
      };
      ClientConfigurationError2.createClaimsRequestParsingError = function(claimsRequestParseError) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError);
      };
      ClientConfigurationError2.createInsecureAuthorityUriError = function(urlString) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + urlString);
      };
      ClientConfigurationError2.createUrlParseError = function(urlParseError) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + urlParseError);
      };
      ClientConfigurationError2.createUrlEmptyError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc);
      };
      ClientConfigurationError2.createEmptyScopesArrayError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.emptyScopesError.code, "" + ClientConfigurationErrorMessage.emptyScopesError.desc);
      };
      ClientConfigurationError2.createClientIdSingleScopeError = function(inputScopes) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + inputScopes);
      };
      ClientConfigurationError2.createInvalidPromptError = function(promptValue) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue);
      };
      ClientConfigurationError2.createInvalidClaimsRequestError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidClaimsRequest.code, ClientConfigurationErrorMessage.invalidClaimsRequest.desc);
      };
      ClientConfigurationError2.createEmptyLogoutRequestError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.logoutRequestEmptyError.code, ClientConfigurationErrorMessage.logoutRequestEmptyError.desc);
      };
      ClientConfigurationError2.createEmptyTokenRequestError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc);
      };
      ClientConfigurationError2.createInvalidCodeChallengeMethodError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code, ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc);
      };
      ClientConfigurationError2.createInvalidCodeChallengeParamsError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCodeChallengeParams.code, ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc);
      };
      ClientConfigurationError2.createInvalidCloudDiscoveryMetadataError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code, ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc);
      };
      ClientConfigurationError2.createInvalidAuthorityMetadataError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthorityMetadata.code, ClientConfigurationErrorMessage.invalidAuthorityMetadata.desc);
      };
      ClientConfigurationError2.createUntrustedAuthorityError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc);
      };
      ClientConfigurationError2.createInvalidAzureCloudInstanceError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAzureCloudInstance.code, ClientConfigurationErrorMessage.invalidAzureCloudInstance.desc);
      };
      ClientConfigurationError2.createMissingSshJwkError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingSshJwk.code, ClientConfigurationErrorMessage.missingSshJwk.desc);
      };
      ClientConfigurationError2.createMissingSshKidError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingSshKid.code, ClientConfigurationErrorMessage.missingSshKid.desc);
      };
      ClientConfigurationError2.createMissingNonceAuthenticationHeadersError = function() {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.code, ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.desc);
      };
      ClientConfigurationError2.createInvalidAuthenticationHeaderError = function(invalidHeaderName, details) {
        return new ClientConfigurationError2(ClientConfigurationErrorMessage.invalidAuthenticationHeader.code, ClientConfigurationErrorMessage.invalidAuthenticationHeader.desc + ". Invalid header: " + invalidHeaderName + ". Details: " + details);
      };
      return ClientConfigurationError2;
    }(ClientAuthError);
    var ScopeSet = function() {
      function ScopeSet2(inputScopes) {
        var _this = this;
        var scopeArr = inputScopes ? StringUtils.trimArrayEntries(__spreadArrays(inputScopes)) : [];
        var filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        this.validateInputScopes(filteredInput);
        this.scopes = /* @__PURE__ */ new Set();
        filteredInput.forEach(function(scope) {
          return _this.scopes.add(scope);
        });
      }
      ScopeSet2.fromString = function(inputScopeString) {
        var scopeString = inputScopeString || Constants.EMPTY_STRING;
        var inputScopes = scopeString.split(" ");
        return new ScopeSet2(inputScopes);
      };
      ScopeSet2.prototype.validateInputScopes = function(inputScopes) {
        if (!inputScopes || inputScopes.length < 1) {
          throw ClientConfigurationError.createEmptyScopesArrayError();
        }
      };
      ScopeSet2.prototype.containsScope = function(scope) {
        var lowerCaseScopes = this.printScopesLowerCase().split(" ");
        var lowerCaseScopesSet = new ScopeSet2(lowerCaseScopes);
        return !StringUtils.isEmpty(scope) ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
      };
      ScopeSet2.prototype.containsScopeSet = function(scopeSet) {
        var _this = this;
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false;
        }
        return this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(function(scope) {
          return _this.containsScope(scope);
        });
      };
      ScopeSet2.prototype.containsOnlyOIDCScopes = function() {
        var _this = this;
        var defaultScopeCount = 0;
        OIDC_SCOPES.forEach(function(defaultScope) {
          if (_this.containsScope(defaultScope)) {
            defaultScopeCount += 1;
          }
        });
        return this.scopes.size === defaultScopeCount;
      };
      ScopeSet2.prototype.appendScope = function(newScope) {
        if (!StringUtils.isEmpty(newScope)) {
          this.scopes.add(newScope.trim());
        }
      };
      ScopeSet2.prototype.appendScopes = function(newScopes) {
        var _this = this;
        try {
          newScopes.forEach(function(newScope) {
            return _this.appendScope(newScope);
          });
        } catch (e) {
          throw ClientAuthError.createAppendScopeSetError(e);
        }
      };
      ScopeSet2.prototype.removeScope = function(scope) {
        if (StringUtils.isEmpty(scope)) {
          throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);
        }
        this.scopes.delete(scope.trim());
      };
      ScopeSet2.prototype.removeOIDCScopes = function() {
        var _this = this;
        OIDC_SCOPES.forEach(function(defaultScope) {
          _this.scopes.delete(defaultScope);
        });
      };
      ScopeSet2.prototype.unionScopeSets = function(otherScopes) {
        if (!otherScopes) {
          throw ClientAuthError.createEmptyInputScopeSetError();
        }
        var unionScopes = /* @__PURE__ */ new Set();
        otherScopes.scopes.forEach(function(scope) {
          return unionScopes.add(scope.toLowerCase());
        });
        this.scopes.forEach(function(scope) {
          return unionScopes.add(scope.toLowerCase());
        });
        return unionScopes;
      };
      ScopeSet2.prototype.intersectingScopeSets = function(otherScopes) {
        if (!otherScopes) {
          throw ClientAuthError.createEmptyInputScopeSetError();
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes();
        }
        var unionScopes = this.unionScopeSets(otherScopes);
        var sizeOtherScopes = otherScopes.getScopeCount();
        var sizeThisScopes = this.getScopeCount();
        var sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
      };
      ScopeSet2.prototype.getScopeCount = function() {
        return this.scopes.size;
      };
      ScopeSet2.prototype.asArray = function() {
        var array = [];
        this.scopes.forEach(function(val) {
          return array.push(val);
        });
        return array;
      };
      ScopeSet2.prototype.printScopes = function() {
        if (this.scopes) {
          var scopeArr = this.asArray();
          return scopeArr.join(" ");
        }
        return Constants.EMPTY_STRING;
      };
      ScopeSet2.prototype.printScopesLowerCase = function() {
        return this.printScopes().toLowerCase();
      };
      return ScopeSet2;
    }();
    function buildClientInfo(rawClientInfo, crypto) {
      if (StringUtils.isEmpty(rawClientInfo)) {
        throw ClientAuthError.createClientInfoEmptyError();
      }
      try {
        var decodedClientInfo = crypto.base64Decode(rawClientInfo);
        return JSON.parse(decodedClientInfo);
      } catch (e) {
        throw ClientAuthError.createClientInfoDecodingError(e.message);
      }
    }
    function buildClientInfoFromHomeAccountId(homeAccountId) {
      if (StringUtils.isEmpty(homeAccountId)) {
        throw ClientAuthError.createClientInfoDecodingError("Home account ID was empty.");
      }
      var clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
      return {
        uid: clientInfoParts[0],
        utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
      };
    }
    exports2.AuthorityType = void 0;
    (function(AuthorityType) {
      AuthorityType[AuthorityType["Default"] = 0] = "Default";
      AuthorityType[AuthorityType["Adfs"] = 1] = "Adfs";
    })(exports2.AuthorityType || (exports2.AuthorityType = {}));
    var AccountEntity = function() {
      function AccountEntity2() {
      }
      AccountEntity2.prototype.generateAccountId = function() {
        var accountId = [this.homeAccountId, this.environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      AccountEntity2.prototype.generateAccountKey = function() {
        return AccountEntity2.generateAccountCacheKey({
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId
        });
      };
      AccountEntity2.prototype.generateType = function() {
        switch (this.authorityType) {
          case exports2.CacheAccountType.ADFS_ACCOUNT_TYPE:
            return exports2.CacheType.ADFS;
          case exports2.CacheAccountType.MSAV1_ACCOUNT_TYPE:
            return exports2.CacheType.MSA;
          case exports2.CacheAccountType.MSSTS_ACCOUNT_TYPE:
            return exports2.CacheType.MSSTS;
          case exports2.CacheAccountType.GENERIC_ACCOUNT_TYPE:
            return exports2.CacheType.GENERIC;
          default: {
            throw ClientAuthError.createUnexpectedAccountTypeError();
          }
        }
      };
      AccountEntity2.prototype.getAccountInfo = function() {
        return {
          homeAccountId: this.homeAccountId,
          environment: this.environment,
          tenantId: this.realm,
          username: this.username,
          localAccountId: this.localAccountId,
          name: this.name,
          idTokenClaims: this.idTokenClaims,
          nativeAccountId: this.nativeAccountId
        };
      };
      AccountEntity2.generateAccountCacheKey = function(accountInterface) {
        var accountKey = [
          accountInterface.homeAccountId,
          accountInterface.environment || Constants.EMPTY_STRING,
          accountInterface.tenantId || Constants.EMPTY_STRING
        ];
        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      AccountEntity2.createAccount = function(clientInfo, homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {
        var _a, _b, _c, _d, _e, _f;
        var account = new AccountEntity2();
        account.authorityType = exports2.CacheAccountType.MSSTS_ACCOUNT_TYPE;
        account.clientInfo = clientInfo;
        account.homeAccountId = homeAccountId;
        account.nativeAccountId = nativeAccountId;
        var env = environment || authority && authority.getPreferredCache();
        if (!env) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        account.environment = env;
        account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || Constants.EMPTY_STRING;
        if (idToken) {
          account.idTokenClaims = idToken.claims;
          account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || Constants.EMPTY_STRING;
          account.username = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username) || (((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : Constants.EMPTY_STRING);
          account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;
        }
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        return account;
      };
      AccountEntity2.createGenericAccount = function(homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment) {
        var _a, _b, _c, _d;
        var account = new AccountEntity2();
        account.authorityType = authority && authority.authorityType === exports2.AuthorityType.Adfs ? exports2.CacheAccountType.ADFS_ACCOUNT_TYPE : exports2.CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = homeAccountId;
        account.realm = Constants.EMPTY_STRING;
        var env = environment || authority && authority.getPreferredCache();
        if (!env) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        if (idToken) {
          account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || Constants.EMPTY_STRING;
          account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || Constants.EMPTY_STRING;
          account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || Constants.EMPTY_STRING;
          account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;
        }
        account.environment = env;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        return account;
      };
      AccountEntity2.generateHomeAccountId = function(serverClientInfo, authType, logger2, cryptoObj, idToken) {
        var _a;
        var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants.EMPTY_STRING;
        if (authType === exports2.AuthorityType.Adfs) {
          return accountId;
        }
        if (serverClientInfo) {
          try {
            var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);
            if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {
              return "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;
            }
          } catch (e) {
          }
        }
        logger2.verbose("No client info in response");
        return accountId;
      };
      AccountEntity2.isAccountEntity = function(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType");
      };
      AccountEntity2.accountInfoIsEqual = function(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false;
        }
        var claimsMatch = true;
        if (compareClaims) {
          var accountAClaims = accountA.idTokenClaims || {};
          var accountBClaims = accountB.idTokenClaims || {};
          claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;
        }
        return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;
      };
      return AccountEntity2;
    }();
    var AuthToken = function() {
      function AuthToken2(rawToken, crypto) {
        if (StringUtils.isEmpty(rawToken)) {
          throw ClientAuthError.createTokenNullOrEmptyError(rawToken);
        }
        this.rawToken = rawToken;
        this.claims = AuthToken2.extractTokenClaims(rawToken, crypto);
      }
      AuthToken2.extractTokenClaims = function(encodedToken, crypto) {
        var decodedToken = StringUtils.decodeAuthToken(encodedToken);
        try {
          var base64TokenPayload = decodedToken.JWSPayload;
          var base64Decoded = crypto.base64Decode(base64TokenPayload);
          return JSON.parse(base64Decoded);
        } catch (err) {
          throw ClientAuthError.createTokenParsingError(err);
        }
      };
      return AuthToken2;
    }();
    var CacheManager = function() {
      function CacheManager2(clientId, cryptoImpl) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl;
      }
      CacheManager2.prototype.getAllAccounts = function() {
        var _this = this;
        var currentAccounts = this.getAccountsFilteredBy();
        var accountValues = Object.keys(currentAccounts).map(function(accountKey) {
          return currentAccounts[accountKey];
        });
        var numAccounts = accountValues.length;
        if (numAccounts < 1) {
          return [];
        } else {
          var allAccounts = accountValues.map(function(value) {
            var accountEntity = CacheManager2.toObject(new AccountEntity(), value);
            var accountInfo = accountEntity.getAccountInfo();
            var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);
            if (idToken && !accountInfo.idTokenClaims) {
              accountInfo.idToken = idToken.secret;
              accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;
            }
            return accountInfo;
          });
          return allAccounts;
        }
      };
      CacheManager2.prototype.saveCacheRecord = function(cacheRecord) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!cacheRecord) {
                  throw ClientAuthError.createNullOrUndefinedCacheRecord();
                }
                if (!!cacheRecord.account) {
                  this.setAccount(cacheRecord.account);
                }
                if (!!cacheRecord.idToken) {
                  this.setIdTokenCredential(cacheRecord.idToken);
                }
                if (!!!cacheRecord.accessToken)
                  return [3, 2];
                return [4, this.saveAccessToken(cacheRecord.accessToken)];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                if (!!cacheRecord.refreshToken) {
                  this.setRefreshTokenCredential(cacheRecord.refreshToken);
                }
                if (!!cacheRecord.appMetadata) {
                  this.setAppMetadata(cacheRecord.appMetadata);
                }
                return [2];
            }
          });
        });
      };
      CacheManager2.prototype.saveAccessToken = function(credential) {
        return __awaiter(this, void 0, void 0, function() {
          var currentTokenCache, currentScopes, currentAccessTokens, removedAccessTokens_1;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                currentTokenCache = this.getCredentialsFilteredBy({
                  clientId: credential.clientId,
                  credentialType: credential.credentialType,
                  environment: credential.environment,
                  homeAccountId: credential.homeAccountId,
                  realm: credential.realm,
                  tokenType: credential.tokenType,
                  requestedClaimsHash: credential.requestedClaimsHash
                });
                currentScopes = ScopeSet.fromString(credential.target);
                currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function(key) {
                  return currentTokenCache.accessTokens[key];
                });
                if (!currentAccessTokens)
                  return [3, 2];
                removedAccessTokens_1 = [];
                currentAccessTokens.forEach(function(tokenEntity) {
                  var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
                  if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
                    removedAccessTokens_1.push(_this.removeCredential(tokenEntity));
                  }
                });
                return [4, Promise.all(removedAccessTokens_1)];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                this.setAccessTokenCredential(credential);
                return [2];
            }
          });
        });
      };
      CacheManager2.prototype.getAccountsFilteredBy = function(accountFilter) {
        return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING, accountFilter ? accountFilter.environment : Constants.EMPTY_STRING, accountFilter ? accountFilter.realm : Constants.EMPTY_STRING, accountFilter ? accountFilter.nativeAccountId : Constants.EMPTY_STRING);
      };
      CacheManager2.prototype.getAccountsFilteredByInternal = function(homeAccountId, environment, realm, nativeAccountId) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingAccounts = {};
        allCacheKeys.forEach(function(cacheKey) {
          var entity = _this.getAccount(cacheKey);
          if (!entity) {
            return;
          }
          if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {
            return;
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return;
          }
          if (!!realm && !_this.matchRealm(entity, realm)) {
            return;
          }
          if (!!nativeAccountId && !_this.matchNativeAccountId(entity, nativeAccountId)) {
            return;
          }
          matchingAccounts[cacheKey] = entity;
        });
        return matchingAccounts;
      };
      CacheManager2.prototype.getCredentialsFilteredBy = function(filter) {
        return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.userAssertionHash, filter.tokenType, filter.keyId, filter.requestedClaimsHash);
      };
      CacheManager2.prototype.getCredentialsFilteredByInternal = function(homeAccountId, environment, credentialType, clientId, familyId, realm, target, userAssertionHash, tokenType, keyId, requestedClaimsHash) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingCredentials = {
          idTokens: {},
          accessTokens: {},
          refreshTokens: {}
        };
        allCacheKeys.forEach(function(cacheKey) {
          var credType = CredentialEntity.getCredentialType(cacheKey);
          if (credType === Constants.NOT_DEFINED) {
            return;
          }
          var entity = _this.getSpecificCredential(cacheKey, credType);
          if (!entity) {
            return;
          }
          if (!!userAssertionHash && !_this.matchUserAssertionHash(entity, userAssertionHash)) {
            return;
          }
          if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {
            return;
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return;
          }
          if (!!realm && !_this.matchRealm(entity, realm)) {
            return;
          }
          if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {
            return;
          }
          if (!!clientId && !_this.matchClientId(entity, clientId)) {
            return;
          }
          if (!!familyId && !_this.matchFamilyId(entity, familyId)) {
            return;
          }
          if (!!target && !_this.matchTarget(entity, target)) {
            return;
          }
          if (requestedClaimsHash || entity.requestedClaimsHash) {
            if (entity.requestedClaimsHash !== requestedClaimsHash) {
              return;
            }
          }
          if (credentialType === exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
            if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {
              return;
            }
            if (tokenType === exports2.AuthenticationScheme.SSH) {
              if (keyId && !_this.matchKeyId(entity, keyId)) {
                return;
              }
            }
          }
          var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);
          switch (credType) {
            case exports2.CredentialType.ID_TOKEN:
              matchingCredentials.idTokens[updatedCacheKey] = entity;
              break;
            case exports2.CredentialType.ACCESS_TOKEN:
            case exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
              matchingCredentials.accessTokens[updatedCacheKey] = entity;
              break;
            case exports2.CredentialType.REFRESH_TOKEN:
              matchingCredentials.refreshTokens[updatedCacheKey] = entity;
              break;
          }
        });
        return matchingCredentials;
      };
      CacheManager2.prototype.getAppMetadataFilteredBy = function(filter) {
        return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);
      };
      CacheManager2.prototype.getAppMetadataFilteredByInternal = function(environment, clientId) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingAppMetadata = {};
        allCacheKeys.forEach(function(cacheKey) {
          if (!_this.isAppMetadata(cacheKey)) {
            return;
          }
          var entity = _this.getAppMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return;
          }
          if (!!clientId && !_this.matchClientId(entity, clientId)) {
            return;
          }
          matchingAppMetadata[cacheKey] = entity;
        });
        return matchingAppMetadata;
      };
      CacheManager2.prototype.getAuthorityMetadataByAlias = function(host) {
        var _this = this;
        var allCacheKeys = this.getAuthorityMetadataKeys();
        var matchedEntity = null;
        allCacheKeys.forEach(function(cacheKey) {
          if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {
            return;
          }
          var entity = _this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return;
          }
          if (entity.aliases.indexOf(host) === -1) {
            return;
          }
          matchedEntity = entity;
        });
        return matchedEntity;
      };
      CacheManager2.prototype.removeAllAccounts = function() {
        return __awaiter(this, void 0, void 0, function() {
          var allCacheKeys, removedAccounts;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                allCacheKeys = this.getKeys();
                removedAccounts = [];
                allCacheKeys.forEach(function(cacheKey) {
                  var entity = _this.getAccount(cacheKey);
                  if (!entity) {
                    return;
                  }
                  removedAccounts.push(_this.removeAccount(cacheKey));
                });
                return [4, Promise.all(removedAccounts)];
              case 1:
                _a.sent();
                return [2, true];
            }
          });
        });
      };
      CacheManager2.prototype.removeAccount = function(accountKey) {
        return __awaiter(this, void 0, void 0, function() {
          var account;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                account = this.getAccount(accountKey);
                if (!account) {
                  throw ClientAuthError.createNoAccountFoundError();
                }
                return [4, this.removeAccountContext(account)];
              case 1:
                return [2, _a.sent() && this.removeItem(accountKey, exports2.CacheSchemaType.ACCOUNT)];
            }
          });
        });
      };
      CacheManager2.prototype.removeAccountContext = function(account) {
        return __awaiter(this, void 0, void 0, function() {
          var allCacheKeys, accountId, removedCredentials;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                allCacheKeys = this.getKeys();
                accountId = account.generateAccountId();
                removedCredentials = [];
                allCacheKeys.forEach(function(cacheKey) {
                  var credType = CredentialEntity.getCredentialType(cacheKey);
                  if (credType === Constants.NOT_DEFINED) {
                    return;
                  }
                  var cacheEntity = _this.getSpecificCredential(cacheKey, credType);
                  if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {
                    removedCredentials.push(_this.removeCredential(cacheEntity));
                  }
                });
                return [4, Promise.all(removedCredentials)];
              case 1:
                _a.sent();
                return [2, true];
            }
          });
        });
      };
      CacheManager2.prototype.removeCredential = function(credential) {
        return __awaiter(this, void 0, void 0, function() {
          var key, accessTokenWithAuthSchemeEntity, kid;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                key = credential.generateCredentialKey();
                if (!(credential.credentialType.toLowerCase() === exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()))
                  return [3, 4];
                if (!(credential.tokenType === exports2.AuthenticationScheme.POP))
                  return [3, 4];
                accessTokenWithAuthSchemeEntity = credential;
                kid = accessTokenWithAuthSchemeEntity.keyId;
                if (!kid)
                  return [3, 4];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.cryptoImpl.removeTokenBindingKey(kid)];
              case 2:
                _a.sent();
                return [3, 4];
              case 3:
                _a.sent();
                throw ClientAuthError.createBindingKeyNotRemovedError();
              case 4:
                return [2, this.removeItem(key, exports2.CacheSchemaType.CREDENTIAL)];
            }
          });
        });
      };
      CacheManager2.prototype.removeAppMetadata = function() {
        var _this = this;
        var allCacheKeys = this.getKeys();
        allCacheKeys.forEach(function(cacheKey) {
          if (_this.isAppMetadata(cacheKey)) {
            _this.removeItem(cacheKey, exports2.CacheSchemaType.APP_METADATA);
          }
        });
        return true;
      };
      CacheManager2.prototype.readCacheRecord = function(account, clientId, request, environment) {
        var cachedAccount = this.readAccountFromCache(account);
        var cachedIdToken = this.readIdTokenFromCache(clientId, account);
        var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);
        var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);
        var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);
        if (cachedAccount && cachedIdToken) {
          cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;
        }
        return {
          account: cachedAccount,
          idToken: cachedIdToken,
          accessToken: cachedAccessToken,
          refreshToken: cachedRefreshToken,
          appMetadata: cachedAppMetadata
        };
      };
      CacheManager2.prototype.readAccountFromCache = function(account) {
        var accountKey = AccountEntity.generateAccountCacheKey(account);
        return this.getAccount(accountKey);
      };
      CacheManager2.prototype.readAccountFromCacheWithNativeAccountId = function(nativeAccountId) {
        var accountFilter = {
          nativeAccountId
        };
        var accountCache = this.getAccountsFilteredBy(accountFilter);
        var accounts = Object.keys(accountCache).map(function(key) {
          return accountCache[key];
        });
        if (accounts.length < 1) {
          return null;
        } else if (accounts.length > 1) {
          throw ClientAuthError.createMultipleMatchingAccountsInCacheError();
        }
        return accountCache[0];
      };
      CacheManager2.prototype.readIdTokenFromCache = function(clientId, account) {
        var idTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: exports2.CredentialType.ID_TOKEN,
          clientId,
          realm: account.tenantId
        };
        var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);
        var idTokens = Object.keys(credentialCache.idTokens).map(function(key) {
          return credentialCache.idTokens[key];
        });
        var numIdTokens = idTokens.length;
        if (numIdTokens < 1) {
          return null;
        } else if (numIdTokens > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return idTokens[0];
      };
      CacheManager2.prototype.readAccessTokenFromCache = function(clientId, account, request) {
        var scopes = new ScopeSet(request.scopes || []);
        var authScheme = request.authenticationScheme || exports2.AuthenticationScheme.BEARER;
        var credentialType = authScheme && authScheme.toLowerCase() !== exports2.AuthenticationScheme.BEARER.toLowerCase() ? exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : exports2.CredentialType.ACCESS_TOKEN;
        var accessTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType,
          clientId,
          realm: account.tenantId,
          target: scopes.printScopesLowerCase(),
          tokenType: authScheme,
          keyId: request.sshKid,
          requestedClaimsHash: request.requestedClaimsHash
        };
        var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function(key) {
          return credentialCache.accessTokens[key];
        });
        var numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          return null;
        } else if (numAccessTokens > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
      };
      CacheManager2.prototype.readRefreshTokenFromCache = function(clientId, account, familyRT) {
        var id = familyRT ? THE_FAMILY_ID : void 0;
        var refreshTokenFilter = {
          homeAccountId: account.homeAccountId,
          environment: account.environment,
          credentialType: exports2.CredentialType.REFRESH_TOKEN,
          clientId,
          familyId: id
        };
        var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);
        var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function(key) {
          return credentialCache.refreshTokens[key];
        });
        var numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          return null;
        }
        return refreshTokens[0];
      };
      CacheManager2.prototype.readAppMetadataFromCache = function(environment, clientId) {
        var appMetadataFilter = {
          environment,
          clientId
        };
        var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        var appMetadataEntries = Object.keys(appMetadata).map(function(key) {
          return appMetadata[key];
        });
        var numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null;
        } else if (numAppMetadata > 1) {
          throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();
        }
        return appMetadataEntries[0];
      };
      CacheManager2.prototype.isAppMetadataFOCI = function(environment, clientId) {
        var appMetadata = this.readAppMetadataFromCache(environment, clientId);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
      };
      CacheManager2.prototype.matchHomeAccountId = function(entity, homeAccountId) {
        return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId);
      };
      CacheManager2.prototype.matchUserAssertionHash = function(entity, userAssertionHash) {
        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
      };
      CacheManager2.prototype.matchEnvironment = function(entity, environment) {
        var cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true;
        }
        return false;
      };
      CacheManager2.prototype.matchCredentialType = function(entity, credentialType) {
        return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();
      };
      CacheManager2.prototype.matchClientId = function(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId);
      };
      CacheManager2.prototype.matchFamilyId = function(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId);
      };
      CacheManager2.prototype.matchRealm = function(entity, realm) {
        return !!(entity.realm && realm === entity.realm);
      };
      CacheManager2.prototype.matchNativeAccountId = function(entity, nativeAccountId) {
        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
      };
      CacheManager2.prototype.matchTarget = function(entity, target) {
        var isNotAccessTokenCredential = entity.credentialType !== exports2.CredentialType.ACCESS_TOKEN && entity.credentialType !== exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
        if (isNotAccessTokenCredential || !entity.target) {
          return false;
        }
        var entityScopeSet = ScopeSet.fromString(entity.target);
        var requestTargetScopeSet = ScopeSet.fromString(target);
        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {
          requestTargetScopeSet.removeOIDCScopes();
        } else {
          requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
        }
        return entityScopeSet.containsScopeSet(requestTargetScopeSet);
      };
      CacheManager2.prototype.matchTokenType = function(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType);
      };
      CacheManager2.prototype.matchKeyId = function(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId);
      };
      CacheManager2.prototype.isAppMetadata = function(key) {
        return key.indexOf(APP_METADATA) !== -1;
      };
      CacheManager2.prototype.isAuthorityMetadata = function(key) {
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
      };
      CacheManager2.prototype.generateAuthorityMetadataCacheKey = function(authority) {
        return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + "-" + this.clientId + "-" + authority;
      };
      CacheManager2.prototype.getSpecificCredential = function(key, credType) {
        switch (credType) {
          case exports2.CredentialType.ID_TOKEN: {
            return this.getIdTokenCredential(key);
          }
          case exports2.CredentialType.ACCESS_TOKEN:
          case exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {
            return this.getAccessTokenCredential(key);
          }
          case exports2.CredentialType.REFRESH_TOKEN: {
            return this.getRefreshTokenCredential(key);
          }
          default:
            return null;
        }
      };
      CacheManager2.toObject = function(obj, json) {
        for (var propertyName in json) {
          obj[propertyName] = json[propertyName];
        }
        return obj;
      };
      return CacheManager2;
    }();
    var DefaultStorageClass = function(_super) {
      __extends(DefaultStorageClass2, _super);
      function DefaultStorageClass2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DefaultStorageClass2.prototype.setAccount = function() {
        var notImplErr = "Storage interface - setAccount() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAccount = function() {
        var notImplErr = "Storage interface - getAccount() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setIdTokenCredential = function() {
        var notImplErr = "Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getIdTokenCredential = function() {
        var notImplErr = "Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setAccessTokenCredential = function() {
        var notImplErr = "Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAccessTokenCredential = function() {
        var notImplErr = "Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setRefreshTokenCredential = function() {
        var notImplErr = "Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getRefreshTokenCredential = function() {
        var notImplErr = "Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setAppMetadata = function() {
        var notImplErr = "Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAppMetadata = function() {
        var notImplErr = "Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setServerTelemetry = function() {
        var notImplErr = "Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getServerTelemetry = function() {
        var notImplErr = "Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setAuthorityMetadata = function() {
        var notImplErr = "Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAuthorityMetadata = function() {
        var notImplErr = "Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getAuthorityMetadataKeys = function() {
        var notImplErr = "Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.setThrottlingCache = function() {
        var notImplErr = "Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getThrottlingCache = function() {
        var notImplErr = "Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.removeItem = function() {
        var notImplErr = "Storage interface - removeItem() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.containsKey = function() {
        var notImplErr = "Storage interface - containsKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.getKeys = function() {
        var notImplErr = "Storage interface - getKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass2.prototype.clear = function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Storage interface - clear() has not been implemented for the cacheStorage interface.";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      };
      DefaultStorageClass2.prototype.updateCredentialCacheKey = function() {
        var notImplErr = "Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      return DefaultStorageClass2;
    }(CacheManager);
    var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
    var DEFAULT_SYSTEM_OPTIONS = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
      preventCorsPreflight: false,
      proxyUrl: Constants.EMPTY_STRING
    };
    var DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: function() {
      },
      piiLoggingEnabled: false,
      logLevel: exports2.LogLevel.Info,
      correlationId: Constants.EMPTY_STRING
    };
    var DEFAULT_NETWORK_IMPLEMENTATION = {
      sendGetRequestAsync: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Network interface - sendGetRequestAsync() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      },
      sendPostRequestAsync: function() {
        return __awaiter(this, void 0, void 0, function() {
          var notImplErr;
          return __generator(this, function(_a) {
            notImplErr = "Network interface - sendPostRequestAsync() has not been implemented";
            throw AuthError.createUnexpectedError(notImplErr);
          });
        });
      }
    };
    var DEFAULT_LIBRARY_INFO = {
      sku: Constants.SKU,
      version,
      cpu: Constants.EMPTY_STRING,
      os: Constants.EMPTY_STRING
    };
    var DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: Constants.EMPTY_STRING,
      clientAssertion: void 0
    };
    var DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: exports2.AzureCloudInstance.None,
      tenant: "" + Constants.DEFAULT_COMMON_TENANT
    };
    var DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: "",
        appVersion: ""
      }
    };
    function buildClientConfiguration(_a) {
      var userAuthOptions = _a.authOptions, userSystemOptions = _a.systemOptions, userLoggerOption = _a.loggerOptions, storageImplementation = _a.storageInterface, networkImplementation = _a.networkInterface, cryptoImplementation = _a.cryptoInterface, clientCredentials = _a.clientCredentials, libraryInfo = _a.libraryInfo, telemetry = _a.telemetry, serverTelemetryManager = _a.serverTelemetryManager, persistencePlugin = _a.persistencePlugin, serializableCache = _a.serializableCache;
      var loggerOptions = __assign(__assign({}, DEFAULT_LOGGER_IMPLEMENTATION), userLoggerOption);
      return {
        authOptions: buildAuthOptions(userAuthOptions),
        systemOptions: __assign(__assign({}, DEFAULT_SYSTEM_OPTIONS), userSystemOptions),
        loggerOptions,
        storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION),
        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
        clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
        libraryInfo: __assign(__assign({}, DEFAULT_LIBRARY_INFO), libraryInfo),
        telemetry: __assign(__assign({}, DEFAULT_TELEMETRY_OPTIONS), telemetry),
        serverTelemetryManager: serverTelemetryManager || null,
        persistencePlugin: persistencePlugin || null,
        serializableCache: serializableCache || null
      };
    }
    function buildAuthOptions(authOptions) {
      return __assign({ clientCapabilities: [], azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS, skipAuthorityMetadataCache: false }, authOptions);
    }
    var ServerError = function(_super) {
      __extends(ServerError2, _super);
      function ServerError2(errorCode, errorMessage, subError) {
        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
        _this.name = "ServerError";
        Object.setPrototypeOf(_this, ServerError2.prototype);
        return _this;
      }
      return ServerError2;
    }(AuthError);
    var ThrottlingUtils = function() {
      function ThrottlingUtils2() {
      }
      ThrottlingUtils2.generateThrottlingStorageKey = function(thumbprint) {
        return ThrottlingConstants.THROTTLING_PREFIX + "." + JSON.stringify(thumbprint);
      };
      ThrottlingUtils2.preProcess = function(cacheManager, thumbprint) {
        var _a;
        var key = ThrottlingUtils2.generateThrottlingStorageKey(thumbprint);
        var value = cacheManager.getThrottlingCache(key);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key, exports2.CacheSchemaType.THROTTLING);
            return;
          }
          throw new ServerError(((_a = value.errorCodes) === null || _a === void 0 ? void 0 : _a.join(" ")) || Constants.EMPTY_STRING, value.errorMessage, value.subError);
        }
      };
      ThrottlingUtils2.postProcess = function(cacheManager, thumbprint, response) {
        if (ThrottlingUtils2.checkResponseStatus(response) || ThrottlingUtils2.checkResponseForRetryAfter(response)) {
          var thumbprintValue = {
            throttleTime: ThrottlingUtils2.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
            error: response.body.error,
            errorCodes: response.body.error_codes,
            errorMessage: response.body.error_description,
            subError: response.body.suberror
          };
          cacheManager.setThrottlingCache(ThrottlingUtils2.generateThrottlingStorageKey(thumbprint), thumbprintValue);
        }
      };
      ThrottlingUtils2.checkResponseStatus = function(response) {
        return response.status === 429 || response.status >= 500 && response.status < 600;
      };
      ThrottlingUtils2.checkResponseForRetryAfter = function(response) {
        if (response.headers) {
          return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
        }
        return false;
      };
      ThrottlingUtils2.calculateThrottleTime = function(throttleTime) {
        var time = throttleTime <= 0 ? 0 : throttleTime;
        var currentSeconds = Date.now() / 1e3;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1e3);
      };
      ThrottlingUtils2.removeThrottle = function(cacheManager, clientId, request, homeAccountIdentifier) {
        var thumbprint = {
          clientId,
          authority: request.authority,
          scopes: request.scopes,
          homeAccountIdentifier,
          claims: request.claims,
          authenticationScheme: request.authenticationScheme,
          resourceRequestMethod: request.resourceRequestMethod,
          resourceRequestUri: request.resourceRequestUri,
          shrClaims: request.shrClaims,
          sshKid: request.sshKid
        };
        var key = this.generateThrottlingStorageKey(thumbprint);
        return cacheManager.removeItem(key, exports2.CacheSchemaType.THROTTLING);
      };
      return ThrottlingUtils2;
    }();
    var NetworkManager = function() {
      function NetworkManager2(networkClient, cacheManager) {
        this.networkClient = networkClient;
        this.cacheManager = cacheManager;
      }
      NetworkManager2.prototype.sendPostRequest = function(thumbprint, tokenEndpoint, options) {
        return __awaiter(this, void 0, void 0, function() {
          var response, e_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.networkClient.sendPostRequestAsync(tokenEndpoint, options)];
              case 2:
                response = _a.sent();
                return [3, 4];
              case 3:
                e_1 = _a.sent();
                if (e_1 instanceof AuthError) {
                  throw e_1;
                } else {
                  throw ClientAuthError.createNetworkError(tokenEndpoint, e_1);
                }
              case 4:
                ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
                return [2, response];
            }
          });
        });
      };
      return NetworkManager2;
    }();
    exports2.CcsCredentialType = void 0;
    (function(CcsCredentialType) {
      CcsCredentialType["HOME_ACCOUNT_ID"] = "home_account_id";
      CcsCredentialType["UPN"] = "UPN";
    })(exports2.CcsCredentialType || (exports2.CcsCredentialType = {}));
    var BaseClient = function() {
      function BaseClient2(configuration, performanceClient) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name, version);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.networkManager = new NetworkManager(this.networkClient, this.cacheManager);
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority;
        this.performanceClient = performanceClient;
      }
      BaseClient2.prototype.createTokenRequestHeaders = function(ccsCred) {
        var headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case exports2.CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                var clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = "Oid:" + clientInfo.uid + "@" + clientInfo.utid;
              } catch (e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
              }
              break;
            case exports2.CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = "UPN: " + ccsCred.credential;
              break;
          }
        }
        return headers;
      };
      BaseClient2.prototype.executePostToTokenEndpoint = function(tokenEndpoint, queryString, headers, thumbprint) {
        return __awaiter(this, void 0, void 0, function() {
          var response;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.networkManager.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers, proxyUrl: this.config.systemOptions.proxyUrl })];
              case 1:
                response = _a.sent();
                if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
                  this.config.serverTelemetryManager.clearTelemetryCache();
                }
                return [2, response];
            }
          });
        });
      };
      BaseClient2.prototype.updateAuthority = function(updatedAuthority) {
        if (!updatedAuthority.discoveryComplete()) {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
        }
        this.authority = updatedAuthority;
      };
      return BaseClient2;
    }();
    var RequestValidator = function() {
      function RequestValidator2() {
      }
      RequestValidator2.validateRedirectUri = function(redirectUri) {
        if (StringUtils.isEmpty(redirectUri)) {
          throw ClientConfigurationError.createRedirectUriEmptyError();
        }
      };
      RequestValidator2.validatePrompt = function(prompt) {
        var promptValues = [];
        for (var value in PromptValue) {
          promptValues.push(PromptValue[value]);
        }
        if (promptValues.indexOf(prompt) < 0) {
          throw ClientConfigurationError.createInvalidPromptError(prompt);
        }
      };
      RequestValidator2.validateClaims = function(claims) {
        try {
          JSON.parse(claims);
        } catch (e) {
          throw ClientConfigurationError.createInvalidClaimsRequestError();
        }
      };
      RequestValidator2.validateCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
        if (StringUtils.isEmpty(codeChallenge) || StringUtils.isEmpty(codeChallengeMethod)) {
          throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
        } else {
          this.validateCodeChallengeMethod(codeChallengeMethod);
        }
      };
      RequestValidator2.validateCodeChallengeMethod = function(codeChallengeMethod) {
        if ([
          CodeChallengeMethodValues.PLAIN,
          CodeChallengeMethodValues.S256
        ].indexOf(codeChallengeMethod) < 0) {
          throw ClientConfigurationError.createInvalidCodeChallengeMethodError();
        }
      };
      RequestValidator2.sanitizeEQParams = function(eQParams, queryParams) {
        if (!eQParams) {
          return {};
        }
        queryParams.forEach(function(value, key) {
          if (eQParams[key]) {
            delete eQParams[key];
          }
        });
        return eQParams;
      };
      return RequestValidator2;
    }();
    var RequestParameterBuilder = function() {
      function RequestParameterBuilder2() {
        this.parameters = /* @__PURE__ */ new Map();
      }
      RequestParameterBuilder2.prototype.addResponseTypeCode = function() {
        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE));
      };
      RequestParameterBuilder2.prototype.addResponseTypeForTokenAndIdToken = function() {
        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.TOKEN_RESPONSE_TYPE + " " + Constants.ID_TOKEN_RESPONSE_TYPE));
      };
      RequestParameterBuilder2.prototype.addResponseMode = function(responseMode) {
        this.parameters.set(AADServerParamKeys.RESPONSE_MODE, encodeURIComponent(responseMode ? responseMode : exports2.ResponseMode.QUERY));
      };
      RequestParameterBuilder2.prototype.addNativeBroker = function() {
        this.parameters.set(AADServerParamKeys.NATIVE_BROKER, encodeURIComponent("1"));
      };
      RequestParameterBuilder2.prototype.addScopes = function(scopes, addOidcScopes) {
        if (addOidcScopes === void 0) {
          addOidcScopes = true;
        }
        var requestScopes = addOidcScopes ? __spreadArrays(scopes || [], OIDC_DEFAULT_SCOPES) : scopes || [];
        var scopeSet = new ScopeSet(requestScopes);
        this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(scopeSet.printScopes()));
      };
      RequestParameterBuilder2.prototype.addClientId = function(clientId) {
        this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(clientId));
      };
      RequestParameterBuilder2.prototype.addRedirectUri = function(redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(redirectUri));
      };
      RequestParameterBuilder2.prototype.addPostLogoutRedirectUri = function(redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(AADServerParamKeys.POST_LOGOUT_URI, encodeURIComponent(redirectUri));
      };
      RequestParameterBuilder2.prototype.addIdTokenHint = function(idTokenHint) {
        this.parameters.set(AADServerParamKeys.ID_TOKEN_HINT, encodeURIComponent(idTokenHint));
      };
      RequestParameterBuilder2.prototype.addDomainHint = function(domainHint) {
        this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(domainHint));
      };
      RequestParameterBuilder2.prototype.addLoginHint = function(loginHint) {
        this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(loginHint));
      };
      RequestParameterBuilder2.prototype.addCcsUpn = function(loginHint) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("UPN:" + loginHint));
      };
      RequestParameterBuilder2.prototype.addCcsOid = function(clientInfo) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("Oid:" + clientInfo.uid + "@" + clientInfo.utid));
      };
      RequestParameterBuilder2.prototype.addSid = function(sid) {
        this.parameters.set(SSOTypes.SID, encodeURIComponent(sid));
      };
      RequestParameterBuilder2.prototype.addClaims = function(claims, clientCapabilities) {
        var mergedClaims = this.addClientCapabilitiesToClaims(claims, clientCapabilities);
        RequestValidator.validateClaims(mergedClaims);
        this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(mergedClaims));
      };
      RequestParameterBuilder2.prototype.addCorrelationId = function(correlationId) {
        this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(correlationId));
      };
      RequestParameterBuilder2.prototype.addLibraryInfo = function(libraryInfo) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, libraryInfo.sku);
        this.parameters.set(AADServerParamKeys.X_CLIENT_VER, libraryInfo.version);
        if (libraryInfo.os) {
          this.parameters.set(AADServerParamKeys.X_CLIENT_OS, libraryInfo.os);
        }
        if (libraryInfo.cpu) {
          this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, libraryInfo.cpu);
        }
      };
      RequestParameterBuilder2.prototype.addApplicationTelemetry = function(appTelemetry) {
        if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appName) {
          this.parameters.set(AADServerParamKeys.X_APP_NAME, appTelemetry.appName);
        }
        if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appVersion) {
          this.parameters.set(AADServerParamKeys.X_APP_VER, appTelemetry.appVersion);
        }
      };
      RequestParameterBuilder2.prototype.addPrompt = function(prompt) {
        RequestValidator.validatePrompt(prompt);
        this.parameters.set("" + AADServerParamKeys.PROMPT, encodeURIComponent(prompt));
      };
      RequestParameterBuilder2.prototype.addState = function(state) {
        if (!StringUtils.isEmpty(state)) {
          this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(state));
        }
      };
      RequestParameterBuilder2.prototype.addNonce = function(nonce) {
        this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(nonce));
      };
      RequestParameterBuilder2.prototype.addCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
        RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);
        if (codeChallenge && codeChallengeMethod) {
          this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(codeChallenge));
          this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod));
        } else {
          throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
        }
      };
      RequestParameterBuilder2.prototype.addAuthorizationCode = function(code2) {
        this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(code2));
      };
      RequestParameterBuilder2.prototype.addDeviceCode = function(code2) {
        this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(code2));
      };
      RequestParameterBuilder2.prototype.addRefreshToken = function(refreshToken) {
        this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(refreshToken));
      };
      RequestParameterBuilder2.prototype.addCodeVerifier = function(codeVerifier) {
        this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(codeVerifier));
      };
      RequestParameterBuilder2.prototype.addClientSecret = function(clientSecret) {
        this.parameters.set(AADServerParamKeys.CLIENT_SECRET, encodeURIComponent(clientSecret));
      };
      RequestParameterBuilder2.prototype.addClientAssertion = function(clientAssertion) {
        if (!StringUtils.isEmpty(clientAssertion)) {
          this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION, encodeURIComponent(clientAssertion));
        }
      };
      RequestParameterBuilder2.prototype.addClientAssertionType = function(clientAssertionType) {
        if (!StringUtils.isEmpty(clientAssertionType)) {
          this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION_TYPE, encodeURIComponent(clientAssertionType));
        }
      };
      RequestParameterBuilder2.prototype.addOboAssertion = function(oboAssertion) {
        this.parameters.set(AADServerParamKeys.OBO_ASSERTION, encodeURIComponent(oboAssertion));
      };
      RequestParameterBuilder2.prototype.addRequestTokenUse = function(tokenUse) {
        this.parameters.set(AADServerParamKeys.REQUESTED_TOKEN_USE, encodeURIComponent(tokenUse));
      };
      RequestParameterBuilder2.prototype.addGrantType = function(grantType) {
        this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(grantType));
      };
      RequestParameterBuilder2.prototype.addClientInfo = function() {
        this.parameters.set(CLIENT_INFO, "1");
      };
      RequestParameterBuilder2.prototype.addExtraQueryParameters = function(eQparams) {
        var _this = this;
        RequestValidator.sanitizeEQParams(eQparams, this.parameters);
        Object.keys(eQparams).forEach(function(key) {
          _this.parameters.set(key, eQparams[key]);
        });
      };
      RequestParameterBuilder2.prototype.addClientCapabilitiesToClaims = function(claims, clientCapabilities) {
        var mergedClaims;
        if (!claims) {
          mergedClaims = {};
        } else {
          try {
            mergedClaims = JSON.parse(claims);
          } catch (e) {
            throw ClientConfigurationError.createInvalidClaimsRequestError();
          }
        }
        if (clientCapabilities && clientCapabilities.length > 0) {
          if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
          }
          mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
            values: clientCapabilities
          };
        }
        return JSON.stringify(mergedClaims);
      };
      RequestParameterBuilder2.prototype.addUsername = function(username) {
        this.parameters.set(PasswordGrantConstants.username, encodeURIComponent(username));
      };
      RequestParameterBuilder2.prototype.addPassword = function(password) {
        this.parameters.set(PasswordGrantConstants.password, encodeURIComponent(password));
      };
      RequestParameterBuilder2.prototype.addPopToken = function(cnfString) {
        if (!StringUtils.isEmpty(cnfString)) {
          this.parameters.set(AADServerParamKeys.TOKEN_TYPE, exports2.AuthenticationScheme.POP);
          this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(cnfString));
        }
      };
      RequestParameterBuilder2.prototype.addSshJwk = function(sshJwkString) {
        if (!StringUtils.isEmpty(sshJwkString)) {
          this.parameters.set(AADServerParamKeys.TOKEN_TYPE, exports2.AuthenticationScheme.SSH);
          this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(sshJwkString));
        }
      };
      RequestParameterBuilder2.prototype.addServerTelemetry = function(serverTelemetryManager) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
        this.parameters.set(AADServerParamKeys.X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
      };
      RequestParameterBuilder2.prototype.addThrottling = function() {
        this.parameters.set(AADServerParamKeys.X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
      };
      RequestParameterBuilder2.prototype.addLogoutHint = function(logoutHint) {
        this.parameters.set(AADServerParamKeys.LOGOUT_HINT, encodeURIComponent(logoutHint));
      };
      RequestParameterBuilder2.prototype.createQueryString = function() {
        var queryParameterArray = new Array();
        this.parameters.forEach(function(value, key) {
          queryParameterArray.push(key + "=" + value);
        });
        return queryParameterArray.join("&");
      };
      return RequestParameterBuilder2;
    }();
    var IdTokenEntity = function(_super) {
      __extends(IdTokenEntity2, _super);
      function IdTokenEntity2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IdTokenEntity2.createIdTokenEntity = function(homeAccountId, environment, idToken, clientId, tenantId) {
        var idTokenEntity = new IdTokenEntity2();
        idTokenEntity.credentialType = exports2.CredentialType.ID_TOKEN;
        idTokenEntity.homeAccountId = homeAccountId;
        idTokenEntity.environment = environment;
        idTokenEntity.clientId = clientId;
        idTokenEntity.secret = idToken;
        idTokenEntity.realm = tenantId;
        return idTokenEntity;
      };
      IdTokenEntity2.isIdTokenEntity = function(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === exports2.CredentialType.ID_TOKEN;
      };
      return IdTokenEntity2;
    }(CredentialEntity);
    var TimeUtils = function() {
      function TimeUtils2() {
      }
      TimeUtils2.nowSeconds = function() {
        return Math.round(new Date().getTime() / 1e3);
      };
      TimeUtils2.isTokenExpired = function(expiresOn, offset) {
        var expirationSec = Number(expiresOn) || 0;
        var offsetCurrentTimeSec = TimeUtils2.nowSeconds() + offset;
        return offsetCurrentTimeSec > expirationSec;
      };
      TimeUtils2.wasClockTurnedBack = function(cachedAt) {
        var cachedAtSec = Number(cachedAt);
        return cachedAtSec > TimeUtils2.nowSeconds();
      };
      TimeUtils2.delay = function(t, value) {
        return new Promise(function(resolve) {
          return setTimeout(function() {
            return resolve(value);
          }, t);
        });
      };
      return TimeUtils2;
    }();
    var AccessTokenEntity = function(_super) {
      __extends(AccessTokenEntity2, _super);
      function AccessTokenEntity2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AccessTokenEntity2.createAccessTokenEntity = function(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
        var _a, _b;
        var atEntity = new AccessTokenEntity2();
        atEntity.homeAccountId = homeAccountId;
        atEntity.credentialType = exports2.CredentialType.ACCESS_TOKEN;
        atEntity.secret = accessToken;
        var currentTime = TimeUtils.nowSeconds();
        atEntity.cachedAt = currentTime.toString();
        atEntity.expiresOn = expiresOn.toString();
        atEntity.extendedExpiresOn = extExpiresOn.toString();
        if (refreshOn) {
          atEntity.refreshOn = refreshOn.toString();
        }
        atEntity.environment = environment;
        atEntity.clientId = clientId;
        atEntity.realm = tenantId;
        atEntity.target = scopes;
        atEntity.userAssertionHash = userAssertionHash;
        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? exports2.AuthenticationScheme.BEARER : tokenType;
        if (requestedClaims) {
          atEntity.requestedClaims = requestedClaims;
          atEntity.requestedClaimsHash = requestedClaimsHash;
        }
        if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== exports2.AuthenticationScheme.BEARER.toLowerCase()) {
          atEntity.credentialType = exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
          switch (atEntity.tokenType) {
            case exports2.AuthenticationScheme.POP:
              var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);
              if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {
                throw ClientAuthError.createTokenClaimsRequiredError();
              }
              atEntity.keyId = tokenClaims.cnf.kid;
              break;
            case exports2.AuthenticationScheme.SSH:
              atEntity.keyId = keyId;
          }
        }
        return atEntity;
      };
      AccessTokenEntity2.isAccessTokenEntity = function(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity.hasOwnProperty("target") && (entity["credentialType"] === exports2.CredentialType.ACCESS_TOKEN || entity["credentialType"] === exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
      };
      return AccessTokenEntity2;
    }(CredentialEntity);
    var RefreshTokenEntity = function(_super) {
      __extends(RefreshTokenEntity2, _super);
      function RefreshTokenEntity2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      RefreshTokenEntity2.createRefreshTokenEntity = function(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash) {
        var rtEntity = new RefreshTokenEntity2();
        rtEntity.clientId = clientId;
        rtEntity.credentialType = exports2.CredentialType.REFRESH_TOKEN;
        rtEntity.environment = environment;
        rtEntity.homeAccountId = homeAccountId;
        rtEntity.secret = refreshToken;
        rtEntity.userAssertionHash = userAssertionHash;
        if (familyId)
          rtEntity.familyId = familyId;
        return rtEntity;
      };
      RefreshTokenEntity2.isRefreshTokenEntity = function(entity) {
        if (!entity) {
          return false;
        }
        return entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === exports2.CredentialType.REFRESH_TOKEN;
      };
      return RefreshTokenEntity2;
    }(CredentialEntity);
    var InteractionRequiredServerErrorMessage = [
      "interaction_required",
      "consent_required",
      "login_required"
    ];
    var InteractionRequiredAuthSubErrorMessage = [
      "message_only",
      "additional_action",
      "basic_action",
      "user_password_expired",
      "consent_required"
    ];
    var InteractionRequiredAuthErrorMessage = {
      noTokensFoundError: {
        code: "no_tokens_found",
        desc: "No refresh token found in the cache. Please sign-in."
      },
      native_account_unavailable: {
        code: "native_account_unavailable",
        desc: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API."
      }
    };
    var InteractionRequiredAuthError = function(_super) {
      __extends(InteractionRequiredAuthError2, _super);
      function InteractionRequiredAuthError2(errorCode, errorMessage, subError) {
        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
        _this.name = "InteractionRequiredAuthError";
        Object.setPrototypeOf(_this, InteractionRequiredAuthError2.prototype);
        return _this;
      }
      InteractionRequiredAuthError2.isInteractionRequiredError = function(errorCode, errorString, subError) {
        var isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
        var isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
        var isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some(function(irErrorCode) {
          return errorString.indexOf(irErrorCode) > -1;
        });
        return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
      };
      InteractionRequiredAuthError2.createNoTokensFoundError = function() {
        return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.noTokensFoundError.code, InteractionRequiredAuthErrorMessage.noTokensFoundError.desc);
      };
      InteractionRequiredAuthError2.createNativeAccountUnavailableError = function() {
        return new InteractionRequiredAuthError2(InteractionRequiredAuthErrorMessage.native_account_unavailable.code, InteractionRequiredAuthErrorMessage.native_account_unavailable.desc);
      };
      return InteractionRequiredAuthError2;
    }(AuthError);
    var CacheRecord = function() {
      function CacheRecord2(accountEntity, idTokenEntity, accessTokenEntity, refreshTokenEntity, appMetadataEntity) {
        this.account = accountEntity || null;
        this.idToken = idTokenEntity || null;
        this.accessToken = accessTokenEntity || null;
        this.refreshToken = refreshTokenEntity || null;
        this.appMetadata = appMetadataEntity || null;
      }
      return CacheRecord2;
    }();
    var ProtocolUtils = function() {
      function ProtocolUtils2() {
      }
      ProtocolUtils2.setRequestState = function(cryptoObj, userState, meta) {
        var libraryState = ProtocolUtils2.generateLibraryState(cryptoObj, meta);
        return !StringUtils.isEmpty(userState) ? "" + libraryState + Constants.RESOURCE_DELIM + userState : libraryState;
      };
      ProtocolUtils2.generateLibraryState = function(cryptoObj, meta) {
        if (!cryptoObj) {
          throw ClientAuthError.createNoCryptoObjectError("generateLibraryState");
        }
        var stateObj = {
          id: cryptoObj.createNewGuid()
        };
        if (meta) {
          stateObj.meta = meta;
        }
        var stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString);
      };
      ProtocolUtils2.parseRequestState = function(cryptoObj, state) {
        if (!cryptoObj) {
          throw ClientAuthError.createNoCryptoObjectError("parseRequestState");
        }
        if (StringUtils.isEmpty(state)) {
          throw ClientAuthError.createInvalidStateError(state, "Null, undefined or empty state");
        }
        try {
          var splitState = state.split(Constants.RESOURCE_DELIM);
          var libraryState = splitState[0];
          var userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
          var libraryStateString = cryptoObj.base64Decode(libraryState);
          var libraryStateObj = JSON.parse(libraryStateString);
          return {
            userRequestState: !StringUtils.isEmpty(userState) ? userState : Constants.EMPTY_STRING,
            libraryState: libraryStateObj
          };
        } catch (e) {
          throw ClientAuthError.createInvalidStateError(state, e);
        }
      };
      return ProtocolUtils2;
    }();
    var UrlString = function() {
      function UrlString2(url) {
        this._urlString = url;
        if (StringUtils.isEmpty(this._urlString)) {
          throw ClientConfigurationError.createUrlEmptyError();
        }
        if (StringUtils.isEmpty(this.getHash())) {
          this._urlString = UrlString2.canonicalizeUri(url);
        }
      }
      Object.defineProperty(UrlString2.prototype, "urlString", {
        get: function() {
          return this._urlString;
        },
        enumerable: false,
        configurable: true
      });
      UrlString2.canonicalizeUri = function(url) {
        if (url) {
          var lowerCaseUrl = url.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, "?")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1);
          } else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2);
          }
          if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
            lowerCaseUrl += "/";
          }
          return lowerCaseUrl;
        }
        return url;
      };
      UrlString2.prototype.validateAsUri = function() {
        var components;
        try {
          components = this.getUrlComponents();
        } catch (e) {
          throw ClientConfigurationError.createUrlParseError(e);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
          throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
        }
      };
      UrlString2.appendQueryString = function(url, queryString) {
        if (StringUtils.isEmpty(queryString)) {
          return url;
        }
        return url.indexOf("?") < 0 ? url + "?" + queryString : url + "&" + queryString;
      };
      UrlString2.removeHashFromUrl = function(url) {
        return UrlString2.canonicalizeUri(url.split("#")[0]);
      };
      UrlString2.prototype.replaceTenantPath = function(tenantId) {
        var urlObject = this.getUrlComponents();
        var pathArray = urlObject.PathSegments;
        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {
          pathArray[0] = tenantId;
        }
        return UrlString2.constructAuthorityUriFromObject(urlObject);
      };
      UrlString2.prototype.getHash = function() {
        return UrlString2.parseHash(this.urlString);
      };
      UrlString2.prototype.getUrlComponents = function() {
        var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        var match = this.urlString.match(regEx);
        if (!match) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        var urlComponents = {
          Protocol: match[1],
          HostNameAndPort: match[4],
          AbsolutePath: match[5],
          QueryString: match[7]
        };
        var pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter(function(val) {
          return val && val.length > 0;
        });
        urlComponents.PathSegments = pathSegments;
        if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith("/")) {
          urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
        }
        return urlComponents;
      };
      UrlString2.getDomainFromUrl = function(url) {
        var regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        var match = url.match(regEx);
        if (!match) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + url);
        }
        return match[2];
      };
      UrlString2.getAbsoluteUrl = function(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
          var url = new UrlString2(baseUrl);
          var baseComponents = url.getUrlComponents();
          return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
        }
        return relativeUrl;
      };
      UrlString2.parseHash = function(hashString) {
        var hashIndex1 = hashString.indexOf("#");
        var hashIndex2 = hashString.indexOf("#/");
        if (hashIndex2 > -1) {
          return hashString.substring(hashIndex2 + 2);
        } else if (hashIndex1 > -1) {
          return hashString.substring(hashIndex1 + 1);
        }
        return Constants.EMPTY_STRING;
      };
      UrlString2.parseQueryString = function(queryString) {
        var queryIndex1 = queryString.indexOf("?");
        var queryIndex2 = queryString.indexOf("/?");
        if (queryIndex2 > -1) {
          return queryString.substring(queryIndex2 + 2);
        } else if (queryIndex1 > -1) {
          return queryString.substring(queryIndex1 + 1);
        }
        return Constants.EMPTY_STRING;
      };
      UrlString2.constructAuthorityUriFromObject = function(urlObject) {
        return new UrlString2(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
      };
      UrlString2.getDeserializedHash = function(hash) {
        if (StringUtils.isEmpty(hash)) {
          return {};
        }
        var parsedHash = UrlString2.parseHash(hash);
        var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);
        if (!deserializedHash) {
          throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));
        }
        return deserializedHash;
      };
      UrlString2.getDeserializedQueryString = function(query) {
        if (StringUtils.isEmpty(query)) {
          return {};
        }
        var parsedQueryString = UrlString2.parseQueryString(query);
        var deserializedQueryString = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);
        if (!deserializedQueryString) {
          throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));
        }
        return deserializedQueryString;
      };
      UrlString2.hashContainsKnownProperties = function(hash) {
        if (StringUtils.isEmpty(hash) || hash.indexOf("=") < 0) {
          return false;
        }
        var parameters = UrlString2.getDeserializedHash(hash);
        return !!(parameters.code || parameters.error_description || parameters.error || parameters.state);
      };
      return UrlString2;
    }();
    var KeyLocation;
    (function(KeyLocation2) {
      KeyLocation2["SW"] = "sw";
      KeyLocation2["UHW"] = "uhw";
    })(KeyLocation || (KeyLocation = {}));
    var PopTokenGenerator = function() {
      function PopTokenGenerator2(cryptoUtils) {
        this.cryptoUtils = cryptoUtils;
      }
      PopTokenGenerator2.prototype.generateCnf = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var reqCnf, reqCnfString, _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.generateKid(request)];
              case 1:
                reqCnf = _b.sent();
                reqCnfString = this.cryptoUtils.base64Encode(JSON.stringify(reqCnf));
                _a = {
                  kid: reqCnf.kid,
                  reqCnfString
                };
                return [4, this.cryptoUtils.hashString(reqCnfString)];
              case 2:
                return [2, (_a.reqCnfHash = _b.sent(), _a)];
            }
          });
        });
      };
      PopTokenGenerator2.prototype.generateKid = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var kidThumbprint;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.cryptoUtils.getPublicKeyThumbprint(request)];
              case 1:
                kidThumbprint = _a.sent();
                return [2, {
                  kid: kidThumbprint,
                  xms_ksl: KeyLocation.SW
                }];
            }
          });
        });
      };
      PopTokenGenerator2.prototype.signPopToken = function(accessToken, keyId, request) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.signPayload(accessToken, keyId, request)];
          });
        });
      };
      PopTokenGenerator2.prototype.signPayload = function(payload, keyId, request, claims) {
        return __awaiter(this, void 0, void 0, function() {
          var resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, resourceUrlString, resourceUrlComponents;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                resourceRequestMethod = request.resourceRequestMethod, resourceRequestUri = request.resourceRequestUri, shrClaims = request.shrClaims, shrNonce = request.shrNonce;
                resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : void 0;
                resourceUrlComponents = resourceUrlString === null || resourceUrlString === void 0 ? void 0 : resourceUrlString.getUrlComponents();
                return [4, this.cryptoUtils.signJwt(__assign({ at: payload, ts: TimeUtils.nowSeconds(), m: resourceRequestMethod === null || resourceRequestMethod === void 0 ? void 0 : resourceRequestMethod.toUpperCase(), u: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.HostNameAndPort, nonce: shrNonce || this.cryptoUtils.createNewGuid(), p: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.AbsolutePath, q: (resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : void 0, client_claims: shrClaims || void 0 }, claims), keyId, request.correlationId)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      return PopTokenGenerator2;
    }();
    var AppMetadataEntity = function() {
      function AppMetadataEntity2() {
      }
      AppMetadataEntity2.prototype.generateAppMetadataKey = function() {
        return AppMetadataEntity2.generateAppMetadataCacheKey(this.environment, this.clientId);
      };
      AppMetadataEntity2.generateAppMetadataCacheKey = function(environment, clientId) {
        var appMetaDataKeyArray = [
          APP_METADATA,
          environment,
          clientId
        ];
        return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
      };
      AppMetadataEntity2.createAppMetadataEntity = function(clientId, environment, familyId) {
        var appMetadata = new AppMetadataEntity2();
        appMetadata.clientId = clientId;
        appMetadata.environment = environment;
        if (familyId) {
          appMetadata.familyId = familyId;
        }
        return appMetadata;
      };
      AppMetadataEntity2.isAppMetadataEntity = function(key, entity) {
        if (!entity) {
          return false;
        }
        return key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment");
      };
      return AppMetadataEntity2;
    }();
    var TokenCacheContext = function() {
      function TokenCacheContext2(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged;
      }
      Object.defineProperty(TokenCacheContext2.prototype, "cacheHasChanged", {
        get: function() {
          return this.hasChanged;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TokenCacheContext2.prototype, "tokenCache", {
        get: function() {
          return this.cache;
        },
        enumerable: false,
        configurable: true
      });
      return TokenCacheContext2;
    }();
    var ResponseHandler = function() {
      function ResponseHandler2(clientId, cacheStorage, cryptoObj, logger2, serializableCache, persistencePlugin) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger2;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin;
      }
      ResponseHandler2.prototype.validateServerAuthorizationCodeResponse = function(serverResponseHash, cachedState, cryptoObj) {
        if (!serverResponseHash.state || !cachedState) {
          throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError("Server State") : ClientAuthError.createStateNotFoundError("Cached State");
        }
        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {
          throw ClientAuthError.createStateMismatchError();
        }
        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {
          if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {
            throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
          }
          throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
        }
        if (serverResponseHash.client_info) {
          buildClientInfo(serverResponseHash.client_info, cryptoObj);
        }
      };
      ResponseHandler2.prototype.validateTokenResponse = function(serverResponse) {
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);
          }
          var errString = serverResponse.error_codes + " - [" + serverResponse.timestamp + "]: " + serverResponse.error_description + " - Correlation ID: " + serverResponse.correlation_id + " - Trace ID: " + serverResponse.trace_id;
          throw new ServerError(serverResponse.error, errString, serverResponse.suberror);
        }
      };
      ResponseHandler2.prototype.handleServerTokenResponse = function(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse) {
        return __awaiter(this, void 0, void 0, function() {
          var idTokenObj, requestStateObj, cacheRecord, cacheContext, key, account;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (serverTokenResponse.id_token) {
                  idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);
                  if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {
                    if (idTokenObj.claims.nonce !== authCodePayload.nonce) {
                      throw ClientAuthError.createNonceMismatchError();
                    }
                  }
                }
                this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);
                if (!!authCodePayload && !!authCodePayload.state) {
                  requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
                }
                serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || void 0;
                cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);
                _a.label = 1;
              case 1:
                _a.trys.push([1, , 5, 8]);
                if (!(this.persistencePlugin && this.serializableCache))
                  return [3, 3];
                this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
                cacheContext = new TokenCacheContext(this.serializableCache, true);
                return [4, this.persistencePlugin.beforeCacheAccess(cacheContext)];
              case 2:
                _a.sent();
                _a.label = 3;
              case 3:
                if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
                  key = cacheRecord.account.generateAccountKey();
                  account = this.cacheStorage.getAccount(key);
                  if (!account) {
                    this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
                    return [2, ResponseHandler2.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, void 0)];
                  }
                }
                return [4, this.cacheStorage.saveCacheRecord(cacheRecord)];
              case 4:
                _a.sent();
                return [3, 8];
              case 5:
                if (!(this.persistencePlugin && this.serializableCache && cacheContext))
                  return [3, 7];
                this.logger.verbose("Persistence enabled, calling afterCacheAccess");
                return [4, this.persistencePlugin.afterCacheAccess(cacheContext)];
              case 6:
                _a.sent();
                _a.label = 7;
              case 7:
                return [7];
              case 8:
                return [2, ResponseHandler2.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse.spa_code)];
            }
          });
        });
      };
      ResponseHandler2.prototype.generateCacheRecord = function(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {
        var env = authority.getPreferredCache();
        if (StringUtils.isEmpty(env)) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        var cachedIdToken;
        var cachedAccount;
        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {
          cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);
          cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);
        }
        var cachedAccessToken = null;
        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {
          var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
          var expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
          var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
          var refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || void 0;
          var tokenExpirationSeconds = reqTimestamp + expiresIn;
          var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : void 0;
          cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
        }
        var cachedRefreshToken = null;
        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {
          cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);
        }
        var cachedAppMetadata = null;
        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {
          cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);
        }
        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);
      };
      ResponseHandler2.prototype.generateAccountEntity = function(serverTokenResponse, idToken, authority, authCodePayload) {
        var authorityType = authority.authorityType;
        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;
        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;
        if (authorityType === exports2.AuthorityType.Adfs) {
          this.logger.verbose("Authority type is ADFS, creating ADFS account");
          return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
        }
        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === "AAD") {
          throw ClientAuthError.createClientInfoEmptyError();
        }
        return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
      };
      ResponseHandler2.generateAuthenticationResult = function(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, code2) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function() {
          var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                accessToken = Constants.EMPTY_STRING;
                responseScopes = [];
                expiresOn = null;
                familyId = Constants.EMPTY_STRING;
                if (!cacheRecord.accessToken)
                  return [3, 4];
                if (!(cacheRecord.accessToken.tokenType === exports2.AuthenticationScheme.POP))
                  return [3, 2];
                popTokenGenerator = new PopTokenGenerator(cryptoObj);
                _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;
                if (!keyId) {
                  throw ClientAuthError.createKeyIdMissingError();
                }
                return [4, popTokenGenerator.signPopToken(secret, keyId, request)];
              case 1:
                accessToken = _e.sent();
                return [3, 3];
              case 2:
                accessToken = cacheRecord.accessToken.secret;
                _e.label = 3;
              case 3:
                responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
                expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1e3);
                extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1e3);
                _e.label = 4;
              case 4:
                if (cacheRecord.appMetadata) {
                  familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;
                }
                uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;
                tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;
                return [2, {
                  authority: authority.canonicalAuthority,
                  uniqueId: uid,
                  tenantId: tid,
                  scopes: responseScopes,
                  account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,
                  idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,
                  idTokenClaims: idTokenObj ? idTokenObj.claims : {},
                  accessToken,
                  fromCache: fromTokenCache,
                  expiresOn,
                  correlationId: request.correlationId,
                  extExpiresOn,
                  familyId,
                  tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,
                  state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
                  cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,
                  msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,
                  code: code2,
                  fromNativeBroker: false
                }];
            }
          });
        });
      };
      return ResponseHandler2;
    }();
    var AuthorizationCodeClient = function(_super) {
      __extends(AuthorizationCodeClient2, _super);
      function AuthorizationCodeClient2(configuration) {
        var _this = _super.call(this, configuration) || this;
        _this.includeRedirectUri = true;
        return _this;
      }
      AuthorizationCodeClient2.prototype.getAuthCodeUrl = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var queryString;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.createAuthCodeUrlQueryString(request)];
              case 1:
                queryString = _a.sent();
                return [2, UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.acquireToken = function(request, authCodePayload) {
        return __awaiter(this, void 0, void 0, function() {
          var reqTimestamp, response, responseHandler;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.logger.info("in acquireToken call");
                if (!request || StringUtils.isEmpty(request.code)) {
                  throw ClientAuthError.createTokenRequestCannotBeMadeError();
                }
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executeTokenRequest(this.authority, request)];
              case 1:
                response = _a.sent();
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response.body);
                return [4, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.handleFragmentResponse = function(hashFragment, cachedState) {
        var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);
        var hashUrlString = new UrlString(hashFragment);
        var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());
        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);
        if (!serverParams.code) {
          throw ClientAuthError.createNoAuthCodeInServerResponseError();
        }
        return __assign(__assign({}, serverParams), {
          code: serverParams.code
        });
      };
      AuthorizationCodeClient2.prototype.getLogoutUri = function(logoutRequest) {
        if (!logoutRequest) {
          throw ClientConfigurationError.createEmptyLogoutRequestError();
        }
        var queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
      };
      AuthorizationCodeClient2.prototype.executeTokenRequest = function(authority, request) {
        return __awaiter(this, void 0, void 0, function() {
          var thumbprint, requestBody, queryParameters, ccsCredential, clientInfo, headers, endpoint;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: authority.canonicalAuthority,
                  scopes: request.scopes,
                  claims: request.claims,
                  authenticationScheme: request.authenticationScheme,
                  resourceRequestMethod: request.resourceRequestMethod,
                  resourceRequestUri: request.resourceRequestUri,
                  shrClaims: request.shrClaims,
                  sshKid: request.sshKid
                };
                return [4, this.createTokenRequestBody(request)];
              case 1:
                requestBody = _a.sent();
                queryParameters = this.createTokenQueryParameters(request);
                ccsCredential = void 0;
                if (request.clientInfo) {
                  try {
                    clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
                    ccsCredential = {
                      credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                      type: exports2.CcsCredentialType.HOME_ACCOUNT_ID
                    };
                  } catch (e) {
                    this.logger.verbose("Could not parse client info for CCS Header: " + e);
                  }
                }
                headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
                endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : authority.tokenEndpoint + "?" + queryParameters;
                return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.createTokenQueryParameters = function(request) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request.tokenQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);
        }
        return parameterBuilder.createQueryString();
      };
      AuthorizationCodeClient2.prototype.createTokenRequestBody = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;
          var _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                parameterBuilder = new RequestParameterBuilder();
                parameterBuilder.addClientId(this.config.authOptions.clientId);
                if (!this.includeRedirectUri) {
                  RequestValidator.validateRedirectUri(request.redirectUri);
                } else {
                  parameterBuilder.addRedirectUri(request.redirectUri);
                }
                parameterBuilder.addScopes(request.scopes);
                parameterBuilder.addAuthorizationCode(request.code);
                parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                parameterBuilder.addThrottling();
                if (this.serverTelemetryManager) {
                  parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
                }
                if (request.codeVerifier) {
                  parameterBuilder.addCodeVerifier(request.codeVerifier);
                }
                if (this.config.clientCredentials.clientSecret) {
                  parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
                }
                if (this.config.clientCredentials.clientAssertion) {
                  clientAssertion = this.config.clientCredentials.clientAssertion;
                  parameterBuilder.addClientAssertion(clientAssertion.assertion);
                  parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
                }
                parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);
                parameterBuilder.addClientInfo();
                if (!(request.authenticationScheme === exports2.AuthenticationScheme.POP))
                  return [3, 2];
                popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                return [4, popTokenGenerator.generateCnf(request)];
              case 1:
                reqCnfData = _b.sent();
                parameterBuilder.addPopToken(reqCnfData.reqCnfString);
                return [3, 3];
              case 2:
                if (request.authenticationScheme === exports2.AuthenticationScheme.SSH) {
                  if (request.sshJwk) {
                    parameterBuilder.addSshJwk(request.sshJwk);
                  } else {
                    throw ClientConfigurationError.createMissingSshJwkError();
                  }
                }
                _b.label = 3;
              case 3:
                correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
                parameterBuilder.addCorrelationId(correlationId);
                if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                  parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
                }
                ccsCred = void 0;
                if (request.clientInfo) {
                  try {
                    clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
                    ccsCred = {
                      credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
                      type: exports2.CcsCredentialType.HOME_ACCOUNT_ID
                    };
                  } catch (e) {
                    this.logger.verbose("Could not parse client info for CCS Header: " + e);
                  }
                } else {
                  ccsCred = request.ccsCredential;
                }
                if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
                  switch (ccsCred.type) {
                    case exports2.CcsCredentialType.HOME_ACCOUNT_ID:
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                      }
                      break;
                    case exports2.CcsCredentialType.UPN:
                      parameterBuilder.addCcsUpn(ccsCred.credential);
                      break;
                  }
                }
                if (request.tokenBodyParameters) {
                  parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);
                }
                if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {
                  parameterBuilder.addExtraQueryParameters((_a = {}, _a[AADServerParamKeys.RETURN_SPA_CODE] = "1", _a));
                }
                return [2, parameterBuilder.createQueryString()];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.createAuthCodeUrlQueryString = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                parameterBuilder = new RequestParameterBuilder();
                parameterBuilder.addClientId(this.config.authOptions.clientId);
                requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);
                parameterBuilder.addScopes(requestScopes);
                parameterBuilder.addRedirectUri(request.redirectUri);
                correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
                parameterBuilder.addCorrelationId(correlationId);
                parameterBuilder.addResponseMode(request.responseMode);
                parameterBuilder.addResponseTypeCode();
                parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                parameterBuilder.addClientInfo();
                if (request.codeChallenge && request.codeChallengeMethod) {
                  parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);
                }
                if (request.prompt) {
                  parameterBuilder.addPrompt(request.prompt);
                }
                if (request.domainHint) {
                  parameterBuilder.addDomainHint(request.domainHint);
                }
                if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
                  if (request.sid && request.prompt === PromptValue.NONE) {
                    this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
                    parameterBuilder.addSid(request.sid);
                  } else if (request.account) {
                    accountSid = this.extractAccountSid(request.account);
                    accountLoginHintClaim = this.extractLoginHint(request.account);
                    if (accountLoginHintClaim) {
                      this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
                      parameterBuilder.addLoginHint(accountLoginHintClaim);
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                      }
                    } else if (accountSid && request.prompt === PromptValue.NONE) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
                      parameterBuilder.addSid(accountSid);
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                      }
                    } else if (request.loginHint) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
                      parameterBuilder.addLoginHint(request.loginHint);
                      parameterBuilder.addCcsUpn(request.loginHint);
                    } else if (request.account.username) {
                      this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
                      parameterBuilder.addLoginHint(request.account.username);
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
                      }
                    }
                  } else if (request.loginHint) {
                    this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
                    parameterBuilder.addLoginHint(request.loginHint);
                    parameterBuilder.addCcsUpn(request.loginHint);
                  }
                } else {
                  this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
                }
                if (request.nonce) {
                  parameterBuilder.addNonce(request.nonce);
                }
                if (request.state) {
                  parameterBuilder.addState(request.state);
                }
                if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                  parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
                }
                if (request.extraQueryParameters) {
                  parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);
                }
                if (!request.nativeBroker)
                  return [3, 2];
                parameterBuilder.addNativeBroker();
                if (!(request.authenticationScheme === exports2.AuthenticationScheme.POP))
                  return [3, 2];
                popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                return [4, popTokenGenerator.generateCnf(request)];
              case 1:
                reqCnfData = _a.sent();
                parameterBuilder.addPopToken(reqCnfData.reqCnfHash);
                _a.label = 2;
              case 2:
                return [2, parameterBuilder.createQueryString()];
            }
          });
        });
      };
      AuthorizationCodeClient2.prototype.createLogoutUrlQueryString = function(request) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request.postLogoutRedirectUri) {
          parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);
        }
        if (request.correlationId) {
          parameterBuilder.addCorrelationId(request.correlationId);
        }
        if (request.idTokenHint) {
          parameterBuilder.addIdTokenHint(request.idTokenHint);
        }
        if (request.state) {
          parameterBuilder.addState(request.state);
        }
        if (request.logoutHint) {
          parameterBuilder.addLogoutHint(request.logoutHint);
        }
        if (request.extraQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);
        }
        return parameterBuilder.createQueryString();
      };
      AuthorizationCodeClient2.prototype.extractAccountSid = function(account) {
        var _a;
        return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.sid) || null;
      };
      AuthorizationCodeClient2.prototype.extractLoginHint = function(account) {
        var _a;
        return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.login_hint) || null;
      };
      return AuthorizationCodeClient2;
    }(BaseClient);
    var DeviceCodeClient = function(_super) {
      __extends(DeviceCodeClient2, _super);
      function DeviceCodeClient2(configuration) {
        return _super.call(this, configuration) || this;
      }
      DeviceCodeClient2.prototype.acquireToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var deviceCodeResponse, reqTimestamp, response, responseHandler;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getDeviceCode(request)];
              case 1:
                deviceCodeResponse = _a.sent();
                request.deviceCodeCallback(deviceCodeResponse);
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.acquireTokenWithDeviceCode(request, deviceCodeResponse)];
              case 2:
                response = _a.sent();
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response);
                return [4, responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request)];
              case 3:
                return [2, _a.sent()];
            }
          });
        });
      };
      DeviceCodeClient2.prototype.getDeviceCode = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var queryString, headers, thumbprint;
          return __generator(this, function(_a) {
            queryString = this.createQueryString(request);
            headers = this.createTokenRequestHeaders();
            thumbprint = {
              clientId: this.config.authOptions.clientId,
              authority: request.authority,
              scopes: request.scopes,
              claims: request.claims,
              authenticationScheme: request.authenticationScheme,
              resourceRequestMethod: request.resourceRequestMethod,
              resourceRequestUri: request.resourceRequestUri,
              shrClaims: request.shrClaims,
              sshKid: request.sshKid
            };
            return [2, this.executePostRequestToDeviceCodeEndpoint(this.authority.deviceCodeEndpoint, queryString, headers, thumbprint)];
          });
        });
      };
      DeviceCodeClient2.prototype.executePostRequestToDeviceCodeEndpoint = function(deviceCodeEndpoint, queryString, headers, thumbprint) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, userCode, deviceCode, verificationUri, expiresIn, interval, message;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.networkManager.sendPostRequest(thumbprint, deviceCodeEndpoint, {
                  body: queryString,
                  headers,
                  proxyUrl: this.config.systemOptions.proxyUrl
                })];
              case 1:
                _a = _b.sent().body, userCode = _a.user_code, deviceCode = _a.device_code, verificationUri = _a.verification_uri, expiresIn = _a.expires_in, interval = _a.interval, message = _a.message;
                return [2, {
                  userCode,
                  deviceCode,
                  verificationUri,
                  expiresIn,
                  interval,
                  message
                }];
            }
          });
        });
      };
      DeviceCodeClient2.prototype.createQueryString = function(request) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addScopes(request.scopes);
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
      };
      DeviceCodeClient2.prototype.continuePolling = function(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
        if (userSpecifiedCancelFlag) {
          this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
          throw ClientAuthError.createDeviceCodeCancelledError();
        } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils.nowSeconds() > userSpecifiedTimeout) {
          this.logger.error("User defined timeout for device code polling reached. The timeout was set for " + userSpecifiedTimeout);
          throw ClientAuthError.createUserTimeoutReachedError();
        } else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {
          if (userSpecifiedTimeout) {
            this.logger.verbose("User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for " + userSpecifiedTimeout);
          }
          this.logger.error("Device code expired. Expiration time of device code was " + deviceCodeExpirationTime);
          throw ClientAuthError.createDeviceCodeExpiredError();
        }
        return true;
      };
      DeviceCodeClient2.prototype.acquireTokenWithDeviceCode = function(request, deviceCodeResponse) {
        return __awaiter(this, void 0, void 0, function() {
          var requestBody, headers, userSpecifiedTimeout, deviceCodeExpirationTime, pollingIntervalMilli, thumbprint, response;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                requestBody = this.createTokenRequestBody(request, deviceCodeResponse);
                headers = this.createTokenRequestHeaders();
                userSpecifiedTimeout = request.timeout ? TimeUtils.nowSeconds() + request.timeout : void 0;
                deviceCodeExpirationTime = TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;
                pollingIntervalMilli = deviceCodeResponse.interval * 1e3;
                _a.label = 1;
              case 1:
                if (!this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel))
                  return [3, 8];
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: request.authority,
                  scopes: request.scopes,
                  claims: request.claims,
                  authenticationScheme: request.authenticationScheme,
                  resourceRequestMethod: request.resourceRequestMethod,
                  resourceRequestUri: request.resourceRequestUri,
                  shrClaims: request.shrClaims,
                  sshKid: request.sshKid
                };
                return [4, this.executePostToTokenEndpoint(this.authority.tokenEndpoint, requestBody, headers, thumbprint)];
              case 2:
                response = _a.sent();
                if (!(response.body && response.body.error))
                  return [3, 6];
                if (!(response.body.error === Constants.AUTHORIZATION_PENDING))
                  return [3, 4];
                this.logger.info("Authorization pending. Continue polling.");
                return [4, TimeUtils.delay(pollingIntervalMilli)];
              case 3:
                _a.sent();
                return [3, 5];
              case 4:
                this.logger.info("Unexpected error in polling from the server");
                throw ServerError.createPostRequestFailed(response.body.error);
              case 5:
                return [3, 7];
              case 6:
                this.logger.verbose("Authorization completed successfully. Polling stopped.");
                return [2, response.body];
              case 7:
                return [3, 1];
              case 8:
                this.logger.error("Polling stopped for unknown reasons.");
                throw ClientAuthError.createDeviceCodeUnknownError();
            }
          });
        });
      };
      DeviceCodeClient2.prototype.createTokenRequestBody = function(request, deviceCodeResponse) {
        var requestParameters = new RequestParameterBuilder();
        requestParameters.addScopes(request.scopes);
        requestParameters.addClientId(this.config.authOptions.clientId);
        requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);
        requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        requestParameters.addCorrelationId(correlationId);
        requestParameters.addClientInfo();
        requestParameters.addLibraryInfo(this.config.libraryInfo);
        requestParameters.addApplicationTelemetry(this.config.telemetry.application);
        requestParameters.addThrottling();
        if (this.serverTelemetryManager) {
          requestParameters.addServerTelemetry(this.serverTelemetryManager);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          requestParameters.addClaims(request.claims, this.config.authOptions.clientCapabilities);
        }
        return requestParameters.createQueryString();
      };
      return DeviceCodeClient2;
    }(BaseClient);
    exports2.PerformanceEvents = void 0;
    (function(PerformanceEvents) {
      PerformanceEvents["AcquireTokenByCode"] = "acquireTokenByCode";
      PerformanceEvents["AcquireTokenByRefreshToken"] = "acquireTokenByRefreshToken";
      PerformanceEvents["AcquireTokenSilent"] = "acquireTokenSilent";
      PerformanceEvents["AcquireTokenSilentAsync"] = "acquireTokenSilentAsync";
      PerformanceEvents["AcquireTokenPopup"] = "acquireTokenPopup";
      PerformanceEvents["CryptoOptsGetPublicKeyThumbprint"] = "cryptoOptsGetPublicKeyThumbprint";
      PerformanceEvents["CryptoOptsSignJwt"] = "cryptoOptsSignJwt";
      PerformanceEvents["SilentCacheClientAcquireToken"] = "silentCacheClientAcquireToken";
      PerformanceEvents["SilentIframeClientAcquireToken"] = "silentIframeClientAcquireToken";
      PerformanceEvents["SilentRefreshClientAcquireToken"] = "silentRefreshClientAcquireToken";
      PerformanceEvents["SsoSilent"] = "ssoSilent";
      PerformanceEvents["StandardInteractionClientGetDiscoveredAuthority"] = "standardInteractionClientGetDiscoveredAuthority";
      PerformanceEvents["FetchAccountIdWithNativeBroker"] = "fetchAccountIdWithNativeBroker";
      PerformanceEvents["NativeInteractionClientAcquireToken"] = "nativeInteractionClientAcquireToken";
      PerformanceEvents["RefreshTokenClientExecuteTokenRequest"] = "refreshTokenClientExecuteTokenRequest";
      PerformanceEvents["BaseClientCreateTokenRequestHeaders"] = "baseClientCreateTokenRequestHeaders";
      PerformanceEvents["BrokerHandhshake"] = "brokerHandshake";
      PerformanceEvents["AcquireTokenByRefreshTokenInBroker"] = "acquireTokenByRefreshTokenInBroker";
      PerformanceEvents["AcquireTokenByBroker"] = "acquireTokenByBroker";
    })(exports2.PerformanceEvents || (exports2.PerformanceEvents = {}));
    exports2.PerformanceEventStatus = void 0;
    (function(PerformanceEventStatus) {
      PerformanceEventStatus[PerformanceEventStatus["NotStarted"] = 0] = "NotStarted";
      PerformanceEventStatus[PerformanceEventStatus["InProgress"] = 1] = "InProgress";
      PerformanceEventStatus[PerformanceEventStatus["Completed"] = 2] = "Completed";
    })(exports2.PerformanceEventStatus || (exports2.PerformanceEventStatus = {}));
    var RefreshTokenClient = function(_super) {
      __extends(RefreshTokenClient2, _super);
      function RefreshTokenClient2(configuration, performanceClient) {
        return _super.call(this, configuration, performanceClient) || this;
      }
      RefreshTokenClient2.prototype.acquireToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var reqTimestamp, response, responseHandler;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executeTokenRequest(request, this.authority)];
              case 1:
                response = _a.sent();
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response.body);
                return [2, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, void 0, void 0, true, request.forceCache)];
            }
          });
        });
      };
      RefreshTokenClient2.prototype.acquireTokenByRefreshToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var isFOCI, noFamilyRTInCache, clientMismatchErrorWithFamilyRT;
          return __generator(this, function(_a) {
            if (!request) {
              throw ClientConfigurationError.createEmptyTokenRequestError();
            }
            if (!request.account) {
              throw ClientAuthError.createNoAccountInSilentRequestError();
            }
            isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment, this.config.authOptions.clientId);
            if (isFOCI) {
              try {
                return [2, this.acquireTokenWithCachedRefreshToken(request, true)];
              } catch (e) {
                noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code;
                clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
                if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
                  return [2, this.acquireTokenWithCachedRefreshToken(request, false)];
                } else {
                  throw e;
                }
              }
            }
            return [2, this.acquireTokenWithCachedRefreshToken(request, false)];
          });
        });
      };
      RefreshTokenClient2.prototype.acquireTokenWithCachedRefreshToken = function(request, foci) {
        return __awaiter(this, void 0, void 0, function() {
          var refreshToken, refreshTokenRequest;
          return __generator(this, function(_a) {
            refreshToken = this.cacheManager.readRefreshTokenFromCache(this.config.authOptions.clientId, request.account, foci);
            if (!refreshToken) {
              throw InteractionRequiredAuthError.createNoTokensFoundError();
            }
            refreshTokenRequest = __assign(__assign({}, request), { refreshToken: refreshToken.secret, authenticationScheme: request.authenticationScheme || exports2.AuthenticationScheme.BEARER, ccsCredential: {
              credential: request.account.homeAccountId,
              type: exports2.CcsCredentialType.HOME_ACCOUNT_ID
            } });
            return [2, this.acquireToken(refreshTokenRequest)];
          });
        });
      };
      RefreshTokenClient2.prototype.executeTokenRequest = function(request, authority) {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
          var acquireTokenMeasurement, requestBody, queryParameters, headers, thumbprint, endpoint;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                acquireTokenMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(exports2.PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
                return [4, this.createTokenRequestBody(request)];
              case 1:
                requestBody = _b.sent();
                queryParameters = this.createTokenQueryParameters(request);
                headers = this.createTokenRequestHeaders(request.ccsCredential);
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: authority.canonicalAuthority,
                  scopes: request.scopes,
                  claims: request.claims,
                  authenticationScheme: request.authenticationScheme,
                  resourceRequestMethod: request.resourceRequestMethod,
                  resourceRequestUri: request.resourceRequestUri,
                  shrClaims: request.shrClaims,
                  sshKid: request.sshKid
                };
                endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParameters);
                return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint).then(function(result) {
                  acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                    success: true
                  });
                  return result;
                }).catch(function(error) {
                  acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                    success: false
                  });
                  throw error;
                })];
            }
          });
        });
      };
      RefreshTokenClient2.prototype.createTokenQueryParameters = function(request) {
        var parameterBuilder = new RequestParameterBuilder();
        if (request.tokenQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);
        }
        return parameterBuilder.createQueryString();
      };
      RefreshTokenClient2.prototype.createTokenRequestBody = function(request) {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
          var correlationId, acquireTokenMeasurement, parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, clientInfo;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                correlationId = request.correlationId;
                acquireTokenMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(exports2.PerformanceEvents.BaseClientCreateTokenRequestHeaders, correlationId);
                parameterBuilder = new RequestParameterBuilder();
                parameterBuilder.addClientId(this.config.authOptions.clientId);
                parameterBuilder.addScopes(request.scopes);
                parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);
                parameterBuilder.addClientInfo();
                parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
                parameterBuilder.addThrottling();
                if (this.serverTelemetryManager) {
                  parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
                }
                parameterBuilder.addCorrelationId(correlationId);
                parameterBuilder.addRefreshToken(request.refreshToken);
                if (this.config.clientCredentials.clientSecret) {
                  parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
                }
                if (this.config.clientCredentials.clientAssertion) {
                  clientAssertion = this.config.clientCredentials.clientAssertion;
                  parameterBuilder.addClientAssertion(clientAssertion.assertion);
                  parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
                }
                if (!(request.authenticationScheme === exports2.AuthenticationScheme.POP))
                  return [3, 2];
                popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                return [4, popTokenGenerator.generateCnf(request)];
              case 1:
                reqCnfData = _b.sent();
                parameterBuilder.addPopToken(reqCnfData.reqCnfString);
                return [3, 3];
              case 2:
                if (request.authenticationScheme === exports2.AuthenticationScheme.SSH) {
                  if (request.sshJwk) {
                    parameterBuilder.addSshJwk(request.sshJwk);
                  } else {
                    acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                      success: false
                    });
                    throw ClientConfigurationError.createMissingSshJwkError();
                  }
                }
                _b.label = 3;
              case 3:
                if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                  parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
                }
                if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
                  switch (request.ccsCredential.type) {
                    case exports2.CcsCredentialType.HOME_ACCOUNT_ID:
                      try {
                        clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
                        parameterBuilder.addCcsOid(clientInfo);
                      } catch (e) {
                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
                      }
                      break;
                    case exports2.CcsCredentialType.UPN:
                      parameterBuilder.addCcsUpn(request.ccsCredential.credential);
                      break;
                  }
                }
                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
                  success: true
                });
                return [2, parameterBuilder.createQueryString()];
            }
          });
        });
      };
      return RefreshTokenClient2;
    }(BaseClient);
    var ClientCredentialClient = function(_super) {
      __extends(ClientCredentialClient2, _super);
      function ClientCredentialClient2(configuration, appTokenProvider) {
        var _this = _super.call(this, configuration) || this;
        _this.appTokenProvider = appTokenProvider;
        return _this;
      }
      ClientCredentialClient2.prototype.acquireToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var cachedAuthenticationResult;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.scopeSet = new ScopeSet(request.scopes || []);
                if (!request.skipCache)
                  return [3, 2];
                return [4, this.executeTokenRequest(request, this.authority)];
              case 1:
                return [2, _a.sent()];
              case 2:
                return [4, this.getCachedAuthenticationResult(request)];
              case 3:
                cachedAuthenticationResult = _a.sent();
                if (!cachedAuthenticationResult)
                  return [3, 4];
                return [2, cachedAuthenticationResult];
              case 4:
                return [4, this.executeTokenRequest(request, this.authority)];
              case 5:
                return [2, _a.sent()];
            }
          });
        });
      };
      ClientCredentialClient2.prototype.getCachedAuthenticationResult = function(request) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function() {
          var cachedAccessToken;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                cachedAccessToken = this.readAccessTokenFromCache();
                if (!cachedAccessToken) {
                  (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                  return [2, null];
                }
                if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                  (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                  return [2, null];
                }
                return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
                  account: null,
                  idToken: null,
                  accessToken: cachedAccessToken,
                  refreshToken: null,
                  appMetadata: null
                }, true, request)];
              case 1:
                return [2, _c.sent()];
            }
          });
        });
      };
      ClientCredentialClient2.prototype.readAccessTokenFromCache = function() {
        var accessTokenFilter = {
          homeAccountId: Constants.EMPTY_STRING,
          environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
          credentialType: exports2.CredentialType.ACCESS_TOKEN,
          clientId: this.config.authOptions.clientId,
          realm: this.authority.tenant,
          target: this.scopeSet.printScopesLowerCase()
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function(key) {
          return credentialCache.accessTokens[key];
        });
        if (accessTokens.length < 1) {
          return null;
        } else if (accessTokens.length > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
      };
      ClientCredentialClient2.prototype.executeTokenRequest = function(request, authority) {
        return __awaiter(this, void 0, void 0, function() {
          var serverTokenResponse, reqTimestamp, appTokenPropviderParameters, appTokenProviderResult, requestBody, headers, thumbprint, response, responseHandler, tokenResponse;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.appTokenProvider)
                  return [3, 2];
                this.logger.info("Using appTokenProvider extensibility.");
                appTokenPropviderParameters = {
                  correlationId: request.correlationId,
                  tenantId: this.config.authOptions.authority.tenant,
                  scopes: request.scopes,
                  claims: request.claims
                };
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.appTokenProvider(appTokenPropviderParameters)];
              case 1:
                appTokenProviderResult = _a.sent();
                serverTokenResponse = {
                  access_token: appTokenProviderResult.accessToken,
                  expires_in: appTokenProviderResult.expiresInSeconds,
                  refresh_in: appTokenProviderResult.refreshInSeconds,
                  token_type: exports2.AuthenticationScheme.BEARER
                };
                return [3, 4];
              case 2:
                requestBody = this.createTokenRequestBody(request);
                headers = this.createTokenRequestHeaders();
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: request.authority,
                  scopes: request.scopes,
                  claims: request.claims,
                  authenticationScheme: request.authenticationScheme,
                  resourceRequestMethod: request.resourceRequestMethod,
                  resourceRequestUri: request.resourceRequestUri,
                  shrClaims: request.shrClaims,
                  sshKid: request.sshKid
                };
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
              case 3:
                response = _a.sent();
                serverTokenResponse = response.body;
                _a.label = 4;
              case 4:
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(serverTokenResponse);
                return [4, responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request)];
              case 5:
                tokenResponse = _a.sent();
                return [2, tokenResponse];
            }
          });
        });
      };
      ClientCredentialClient2.prototype.createTokenRequestBody = function(request) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addScopes(request.scopes, false);
        parameterBuilder.addGrantType(GrantType.CLIENT_CREDENTIALS_GRANT);
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        var clientAssertion = request.clientAssertion || this.config.clientCredentials.clientAssertion;
        if (clientAssertion) {
          parameterBuilder.addClientAssertion(clientAssertion.assertion);
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
        }
        return parameterBuilder.createQueryString();
      };
      return ClientCredentialClient2;
    }(BaseClient);
    var OnBehalfOfClient = function(_super) {
      __extends(OnBehalfOfClient2, _super);
      function OnBehalfOfClient2(configuration) {
        return _super.call(this, configuration) || this;
      }
      OnBehalfOfClient2.prototype.acquireToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                this.scopeSet = new ScopeSet(request.scopes || []);
                _a = this;
                return [4, this.cryptoUtils.hashString(request.oboAssertion)];
              case 1:
                _a.userAssertionHash = _b.sent();
                if (!request.skipCache)
                  return [3, 3];
                return [4, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];
              case 2:
                return [2, _b.sent()];
              case 3:
                _b.trys.push([3, 5, , 7]);
                return [4, this.getCachedAuthenticationResult(request)];
              case 4:
                return [2, _b.sent()];
              case 5:
                _b.sent();
                return [4, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];
              case 6:
                return [2, _b.sent()];
              case 7:
                return [2];
            }
          });
        });
      };
      OnBehalfOfClient2.prototype.getCachedAuthenticationResult = function(request) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function() {
          var cachedAccessToken, cachedIdToken, idTokenObject, cachedAccount, localAccountId, accountInfo;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);
                if (!cachedAccessToken) {
                  (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                  this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                  throw ClientAuthError.createRefreshRequiredError();
                } else if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                  (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                  this.logger.info("OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                  throw ClientAuthError.createRefreshRequiredError();
                }
                cachedIdToken = this.readIdTokenFromCacheForOBO(request, cachedAccessToken.homeAccountId);
                cachedAccount = null;
                if (cachedIdToken) {
                  idTokenObject = new AuthToken(cachedIdToken.secret, this.config.cryptoInterface);
                  localAccountId = idTokenObject.claims.oid ? idTokenObject.claims.oid : idTokenObject.claims.sub;
                  accountInfo = {
                    homeAccountId: cachedIdToken.homeAccountId,
                    environment: cachedIdToken.environment,
                    tenantId: cachedIdToken.realm,
                    username: Constants.EMPTY_STRING,
                    localAccountId: localAccountId || Constants.EMPTY_STRING
                  };
                  cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);
                }
                if (this.config.serverTelemetryManager) {
                  this.config.serverTelemetryManager.incrementCacheHits();
                }
                return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
                  account: cachedAccount,
                  accessToken: cachedAccessToken,
                  idToken: cachedIdToken,
                  refreshToken: null,
                  appMetadata: null
                }, true, request, idTokenObject)];
              case 1:
                return [2, _c.sent()];
            }
          });
        });
      };
      OnBehalfOfClient2.prototype.readIdTokenFromCacheForOBO = function(request, atHomeAccountId) {
        var idTokenFilter = {
          homeAccountId: atHomeAccountId,
          environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
          credentialType: exports2.CredentialType.ID_TOKEN,
          clientId: this.config.authOptions.clientId,
          realm: this.authority.tenant
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(idTokenFilter);
        var idTokens = Object.keys(credentialCache.idTokens).map(function(key) {
          return credentialCache.idTokens[key];
        });
        if (idTokens.length < 1) {
          return null;
        }
        return idTokens[0];
      };
      OnBehalfOfClient2.prototype.readAccessTokenFromCacheForOBO = function(clientId, request) {
        var authScheme = request.authenticationScheme || exports2.AuthenticationScheme.BEARER;
        var credentialType = authScheme && authScheme.toLowerCase() !== exports2.AuthenticationScheme.BEARER.toLowerCase() ? exports2.CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : exports2.CredentialType.ACCESS_TOKEN;
        var accessTokenFilter = {
          credentialType,
          clientId,
          target: this.scopeSet.printScopesLowerCase(),
          tokenType: authScheme,
          keyId: request.sshKid,
          requestedClaimsHash: request.requestedClaimsHash,
          userAssertionHash: this.userAssertionHash
        };
        var credentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function(key) {
          return credentialCache.accessTokens[key];
        });
        var numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          return null;
        } else if (numAccessTokens > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0];
      };
      OnBehalfOfClient2.prototype.executeTokenRequest = function(request, authority, userAssertionHash) {
        return __awaiter(this, void 0, void 0, function() {
          var requestBody, headers, thumbprint, reqTimestamp, response, responseHandler, tokenResponse;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                requestBody = this.createTokenRequestBody(request);
                headers = this.createTokenRequestHeaders();
                thumbprint = {
                  clientId: this.config.authOptions.clientId,
                  authority: request.authority,
                  scopes: request.scopes,
                  claims: request.claims,
                  authenticationScheme: request.authenticationScheme,
                  resourceRequestMethod: request.resourceRequestMethod,
                  resourceRequestUri: request.resourceRequestUri,
                  shrClaims: request.shrClaims,
                  sshKid: request.sshKid
                };
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
              case 1:
                response = _a.sent();
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response.body);
                return [4, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, void 0, userAssertionHash)];
              case 2:
                tokenResponse = _a.sent();
                return [2, tokenResponse];
            }
          });
        });
      };
      OnBehalfOfClient2.prototype.createTokenRequestBody = function(request) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addScopes(request.scopes);
        parameterBuilder.addGrantType(GrantType.JWT_BEARER);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        parameterBuilder.addRequestTokenUse(AADServerParamKeys.ON_BEHALF_OF);
        parameterBuilder.addOboAssertion(request.oboAssertion);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          var clientAssertion = this.config.clientCredentials.clientAssertion;
          parameterBuilder.addClientAssertion(clientAssertion.assertion);
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        return parameterBuilder.createQueryString();
      };
      return OnBehalfOfClient2;
    }(BaseClient);
    var SilentFlowClient = function(_super) {
      __extends(SilentFlowClient2, _super);
      function SilentFlowClient2(configuration, performanceClient) {
        return _super.call(this, configuration, performanceClient) || this;
      }
      SilentFlowClient2.prototype.acquireToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var e_1, refreshTokenClient;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, this.acquireCachedToken(request)];
              case 1:
                return [2, _a.sent()];
              case 2:
                e_1 = _a.sent();
                if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {
                  refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);
                  return [2, refreshTokenClient.acquireTokenByRefreshToken(request)];
                } else {
                  throw e_1;
                }
              case 3:
                return [2];
            }
          });
        });
      };
      SilentFlowClient2.prototype.acquireCachedToken = function(request) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function() {
          var environment, cacheRecord;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                if (!request) {
                  throw ClientConfigurationError.createEmptyTokenRequestError();
                }
                if (request.forceRefresh) {
                  (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);
                  this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.");
                  throw ClientAuthError.createRefreshRequiredError();
                }
                if (!request.account) {
                  throw ClientAuthError.createNoAccountInSilentRequestError();
                }
                environment = request.authority || this.authority.getPreferredCache();
                cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, request, environment);
                if (!cacheRecord.accessToken) {
                  (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                  this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                  throw ClientAuthError.createRefreshRequiredError();
                } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                  (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                  this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                  throw ClientAuthError.createRefreshRequiredError();
                } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {
                  (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);
                  this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.");
                  throw ClientAuthError.createRefreshRequiredError();
                }
                if (this.config.serverTelemetryManager) {
                  this.config.serverTelemetryManager.incrementCacheHits();
                }
                return [4, this.generateResultFromCacheRecord(cacheRecord, request)];
              case 1:
                return [2, _e.sent()];
            }
          });
        });
      };
      SilentFlowClient2.prototype.generateResultFromCacheRecord = function(cacheRecord, request) {
        return __awaiter(this, void 0, void 0, function() {
          var idTokenObj;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (cacheRecord.idToken) {
                  idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);
                }
                return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      return SilentFlowClient2;
    }(BaseClient);
    var UsernamePasswordClient = function(_super) {
      __extends(UsernamePasswordClient2, _super);
      function UsernamePasswordClient2(configuration) {
        return _super.call(this, configuration) || this;
      }
      UsernamePasswordClient2.prototype.acquireToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
          var reqTimestamp, response, responseHandler, tokenResponse;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.logger.info("in acquireToken call");
                reqTimestamp = TimeUtils.nowSeconds();
                return [4, this.executeTokenRequest(this.authority, request)];
              case 1:
                response = _a.sent();
                responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                responseHandler.validateTokenResponse(response.body);
                tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request);
                return [2, tokenResponse];
            }
          });
        });
      };
      UsernamePasswordClient2.prototype.executeTokenRequest = function(authority, request) {
        return __awaiter(this, void 0, void 0, function() {
          var thumbprint, requestBody, headers;
          return __generator(this, function(_a) {
            thumbprint = {
              clientId: this.config.authOptions.clientId,
              authority: authority.canonicalAuthority,
              scopes: request.scopes,
              claims: request.claims,
              authenticationScheme: request.authenticationScheme,
              resourceRequestMethod: request.resourceRequestMethod,
              resourceRequestUri: request.resourceRequestUri,
              shrClaims: request.shrClaims,
              sshKid: request.sshKid
            };
            requestBody = this.createTokenRequestBody(request);
            headers = this.createTokenRequestHeaders({
              credential: request.username,
              type: exports2.CcsCredentialType.UPN
            });
            return [2, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];
          });
        });
      };
      UsernamePasswordClient2.prototype.createTokenRequestBody = function(request) {
        var parameterBuilder = new RequestParameterBuilder();
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        parameterBuilder.addUsername(request.username);
        parameterBuilder.addPassword(request.password);
        parameterBuilder.addScopes(request.scopes);
        parameterBuilder.addResponseTypeForTokenAndIdToken();
        parameterBuilder.addGrantType(GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
        parameterBuilder.addClientInfo();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
        parameterBuilder.addThrottling();
        if (this.serverTelemetryManager) {
          parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
        }
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        if (this.config.clientCredentials.clientSecret) {
          parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
        }
        if (this.config.clientCredentials.clientAssertion) {
          var clientAssertion = this.config.clientCredentials.clientAssertion;
          parameterBuilder.addClientAssertion(clientAssertion.assertion);
          parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
        }
        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
        }
        if (this.config.systemOptions.preventCorsPreflight && request.username) {
          parameterBuilder.addCcsUpn(request.username);
        }
        return parameterBuilder.createQueryString();
      };
      return UsernamePasswordClient2;
    }(BaseClient);
    function isOpenIdConfigResponse(response) {
      return response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer") && response.hasOwnProperty("jwks_uri");
    }
    var rawMetdataJSON = { "endpointMetadata": { "https://login.microsoftonline.com/common/": { "token_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/common/": { "token_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/common/": { "token_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/consumers/": { "token_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/consumers/": { "token_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/consumers/": { "token_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/organizations/": { "token_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/organizations/": { "token_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/organizations/": { "token_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" } }, "instanceDiscoveryMetadata": { "https://login.microsoftonline.com/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/common/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/consumers/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/organizations/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] } } };
    var EndpointMetadata = rawMetdataJSON.endpointMetadata;
    var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
    exports2.ProtocolMode = void 0;
    (function(ProtocolMode) {
      ProtocolMode["AAD"] = "AAD";
      ProtocolMode["OIDC"] = "OIDC";
    })(exports2.ProtocolMode || (exports2.ProtocolMode = {}));
    var AuthorityMetadataEntity = function() {
      function AuthorityMetadataEntity2() {
        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
      }
      AuthorityMetadataEntity2.prototype.updateCloudDiscoveryMetadata = function(metadata, fromNetwork) {
        this.aliases = metadata.aliases;
        this.preferred_cache = metadata.preferred_cache;
        this.preferred_network = metadata.preferred_network;
        this.aliasesFromNetwork = fromNetwork;
      };
      AuthorityMetadataEntity2.prototype.updateEndpointMetadata = function(metadata, fromNetwork) {
        this.authorization_endpoint = metadata.authorization_endpoint;
        this.token_endpoint = metadata.token_endpoint;
        this.end_session_endpoint = metadata.end_session_endpoint;
        this.issuer = metadata.issuer;
        this.endpointsFromNetwork = fromNetwork;
        this.jwks_uri = metadata.jwks_uri;
      };
      AuthorityMetadataEntity2.prototype.updateCanonicalAuthority = function(authority) {
        this.canonical_authority = authority;
      };
      AuthorityMetadataEntity2.prototype.resetExpiresAt = function() {
        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
      };
      AuthorityMetadataEntity2.prototype.isExpired = function() {
        return this.expiresAt <= TimeUtils.nowSeconds();
      };
      AuthorityMetadataEntity2.isAuthorityMetadataEntity = function(key, entity) {
        if (!entity) {
          return false;
        }
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt") && entity.hasOwnProperty("jwks_uri");
      };
      return AuthorityMetadataEntity2;
    }();
    function isCloudInstanceDiscoveryResponse(response) {
      return response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata");
    }
    var RegionDiscovery = function() {
      function RegionDiscovery2(networkInterface) {
        this.networkInterface = networkInterface;
      }
      RegionDiscovery2.prototype.detectRegion = function(environmentRegion, regionDiscoveryMetadata, proxyUrl) {
        return __awaiter(this, void 0, void 0, function() {
          var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                autodetectedRegionName = environmentRegion;
                if (!!autodetectedRegionName)
                  return [3, 8];
                options = RegionDiscovery2.IMDS_OPTIONS;
                if (proxyUrl) {
                  options.proxyUrl = proxyUrl;
                }
                _a.label = 1;
              case 1:
                _a.trys.push([1, 6, , 7]);
                return [4, this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];
              case 2:
                localIMDSVersionResponse = _a.sent();
                if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                  autodetectedRegionName = localIMDSVersionResponse.body;
                  regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
                }
                if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest))
                  return [3, 5];
                return [4, this.getCurrentVersion(options)];
              case 3:
                currentIMDSVersion = _a.sent();
                if (!currentIMDSVersion) {
                  regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                  return [2, null];
                }
                return [4, this.getRegionFromIMDS(currentIMDSVersion, options)];
              case 4:
                currentIMDSVersionResponse = _a.sent();
                if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                  autodetectedRegionName = currentIMDSVersionResponse.body;
                  regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
                }
                _a.label = 5;
              case 5:
                return [3, 7];
              case 6:
                _a.sent();
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                return [2, null];
              case 7:
                return [3, 9];
              case 8:
                regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
                _a.label = 9;
              case 9:
                if (!autodetectedRegionName) {
                  regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                }
                return [2, autodetectedRegionName || null];
            }
          });
        });
      };
      RegionDiscovery2.prototype.getRegionFromIMDS = function(version2, options) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?api-version=" + version2 + "&format=text", options, Constants.IMDS_TIMEOUT)];
          });
        });
      };
      RegionDiscovery2.prototype.getCurrentVersion = function(options) {
        return __awaiter(this, void 0, void 0, function() {
          var response;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?format=json", options)];
              case 1:
                response = _a.sent();
                if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
                  return [2, response.body["newest-versions"][0]];
                }
                return [2, null];
              case 2:
                _a.sent();
                return [2, null];
              case 3:
                return [2];
            }
          });
        });
      };
      RegionDiscovery2.IMDS_OPTIONS = {
        headers: {
          Metadata: "true"
        }
      };
      return RegionDiscovery2;
    }();
    var Authority = function() {
      function Authority2(authority, networkInterface, cacheManager, authorityOptions, proxyUrl) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscovery = new RegionDiscovery(networkInterface);
        this.regionDiscoveryMetadata = { region_used: void 0, region_source: void 0, region_outcome: void 0 };
        this.proxyUrl = proxyUrl || Constants.EMPTY_STRING;
      }
      Object.defineProperty(Authority2.prototype, "authorityType", {
        get: function() {
          var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;
          if (pathSegments.length && pathSegments[0].toLowerCase() === Constants.ADFS) {
            return exports2.AuthorityType.Adfs;
          }
          return exports2.AuthorityType.Default;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "protocolMode", {
        get: function() {
          return this.authorityOptions.protocolMode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "options", {
        get: function() {
          return this.authorityOptions;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "canonicalAuthority", {
        get: function() {
          return this._canonicalAuthority.urlString;
        },
        set: function(url) {
          this._canonicalAuthority = new UrlString(url);
          this._canonicalAuthority.validateAsUri();
          this._canonicalAuthorityUrlComponents = null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "canonicalAuthorityUrlComponents", {
        get: function() {
          if (!this._canonicalAuthorityUrlComponents) {
            this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
          }
          return this._canonicalAuthorityUrlComponents;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "hostnameAndPort", {
        get: function() {
          return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "tenant", {
        get: function() {
          return this.canonicalAuthorityUrlComponents.PathSegments[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "authorizationEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.authorization_endpoint);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "tokenEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.token_endpoint);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "deviceCodeEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "endSessionEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            if (!this.metadata.end_session_endpoint) {
              throw ClientAuthError.createLogoutNotSupportedError();
            }
            var endpoint = this.replacePath(this.metadata.end_session_endpoint);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "selfSignedJwtAudience", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.issuer);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Authority2.prototype, "jwksUri", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.jwks_uri);
            return this.replaceTenant(endpoint);
          } else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        },
        enumerable: false,
        configurable: true
      });
      Authority2.prototype.replaceTenant = function(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
      };
      Authority2.prototype.replacePath = function(urlString) {
        var endpoint = urlString;
        var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach(function(currentPart, index) {
          var cachedPart = cachedAuthorityParts[index];
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace("/" + cachedPart + "/", "/" + currentPart + "/");
          }
        });
        return endpoint;
      };
      Object.defineProperty(Authority2.prototype, "defaultOpenIdConfigurationEndpoint", {
        get: function() {
          if (this.authorityType === exports2.AuthorityType.Adfs || this.protocolMode === exports2.ProtocolMode.OIDC) {
            return this.canonicalAuthority + ".well-known/openid-configuration";
          }
          return this.canonicalAuthority + "v2.0/.well-known/openid-configuration";
        },
        enumerable: false,
        configurable: true
      });
      Authority2.prototype.discoveryComplete = function() {
        return !!this.metadata;
      };
      Authority2.prototype.resolveEndpointsAsync = function() {
        return __awaiter(this, void 0, void 0, function() {
          var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
                if (!metadataEntity) {
                  metadataEntity = new AuthorityMetadataEntity();
                  metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
                }
                return [4, this.updateCloudDiscoveryMetadata(metadataEntity)];
              case 1:
                cloudDiscoverySource = _a.sent();
                this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
                return [4, this.updateEndpointMetadata(metadataEntity)];
              case 2:
                endpointSource = _a.sent();
                if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {
                  metadataEntity.resetExpiresAt();
                  metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
                }
                cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
                this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
                this.metadata = metadataEntity;
                return [2];
            }
          });
        });
      };
      Authority2.prototype.updateEndpointMetadata = function(metadataEntity) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function() {
          var metadata, harcodedMetadata;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                metadata = this.getEndpointMetadataFromConfig();
                if (metadata) {
                  metadataEntity.updateEndpointMetadata(metadata, false);
                  return [2, AuthorityMetadataSource.CONFIG];
                }
                if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {
                  return [2, AuthorityMetadataSource.CACHE];
                }
                harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
                return [4, this.getEndpointMetadataFromNetwork()];
              case 1:
                metadata = _c.sent();
                if (!metadata)
                  return [3, 4];
                if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion))
                  return [3, 3];
                return [4, this.updateMetadataWithRegionalInformation(metadata)];
              case 2:
                metadata = _c.sent();
                _c.label = 3;
              case 3:
                metadataEntity.updateEndpointMetadata(metadata, true);
                return [2, AuthorityMetadataSource.NETWORK];
              case 4:
                if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache))
                  return [3, 7];
                if (!((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion))
                  return [3, 6];
                return [4, this.updateMetadataWithRegionalInformation(harcodedMetadata)];
              case 5:
                harcodedMetadata = _c.sent();
                _c.label = 6;
              case 6:
                metadataEntity.updateEndpointMetadata(harcodedMetadata, false);
                return [2, AuthorityMetadataSource.HARDCODED_VALUES];
              case 7:
                throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);
            }
          });
        });
      };
      Authority2.prototype.isAuthoritySameType = function(metadataEntity) {
        var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
      };
      Authority2.prototype.getEndpointMetadataFromConfig = function() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata);
          } catch (e) {
            throw ClientConfigurationError.createInvalidAuthorityMetadataError();
          }
        }
        return null;
      };
      Authority2.prototype.getEndpointMetadataFromNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          var options, response;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                options = {};
                if (this.proxyUrl) {
                  options.proxyUrl = this.proxyUrl;
                }
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];
              case 2:
                response = _a.sent();
                return [2, isOpenIdConfigResponse(response.body) ? response.body : null];
              case 3:
                _a.sent();
                return [2, null];
              case 4:
                return [2];
            }
          });
        });
      };
      Authority2.prototype.getEndpointMetadataFromHardcodedValues = function() {
        if (this.canonicalAuthority in EndpointMetadata) {
          return EndpointMetadata[this.canonicalAuthority];
        }
        return null;
      };
      Authority2.prototype.updateMetadataWithRegionalInformation = function(metadata) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function() {
          var autodetectedRegionName, azureRegion;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                return [4, this.regionDiscovery.detectRegion((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.environmentRegion, this.regionDiscoveryMetadata, this.proxyUrl)];
              case 1:
                autodetectedRegionName = _f.sent();
                azureRegion = ((_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : (_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion;
                if (((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.azureRegion) === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
                  this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ? RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL : RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
                } else {
                  if (autodetectedRegionName) {
                    this.regionDiscoveryMetadata.region_outcome = ((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion) === autodetectedRegionName ? RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED : RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED;
                  } else {
                    this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
                  }
                }
                if (azureRegion) {
                  this.regionDiscoveryMetadata.region_used = azureRegion;
                  return [2, Authority2.replaceWithRegionalInformation(metadata, azureRegion)];
                }
                return [2, metadata];
            }
          });
        });
      };
      Authority2.prototype.updateCloudDiscoveryMetadata = function(metadataEntity) {
        return __awaiter(this, void 0, void 0, function() {
          var metadata, harcodedMetadata;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                metadata = this.getCloudDiscoveryMetadataFromConfig();
                if (metadata) {
                  metadataEntity.updateCloudDiscoveryMetadata(metadata, false);
                  return [2, AuthorityMetadataSource.CONFIG];
                }
                if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {
                  return [2, AuthorityMetadataSource.CACHE];
                }
                harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();
                return [4, this.getCloudDiscoveryMetadataFromNetwork()];
              case 1:
                metadata = _a.sent();
                if (metadata) {
                  metadataEntity.updateCloudDiscoveryMetadata(metadata, true);
                  return [2, AuthorityMetadataSource.NETWORK];
                }
                if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {
                  metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);
                  return [2, AuthorityMetadataSource.HARDCODED_VALUES];
                } else {
                  throw ClientConfigurationError.createUntrustedAuthorityError();
                }
            }
          });
        });
      };
      Authority2.prototype.getCloudDiscoveryMetadataFromConfig = function() {
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          try {
            var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            var metadata = Authority2.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
            if (metadata) {
              return metadata;
            }
          } catch (e) {
            throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();
          }
        }
        if (this.isInKnownAuthorities()) {
          return Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
        }
        return null;
      };
      Authority2.prototype.getCloudDiscoveryMetadataFromNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
          var instanceDiscoveryEndpoint, options, match, response, metadata;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                instanceDiscoveryEndpoint = "" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize";
                options = {};
                if (this.proxyUrl) {
                  options.proxyUrl = this.proxyUrl;
                }
                match = null;
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];
              case 2:
                response = _a.sent();
                metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];
                if (metadata.length === 0) {
                  return [2, null];
                }
                match = Authority2.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
                return [3, 4];
              case 3:
                _a.sent();
                return [2, null];
              case 4:
                if (!match) {
                  match = Authority2.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
                }
                return [2, match];
            }
          });
        });
      };
      Authority2.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function() {
        if (this.canonicalAuthority in InstanceDiscoveryMetadata) {
          return InstanceDiscoveryMetadata[this.canonicalAuthority];
        }
        return null;
      };
      Authority2.prototype.isInKnownAuthorities = function() {
        var _this = this;
        var matches = this.authorityOptions.knownAuthorities.filter(function(authority) {
          return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;
        });
        return matches.length > 0;
      };
      Authority2.generateAuthority = function(authorityString, azureCloudOptions) {
        var authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== exports2.AzureCloudInstance.None) {
          var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + "/" + tenant + "/";
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
      };
      Authority2.createCloudDiscoveryMetadataFromHost = function(host) {
        return {
          preferred_network: host,
          preferred_cache: host,
          aliases: [host]
        };
      };
      Authority2.getCloudDiscoveryMetadataFromNetworkResponse = function(response, authority) {
        for (var i = 0; i < response.length; i++) {
          var metadata = response[i];
          if (metadata.aliases.indexOf(authority) > -1) {
            return metadata;
          }
        }
        return null;
      };
      Authority2.prototype.getPreferredCache = function() {
        if (this.discoveryComplete()) {
          return this.metadata.preferred_cache;
        } else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      };
      Authority2.prototype.isAlias = function(host) {
        return this.metadata.aliases.indexOf(host) > -1;
      };
      Authority2.isPublicCloudAuthority = function(host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
      };
      Authority2.buildRegionalAuthorityString = function(host, region, queryString) {
        var authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        var authorityUrlParts = authorityUrlInstance.getUrlComponents();
        var hostNameAndPort = region + "." + authorityUrlParts.HostNameAndPort;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = region + "." + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;
        }
        var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), { HostNameAndPort: hostNameAndPort })).urlString;
        if (queryString)
          return url + "?" + queryString;
        return url;
      };
      Authority2.replaceWithRegionalInformation = function(metadata, azureRegion) {
        metadata.authorization_endpoint = Authority2.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);
        metadata.token_endpoint = Authority2.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, "allowestsrnonmsi=true");
        if (metadata.end_session_endpoint) {
          metadata.end_session_endpoint = Authority2.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);
        }
        return metadata;
      };
      return Authority2;
    }();
    var AuthorityFactory = function() {
      function AuthorityFactory2() {
      }
      AuthorityFactory2.createDiscoveredInstance = function(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl) {
        return __awaiter(this, void 0, void 0, function() {
          var acquireTokenAuthority, e_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                acquireTokenAuthority = AuthorityFactory2.createInstance(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl);
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, acquireTokenAuthority.resolveEndpointsAsync()];
              case 2:
                _a.sent();
                return [2, acquireTokenAuthority];
              case 3:
                e_1 = _a.sent();
                throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_1);
              case 4:
                return [2];
            }
          });
        });
      };
      AuthorityFactory2.createInstance = function(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl) {
        if (StringUtils.isEmpty(authorityUrl)) {
          throw ClientConfigurationError.createUrlEmptyError();
        }
        return new Authority(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl);
      };
      return AuthorityFactory2;
    }();
    var ServerTelemetryEntity = function() {
      function ServerTelemetryEntity2() {
        this.failedRequests = [];
        this.errors = [];
        this.cacheHits = 0;
      }
      ServerTelemetryEntity2.isServerTelemetryEntity = function(key, entity) {
        var validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
        var validateEntity = true;
        if (entity) {
          validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits");
        }
        return validateKey && validateEntity;
      };
      return ServerTelemetryEntity2;
    }();
    var ThrottlingEntity = function() {
      function ThrottlingEntity2() {
      }
      ThrottlingEntity2.isThrottlingEntity = function(key, entity) {
        var validateKey = false;
        if (key) {
          validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
        }
        var validateEntity = true;
        if (entity) {
          validateEntity = entity.hasOwnProperty("throttleTime");
        }
        return validateKey && validateEntity;
      };
      return ThrottlingEntity2;
    }();
    var StubbedNetworkModule = {
      sendGetRequestAsync: function() {
        var notImplErr = "Network interface - sendGetRequestAsync() has not been implemented for the Network interface.";
        return Promise.reject(AuthError.createUnexpectedError(notImplErr));
      },
      sendPostRequestAsync: function() {
        var notImplErr = "Network interface - sendPostRequestAsync() has not been implemented for the Network interface.";
        return Promise.reject(AuthError.createUnexpectedError(notImplErr));
      }
    };
    var JoseHeaderErrorMessage = {
      missingKidError: {
        code: "missing_kid_error",
        desc: "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided."
      },
      missingAlgError: {
        code: "missing_alg_error",
        desc: "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided."
      }
    };
    var JoseHeaderError = function(_super) {
      __extends(JoseHeaderError2, _super);
      function JoseHeaderError2(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "JoseHeaderError";
        Object.setPrototypeOf(_this, JoseHeaderError2.prototype);
        return _this;
      }
      JoseHeaderError2.createMissingKidError = function() {
        return new JoseHeaderError2(JoseHeaderErrorMessage.missingKidError.code, JoseHeaderErrorMessage.missingKidError.desc);
      };
      JoseHeaderError2.createMissingAlgError = function() {
        return new JoseHeaderError2(JoseHeaderErrorMessage.missingAlgError.code, JoseHeaderErrorMessage.missingAlgError.desc);
      };
      return JoseHeaderError2;
    }(AuthError);
    var JoseHeader = function() {
      function JoseHeader2(options) {
        this.typ = options.typ;
        this.alg = options.alg;
        this.kid = options.kid;
      }
      JoseHeader2.getShrHeaderString = function(shrHeaderOptions) {
        if (!shrHeaderOptions.kid) {
          throw JoseHeaderError.createMissingKidError();
        }
        if (!shrHeaderOptions.alg) {
          throw JoseHeaderError.createMissingAlgError();
        }
        var shrHeader = new JoseHeader2({
          typ: shrHeaderOptions.typ || JsonTypes.Jwt,
          kid: shrHeaderOptions.kid,
          alg: shrHeaderOptions.alg
        });
        return JSON.stringify(shrHeader);
      };
      return JoseHeader2;
    }();
    var AuthenticationHeaderParser = function() {
      function AuthenticationHeaderParser2(headers) {
        this.headers = headers;
      }
      AuthenticationHeaderParser2.prototype.getShrNonce = function() {
        var authenticationInfo = this.headers[HeaderNames.AuthenticationInfo];
        if (authenticationInfo) {
          var authenticationInfoChallenges = this.parseChallenges(authenticationInfo);
          if (authenticationInfoChallenges.nextnonce) {
            return authenticationInfoChallenges.nextnonce;
          }
          throw ClientConfigurationError.createInvalidAuthenticationHeaderError(HeaderNames.AuthenticationInfo, "nextnonce challenge is missing.");
        }
        var wwwAuthenticate = this.headers[HeaderNames.WWWAuthenticate];
        if (wwwAuthenticate) {
          var wwwAuthenticateChallenges = this.parseChallenges(wwwAuthenticate);
          if (wwwAuthenticateChallenges.nonce) {
            return wwwAuthenticateChallenges.nonce;
          }
          throw ClientConfigurationError.createInvalidAuthenticationHeaderError(HeaderNames.WWWAuthenticate, "nonce challenge is missing.");
        }
        throw ClientConfigurationError.createMissingNonceAuthenticationHeadersError();
      };
      AuthenticationHeaderParser2.prototype.parseChallenges = function(header) {
        var schemeSeparator = header.indexOf(" ");
        var challenges = header.substr(schemeSeparator + 1).split(",");
        var challengeMap = {};
        challenges.forEach(function(challenge) {
          var _a = challenge.split("="), key = _a[0], value = _a[1];
          challengeMap[key] = unescape(value.replace(/['"]+/g, Constants.EMPTY_STRING));
        });
        return challengeMap;
      };
      return AuthenticationHeaderParser2;
    }();
    var ServerTelemetryManager = function() {
      function ServerTelemetryManager2(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NO_CACHE_HIT;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
      }
      ServerTelemetryManager2.prototype.generateCurrentRequestHeaderValue = function() {
        var request = "" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + this.cacheOutcome;
        var platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var regionDiscoveryFields = this.getRegionDiscoveryFields();
        var requestWithRegionDiscoveryFields = [request, regionDiscoveryFields].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, requestWithRegionDiscoveryFields, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      };
      ServerTelemetryManager2.prototype.generateLastRequestHeaderValue = function() {
        var lastRequests = this.getLastRequests();
        var maxErrors = ServerTelemetryManager2.maxErrorsToSend(lastRequests);
        var failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var errorCount = lastRequests.errors.length;
        var overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        var platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
      };
      ServerTelemetryManager2.prototype.cacheFailedRequest = function(error) {
        var lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift();
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (!StringUtils.isEmpty(error.subError)) {
          lastRequests.errors.push(error.subError);
        } else if (!StringUtils.isEmpty(error.errorCode)) {
          lastRequests.errors.push(error.errorCode);
        } else if (!!error && error.toString()) {
          lastRequests.errors.push(error.toString());
        } else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return;
      };
      ServerTelemetryManager2.prototype.incrementCacheHits = function() {
        var lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return lastRequests.cacheHits;
      };
      ServerTelemetryManager2.prototype.getLastRequests = function() {
        var initialValue = new ServerTelemetryEntity();
        var lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue;
      };
      ServerTelemetryManager2.prototype.clearTelemetryCache = function() {
        var lastRequests = this.getLastRequests();
        var numErrorsFlushed = ServerTelemetryManager2.maxErrorsToSend(lastRequests);
        var errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey);
        } else {
          var serverTelemEntity = new ServerTelemetryEntity();
          serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed * 2);
          serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);
          this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
        }
      };
      ServerTelemetryManager2.maxErrorsToSend = function(serverTelemetryEntity) {
        var i;
        var maxErrors = 0;
        var dataSize = 0;
        var errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          var apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
          var correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
          var errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
          dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1;
          } else {
            break;
          }
        }
        return maxErrors;
      };
      ServerTelemetryManager2.prototype.getRegionDiscoveryFields = function() {
        var regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
        return regionDiscoveryFields.join(",");
      };
      ServerTelemetryManager2.prototype.updateRegionDiscoveryMetadata = function(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
      };
      ServerTelemetryManager2.prototype.setCacheOutcome = function(cacheOutcome) {
        this.cacheOutcome = cacheOutcome;
      };
      return ServerTelemetryManager2;
    }();
    var PerformanceClient = function() {
      function PerformanceClient2(clientId, authority, logger2, libraryName, libraryVersion, applicationTelemetry) {
        this.authority = authority;
        this.libraryName = libraryName;
        this.libraryVersion = libraryVersion;
        this.applicationTelemetry = applicationTelemetry;
        this.clientId = clientId;
        this.logger = logger2;
        this.callbacks = /* @__PURE__ */ new Map();
        this.eventsByCorrelationId = /* @__PURE__ */ new Map();
        this.measurementsById = /* @__PURE__ */ new Map();
      }
      PerformanceClient2.prototype.startMeasurement = function(measureName, correlationId) {
        var _this = this;
        var _a, _b;
        var eventCorrelationId = correlationId || this.generateId();
        if (!correlationId) {
          this.logger.info("PerformanceClient: No correlation id provided for " + measureName + ", generating", eventCorrelationId);
        }
        this.logger.trace("PerformanceClient: Performance measurement started for " + measureName, eventCorrelationId);
        var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);
        performanceMeasurement.startMeasurement();
        var inProgressEvent = {
          eventId: this.generateId(),
          status: exports2.PerformanceEventStatus.InProgress,
          authority: this.authority,
          libraryName: this.libraryName,
          libraryVersion: this.libraryVersion,
          appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,
          appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion,
          clientId: this.clientId,
          name: measureName,
          startTimeMs: Date.now(),
          correlationId: eventCorrelationId
        };
        this.cacheEventByCorrelationId(inProgressEvent);
        this.cacheMeasurement(inProgressEvent, performanceMeasurement);
        return {
          endMeasurement: function(event) {
            var completedEvent = _this.endMeasurement(__assign(__assign({}, inProgressEvent), event));
            if (completedEvent) {
              _this.cacheEventByCorrelationId(completedEvent);
            }
            return completedEvent;
          },
          flushMeasurement: function() {
            return _this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);
          },
          discardMeasurement: function() {
            return _this.discardMeasurements(inProgressEvent.correlationId);
          },
          measurement: performanceMeasurement,
          event: inProgressEvent
        };
      };
      PerformanceClient2.prototype.endMeasurement = function(event) {
        var performanceMeasurement = this.measurementsById.get(event.eventId);
        if (performanceMeasurement) {
          this.measurementsById.delete(event.eventId);
          performanceMeasurement.endMeasurement();
          var durationMs = performanceMeasurement.flushMeasurement();
          if (durationMs !== null) {
            this.logger.trace("PerformanceClient: Performance measurement ended for " + event.name + ": " + durationMs + " ms", event.correlationId);
            var completedEvent = __assign(__assign({
              durationMs: Math.round(durationMs)
            }, event), { status: exports2.PerformanceEventStatus.Completed });
            return completedEvent;
          } else {
            this.logger.trace("PerformanceClient: Performance measurement not taken", event.correlationId);
          }
        } else {
          this.logger.trace("PerformanceClient: Measurement not found for " + event.eventId, event.correlationId);
        }
        return null;
      };
      PerformanceClient2.prototype.cacheEventByCorrelationId = function(event) {
        var existingEvents = this.eventsByCorrelationId.get(event.correlationId);
        if (existingEvents) {
          this.logger.trace("PerformanceClient: Performance measurement for " + event.name + " added/updated", event.correlationId);
          existingEvents.set(event.eventId, event);
        } else {
          this.logger.trace("PerformanceClient: Performance measurement for " + event.name + " started", event.correlationId);
          this.eventsByCorrelationId.set(event.correlationId, (/* @__PURE__ */ new Map()).set(event.eventId, event));
        }
      };
      PerformanceClient2.prototype.cacheMeasurement = function(event, measurement) {
        this.measurementsById.set(event.eventId, measurement);
      };
      PerformanceClient2.prototype.flushMeasurements = function(measureName, correlationId) {
        var _this = this;
        this.logger.trace("PerformanceClient: Performance measurements flushed for " + measureName, correlationId);
        var eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);
        if (eventsForCorrelationId) {
          this.discardMeasurements(correlationId);
          var completedEvents_1 = [];
          eventsForCorrelationId.forEach(function(event) {
            if (event.name !== measureName && event.status !== exports2.PerformanceEventStatus.Completed) {
              _this.logger.trace("PerformanceClient: Incomplete submeasurement " + event.name + " found for " + measureName, correlationId);
              var completedEvent = _this.endMeasurement(event);
              if (completedEvent) {
                completedEvents_1.push(completedEvent);
              }
            }
            completedEvents_1.push(event);
          });
          var sortedCompletedEvents = completedEvents_1.sort(function(eventA, eventB) {
            return eventA.startTimeMs - eventB.startTimeMs;
          });
          var topLevelEvents = sortedCompletedEvents.filter(function(event) {
            return event.name === measureName && event.status === exports2.PerformanceEventStatus.Completed;
          });
          if (topLevelEvents.length > 0) {
            if (topLevelEvents.length > 1) {
              this.logger.verbose("PerformanceClient: Multiple distinct top-level performance events found, using the first", correlationId);
            }
            var topLevelEvent = topLevelEvents[0];
            this.logger.verbose("PerformanceClient: Measurement found for " + measureName, correlationId);
            var eventToEmit = sortedCompletedEvents.reduce(function(previous, current) {
              if (current.name !== measureName) {
                _this.logger.trace("PerformanceClient: Complete submeasurement found for " + current.name, correlationId);
                var subMeasurementName = current.name + "DurationMs";
                if (!previous[subMeasurementName]) {
                  previous[subMeasurementName] = current.durationMs;
                } else {
                  _this.logger.verbose("PerformanceClient: Submeasurement for " + measureName + " already exists for " + current.name + ", ignoring", correlationId);
                }
                if (current.accessTokenSize) {
                  previous.accessTokenSize = current.accessTokenSize;
                }
                if (current.idTokenSize) {
                  previous.idTokenSize = current.idTokenSize;
                }
              }
              return previous;
            }, topLevelEvent);
            this.emitEvents([eventToEmit], eventToEmit.correlationId);
          } else {
            this.logger.verbose("PerformanceClient: No completed top-level measurements found for " + measureName, correlationId);
          }
        } else {
          this.logger.verbose("PerformanceClient: No measurements found", correlationId);
        }
      };
      PerformanceClient2.prototype.discardMeasurements = function(correlationId) {
        this.logger.trace("PerformanceClient: Performance measurements discarded", correlationId);
        this.eventsByCorrelationId.delete(correlationId);
      };
      PerformanceClient2.prototype.addPerformanceCallback = function(callback) {
        var callbackId = this.generateId();
        this.callbacks.set(callbackId, callback);
        this.logger.verbose("PerformanceClient: Performance callback registered with id: " + callbackId);
        return callbackId;
      };
      PerformanceClient2.prototype.removePerformanceCallback = function(callbackId) {
        var result = this.callbacks.delete(callbackId);
        if (result) {
          this.logger.verbose("PerformanceClient: Performance callback " + callbackId + " removed.");
        } else {
          this.logger.verbose("PerformanceClient: Performance callback " + callbackId + " not removed.");
        }
        return result;
      };
      PerformanceClient2.prototype.emitEvents = function(events, correlationId) {
        var _this = this;
        this.logger.verbose("PerformanceClient: Emitting performance events", correlationId);
        this.callbacks.forEach(function(callback, callbackId) {
          _this.logger.trace("PerformanceClient: Emitting event to callback " + callbackId, correlationId);
          callback.apply(null, [events]);
        });
      };
      return PerformanceClient2;
    }();
    var StubPerformanceMeasurement = function() {
      function StubPerformanceMeasurement2() {
      }
      StubPerformanceMeasurement2.prototype.startMeasurement = function() {
      };
      StubPerformanceMeasurement2.prototype.endMeasurement = function() {
      };
      StubPerformanceMeasurement2.prototype.flushMeasurement = function() {
        return null;
      };
      return StubPerformanceMeasurement2;
    }();
    var StubPerformanceClient = function(_super) {
      __extends(StubPerformanceClient2, _super);
      function StubPerformanceClient2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      StubPerformanceClient2.prototype.generateId = function() {
        return "callback-id";
      };
      StubPerformanceClient2.prototype.startPerformanceMeasuremeant = function() {
        return new StubPerformanceMeasurement();
      };
      return StubPerformanceClient2;
    }(PerformanceClient);
    exports2.AccessTokenEntity = AccessTokenEntity;
    exports2.AccountEntity = AccountEntity;
    exports2.AppMetadataEntity = AppMetadataEntity;
    exports2.AuthError = AuthError;
    exports2.AuthErrorMessage = AuthErrorMessage;
    exports2.AuthToken = AuthToken;
    exports2.AuthenticationHeaderParser = AuthenticationHeaderParser;
    exports2.Authority = Authority;
    exports2.AuthorityFactory = AuthorityFactory;
    exports2.AuthorityMetadataEntity = AuthorityMetadataEntity;
    exports2.AuthorizationCodeClient = AuthorizationCodeClient;
    exports2.CacheManager = CacheManager;
    exports2.ClientAuthError = ClientAuthError;
    exports2.ClientAuthErrorMessage = ClientAuthErrorMessage;
    exports2.ClientConfigurationError = ClientConfigurationError;
    exports2.ClientConfigurationErrorMessage = ClientConfigurationErrorMessage;
    exports2.ClientCredentialClient = ClientCredentialClient;
    exports2.CodeChallengeMethodValues = CodeChallengeMethodValues;
    exports2.Constants = Constants;
    exports2.CredentialEntity = CredentialEntity;
    exports2.DEFAULT_CRYPTO_IMPLEMENTATION = DEFAULT_CRYPTO_IMPLEMENTATION;
    exports2.DEFAULT_SYSTEM_OPTIONS = DEFAULT_SYSTEM_OPTIONS;
    exports2.DefaultStorageClass = DefaultStorageClass;
    exports2.DeviceCodeClient = DeviceCodeClient;
    exports2.IdToken = AuthToken;
    exports2.IdTokenEntity = IdTokenEntity;
    exports2.InteractionRequiredAuthError = InteractionRequiredAuthError;
    exports2.InteractionRequiredAuthErrorMessage = InteractionRequiredAuthErrorMessage;
    exports2.JoseHeader = JoseHeader;
    exports2.Logger = Logger;
    exports2.NetworkManager = NetworkManager;
    exports2.OIDC_DEFAULT_SCOPES = OIDC_DEFAULT_SCOPES;
    exports2.OnBehalfOfClient = OnBehalfOfClient;
    exports2.PerformanceClient = PerformanceClient;
    exports2.PopTokenGenerator = PopTokenGenerator;
    exports2.PromptValue = PromptValue;
    exports2.ProtocolUtils = ProtocolUtils;
    exports2.RefreshTokenClient = RefreshTokenClient;
    exports2.RefreshTokenEntity = RefreshTokenEntity;
    exports2.ScopeSet = ScopeSet;
    exports2.ServerError = ServerError;
    exports2.ServerTelemetryEntity = ServerTelemetryEntity;
    exports2.ServerTelemetryManager = ServerTelemetryManager;
    exports2.SilentFlowClient = SilentFlowClient;
    exports2.StringUtils = StringUtils;
    exports2.StubPerformanceClient = StubPerformanceClient;
    exports2.StubbedNetworkModule = StubbedNetworkModule;
    exports2.ThrottlingEntity = ThrottlingEntity;
    exports2.ThrottlingUtils = ThrottlingUtils;
    exports2.TimeUtils = TimeUtils;
    exports2.TokenCacheContext = TokenCacheContext;
    exports2.UrlString = UrlString;
    exports2.UsernamePasswordClient = UsernamePasswordClient;
    exports2.buildClientInfo = buildClientInfo;
    exports2.buildClientInfoFromHomeAccountId = buildClientInfoFromHomeAccountId;
    exports2.version = version;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/rng.js
var require_rng2 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/regex.js
var require_regex2 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/validate.js
var require_validate3 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/stringify.js
var require_stringify2 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    function stringify(arr, offset = 0) {
      const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/v1.js
var require_v12 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng2());
    var _stringify = _interopRequireDefault(require_stringify2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.default)(b);
    }
    var _default = v1;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/parse.js
var require_parse2 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/v35.js
var require_v352 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    exports2.URL = exports2.DNS = void 0;
    var _stringify = _interopRequireDefault(require_stringify2());
    var _parse = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL2;
    function _default(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (namespace.length !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.default)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/md5.js
var require_md52 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default = md5;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/v3.js
var require_v32 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v352());
    var _md = _interopRequireDefault(require_md52());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/v4.js
var require_v42 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng2());
    var _stringify = _interopRequireDefault(require_stringify2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.default)(rnds);
    }
    var _default = v4;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/sha1.js
var require_sha12 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default = sha1;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/v5.js
var require_v52 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v352());
    var _sha = _interopRequireDefault(require_sha12());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/nil.js
var require_nil2 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/version.js
var require_version2 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.substr(14, 1), 16);
    }
    var _default = version;
    exports2.default = _default;
  }
});

// ../node_modules/@azure/msal-node/node_modules/uuid/dist/index.js
var require_dist4 = __commonJS({
  "../node_modules/@azure/msal-node/node_modules/uuid/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    var _v = _interopRequireDefault(require_v12());
    var _v2 = _interopRequireDefault(require_v32());
    var _v3 = _interopRequireDefault(require_v42());
    var _v4 = _interopRequireDefault(require_v52());
    var _nil = _interopRequireDefault(require_nil2());
    var _version = _interopRequireDefault(require_version2());
    var _validate = _interopRequireDefault(require_validate3());
    var _stringify = _interopRequireDefault(require_stringify2());
    var _parse = _interopRequireDefault(require_parse2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// ../node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "../node_modules/jws/lib/data-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require("stream");
    var util = require("util");
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    };
    DataStream.prototype.end = function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    };
    module2.exports = DataStream;
  }
});

// ../node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "../node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require("buffer").Buffer;
    var SlowBuffer = require("buffer").SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
      };
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// ../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    module2.exports = getParamBytesForAlg;
  }
});

// ../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// ../node_modules/jwa/index.js
var require_jwa = __commonJS({
  "../node_modules/jwa/index.js"(exports2, module2) {
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto = require("crypto");
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require("util");
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    function createHmacSigner(bits) {
      return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      };
    }
    function createHmacVerifier(bits) {
      return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      };
    }
    function createKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      };
    }
    function createKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      };
    }
    function createPSSKeySigner(bits) {
      return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      };
    }
    function createPSSKeyVerifier(bits) {
      return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      };
    }
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      };
    }
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      };
    }
    function createNoneSigner() {
      return function sign() {
        return "";
      };
    }
    function createNoneVerifier() {
      return function verify(thing, signature) {
        return signature === "";
      };
    }
    module2.exports = function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    };
  }
});

// ../node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "../node_modules/jws/lib/tostring.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    };
  }
});

// ../node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "../node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = function sign() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// ../node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "../node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require("stream");
    var toString = require_tostring();
    var util = require("util");
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    function safeJsonParse(thing) {
      if (isObject(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = function verify() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    };
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// ../node_modules/jws/index.js
var require_jws = __commonJS({
  "../node_modules/jws/index.js"(exports2) {
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = function createSign(opts) {
      return new SignStream(opts);
    };
    exports2.createVerify = function createVerify(opts) {
      return new VerifyStream(opts);
    };
  }
});

// ../node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "../node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    var jws = require_jws();
    module2.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// ../node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "../node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    var JsonWebTokenError = function(message, error) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error)
        this.inner = error;
    };
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// ../node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "../node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    };
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// ../node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "../node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    };
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// ../node_modules/ms/index.js
var require_ms2 = __commonJS({
  "../node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "../node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    var ms = require_ms2();
    module2.exports = function(time, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time === "number") {
        return timestamp + time;
      } else {
        return;
      }
    };
  }
});

// ../node_modules/semver/semver.js
var require_semver = __commonJS({
  "../node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric2 = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric2.test(a);
      var bnum = numeric2.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// ../node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "../node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    var semver = require_semver();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// ../node_modules/jsonwebtoken/verify.js
var require_verify6 = __commonJS({
  "../node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      var done;
      if (callback) {
        done = callback;
      } else {
        done = function(err, data) {
          if (err)
            throw err;
          return data;
        };
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      var parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      var decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      var header = decodedToken.header;
      var getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        };
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        var hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          options.algorithms = ["none"];
        }
        if (!options.algorithms) {
          options.algorithms = ~secretOrPublicKey2.toString().indexOf("BEGIN CERTIFICATE") || ~secretOrPublicKey2.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~secretOrPublicKey2.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS;
        }
        if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        var valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        var payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          var audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          var match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          var invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          var signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// ../node_modules/lodash.includes/index.js
var require_lodash4 = __commonJS({
  "../node_modules/lodash.includes/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    module2.exports = includes;
  }
});

// ../node_modules/lodash.isboolean/index.js
var require_lodash5 = __commonJS({
  "../node_modules/lodash.isboolean/index.js"(exports2, module2) {
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = isBoolean;
  }
});

// ../node_modules/lodash.isinteger/index.js
var require_lodash6 = __commonJS({
  "../node_modules/lodash.isinteger/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = isInteger;
  }
});

// ../node_modules/lodash.isnumber/index.js
var require_lodash7 = __commonJS({
  "../node_modules/lodash.isnumber/index.js"(exports2, module2) {
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    module2.exports = isNumber;
  }
});

// ../node_modules/lodash.isplainobject/index.js
var require_lodash8 = __commonJS({
  "../node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// ../node_modules/lodash.isstring/index.js
var require_lodash9 = __commonJS({
  "../node_modules/lodash.isstring/index.js"(exports2, module2) {
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// ../node_modules/lodash.once/index.js
var require_lodash10 = __commonJS({
  "../node_modules/lodash.once/index.js"(exports2, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function once(func) {
      return before(2, func);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = once;
  }
});

// ../node_modules/jsonwebtoken/sign.js
var require_sign6 = __commonJS({
  "../node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var includes = require_lodash4();
    var isBoolean = require_lodash5();
    var isInteger = require_lodash6();
    var isNumber = require_lodash7();
    var isPlainObject = require_lodash8();
    var isString = require_lodash9();
    var once = require_lodash10();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: function(value) {
        return isInteger(value) || isString(value) && value;
      }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: function(value) {
        return isString(value) || Array.isArray(value);
      }, message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString, message: '"encoding" must be a string' },
      issuer: { isValid: isString, message: '"issuer" must be a string' },
      subject: { isValid: isString, message: '"subject" must be a string' },
      jwtid: { isValid: isString, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        var validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    function validateOptions(options) {
      return validate(sign_options_schema, false, options, "options");
    }
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      var isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      var header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error) {
          return failure(error);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        var invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error) {
        return failure(error);
      }
      var timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        var claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      var encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          callback(null, signature);
        });
      } else {
        return jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      }
    };
  }
});

// ../node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "../node_modules/jsonwebtoken/index.js"(exports2, module2) {
    module2.exports = {
      decode: require_decode(),
      verify: require_verify6(),
      sign: require_sign6(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// ../node_modules/@azure/msal-node/dist/msal-node.cjs.production.min.js
var require_msal_node_cjs_production_min = __commonJS({
  "../node_modules/@azure/msal-node/dist/msal-node.cjs.production.min.js"(exports2) {
    "use strict";
    function e(e2) {
      return e2 && "object" == typeof e2 && "default" in e2 ? e2.default : e2;
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    var t;
    var r;
    var n = require_index_cjs();
    var i = require("http");
    var o = e(i);
    var s = e(require("https"));
    var a = require_dist4();
    var c = e(require("crypto"));
    var l = require_jsonwebtoken();
    !function(e2) {
      e2.GET = "get", e2.POST = "post";
    }(t || (t = {})), function(e2) {
      e2[e2.OK = 200] = "OK", e2[e2.REDIRECT = 302] = "REDIRECT";
    }(r || (r = {}));
    var h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    var u;
    !function(e2) {
      e2[e2.acquireTokenSilent = 62] = "acquireTokenSilent", e2[e2.acquireTokenByUsernamePassword = 371] = "acquireTokenByUsernamePassword", e2[e2.acquireTokenByDeviceCode = 671] = "acquireTokenByDeviceCode", e2[e2.acquireTokenByClientCredential = 771] = "acquireTokenByClientCredential", e2[e2.acquireTokenByCode = 871] = "acquireTokenByCode", e2[e2.acquireTokenByRefreshToken = 872] = "acquireTokenByRefreshToken";
    }(u || (u = {}));
    var d = class {
      async sendGetRequestAsync(e2, r2) {
        return null != r2 && r2.proxyUrl ? g(e2, t.GET, r2) : p(e2, t.GET, r2);
      }
      async sendPostRequestAsync(e2, r2, n2) {
        return null != r2 && r2.proxyUrl ? g(e2, t.POST, r2, n2) : p(e2, t.POST, r2, n2);
      }
    };
    var g = (e2, r2, n2, i2) => {
      const s2 = (null == n2 ? void 0 : n2.headers) || {}, a2 = new URL((null == n2 ? void 0 : n2.proxyUrl) || ""), c2 = new URL(e2), l2 = { host: a2.hostname, port: a2.port, method: "CONNECT", path: c2.hostname, headers: s2 };
      i2 && (l2.timeout = i2);
      let h2 = "";
      if (r2 === t.POST) {
        const e3 = (null == n2 ? void 0 : n2.body) || "";
        h2 = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${e3.length}\r
\r
` + e3;
      }
      const u2 = `${r2.toUpperCase()} ${c2.href} HTTP/1.1\r
Host: ${c2.host}\r
Connection: close\r
` + h2 + "\r\n";
      return new Promise((e3, t2) => {
        const r3 = o.request(l2);
        l2.timeout && r3.on("timeout", () => {
          r3.destroy(), t2(new Error("Request time out"));
        }), r3.end(), r3.on("connect", (n3, i3) => {
          const o2 = (null == n3 ? void 0 : n3.statusCode) || 500;
          (o2 < 200 || o2 > 299) && (r3.destroy(), i3.destroy(), t2(new Error("HTTP status code " + o2))), l2.timeout && (i3.setTimeout(l2.timeout), i3.on("timeout", () => {
            r3.destroy(), i3.destroy(), t2(new Error("Request time out"));
          })), i3.write(u2);
          const s3 = [];
          i3.on("data", (e4) => {
            s3.push(e4);
          }), i3.on("end", () => {
            const n4 = Buffer.concat([...s3]).toString().split("\r\n"), o3 = parseInt(n4[0].split(" ")[1]), a3 = n4[n4.length - 1], c3 = n4.slice(1, n4.length - 2), l3 = /* @__PURE__ */ new Map();
            c3.forEach((e4) => {
              const t3 = e4.split(new RegExp(/:\s(.*)/s)), r4 = t3[0];
              let n5 = t3[1];
              try {
                const e5 = JSON.parse(n5);
                e5 && "object" == typeof e5 && (n5 = e5);
              } catch (e5) {
              }
              l3.set(r4, n5);
            });
            const h3 = { headers: Object.fromEntries(l3), body: JSON.parse(a3), status: o3 };
            (o3 < 200 || o3 > 299) && "authorization_pending" !== h3.body.error && (r3.destroy(), i3.destroy(), t2(new Error("HTTP status code " + o3))), e3(h3);
          }), i3.on("error", (e4) => {
            r3.destroy(), i3.destroy(), t2(new Error(e4.toString()));
          });
        }), r3.on("error", (e4) => {
          r3.destroy(), t2(new Error(e4.toString()));
        });
      });
    };
    var p = (e2, r2, n2, i2) => {
      const o2 = r2 === t.POST, a2 = (null == n2 ? void 0 : n2.body) || "", c2 = { method: r2, headers: (null == n2 ? void 0 : n2.headers) || {} };
      return i2 && (c2.timeout = i2), o2 && (c2.headers = { ...c2.headers, "Content-Length": a2.length }), new Promise((t2, r3) => {
        const n3 = s.request(e2, c2);
        i2 && n3.on("timeout", () => {
          n3.destroy(), r3(new Error("Request time out"));
        }), o2 && n3.write(a2), n3.end(), n3.on("response", (e3) => {
          const i3 = e3.headers, o3 = e3.statusCode, s2 = [];
          e3.on("data", (e4) => {
            s2.push(e4);
          }), e3.on("end", () => {
            const e4 = Buffer.concat([...s2]).toString(), a3 = { headers: i3, body: JSON.parse(e4), status: o3 };
            (o3 < 200 || o3 > 299) && "authorization_pending" !== a3.body.error && (n3.destroy(), r3(new Error("HTTP status code " + o3))), t2(a3);
          });
        }), n3.on("error", (e3) => {
          n3.destroy(), r3(new Error(e3.toString()));
        });
      });
    };
    var y = { clientId: n.Constants.EMPTY_STRING, authority: n.Constants.DEFAULT_AUTHORITY, clientSecret: n.Constants.EMPTY_STRING, clientAssertion: n.Constants.EMPTY_STRING, clientCertificate: { thumbprint: n.Constants.EMPTY_STRING, privateKey: n.Constants.EMPTY_STRING, x5c: n.Constants.EMPTY_STRING }, knownAuthorities: [], cloudDiscoveryMetadata: n.Constants.EMPTY_STRING, authorityMetadata: n.Constants.EMPTY_STRING, clientCapabilities: [], protocolMode: n.ProtocolMode.AAD, azureCloudOptions: { azureCloudInstance: n.AzureCloudInstance.None, tenant: n.Constants.EMPTY_STRING }, skipAuthorityMetadataCache: false };
    var m = {};
    var f = { loggerOptions: { loggerCallback: () => {
    }, piiLoggingEnabled: false, logLevel: n.LogLevel.Info }, networkClient: class {
      static getNetworkClient() {
        return new d();
      }
    }.getNetworkClient(), proxyUrl: n.Constants.EMPTY_STRING };
    var C = { application: { appName: n.Constants.EMPTY_STRING, appVersion: n.Constants.EMPTY_STRING } };
    function T({ auth: e2, cache: t2, system: r2, telemetry: n2 }) {
      return { auth: { ...y, ...e2 }, cache: { ...m, ...t2 }, system: { ...f, ...r2 }, telemetry: { ...C, ...n2 } };
    }
    var A = class {
      generateGuid() {
        return a.v4();
      }
      isGuid(e2) {
        return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e2);
      }
    };
    var k = class {
      static base64Encode(e2, t2) {
        return Buffer.from(e2, t2).toString("base64");
      }
      static base64EncodeUrl(e2, t2) {
        return k.base64Encode(e2, t2).replace(/=/g, n.Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
      }
      static base64Decode(e2) {
        return Buffer.from(e2, "base64").toString("utf8");
      }
      static base64DecodeUrl(e2) {
        let t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
        for (; t2.length % 4; )
          t2 += "=";
        return k.base64Decode(t2);
      }
    };
    var I = class {
      sha256(e2) {
        return c.createHash("sha256").update(e2).digest();
      }
    };
    var E = class {
      constructor() {
        this.hashUtils = new I();
      }
      async generatePkceCodes() {
        const e2 = this.generateCodeVerifier();
        return { verifier: e2, challenge: this.generateCodeChallengeFromVerifier(e2) };
      }
      generateCodeVerifier() {
        const e2 = [], t2 = 256 - 256 % h.length;
        for (; e2.length <= 32; ) {
          const r3 = c.randomBytes(1)[0];
          r3 >= t2 || e2.push(h[r3 % h.length]);
        }
        const r2 = e2.join(n.Constants.EMPTY_STRING);
        return k.base64EncodeUrl(r2);
      }
      generateCodeChallengeFromVerifier(e2) {
        return k.base64EncodeUrl(this.hashUtils.sha256(e2).toString("base64"), "base64");
      }
    };
    var v = class {
      constructor() {
        this.pkceGenerator = new E(), this.guidGenerator = new A(), this.hashUtils = new I();
      }
      createNewGuid() {
        return this.guidGenerator.generateGuid();
      }
      base64Encode(e2) {
        return k.base64Encode(e2);
      }
      base64Decode(e2) {
        return k.base64Decode(e2);
      }
      generatePkceCodes() {
        return this.pkceGenerator.generatePkceCodes();
      }
      getPublicKeyThumbprint() {
        throw new Error("Method not implemented.");
      }
      removeTokenBindingKey() {
        throw new Error("Method not implemented.");
      }
      clearKeystore() {
        throw new Error("Method not implemented.");
      }
      signJwt() {
        throw new Error("Method not implemented.");
      }
      async hashString(e2) {
        return k.base64EncodeUrl(this.hashUtils.sha256(e2).toString("base64"), "base64");
      }
    };
    var w = class {
      static deserializeJSONBlob(e2) {
        return n.StringUtils.isEmpty(e2) ? {} : JSON.parse(e2);
      }
      static deserializeAccounts(e2) {
        const t2 = {};
        return e2 && Object.keys(e2).map(function(r2) {
          const i2 = e2[r2], o2 = { homeAccountId: i2.home_account_id, environment: i2.environment, realm: i2.realm, localAccountId: i2.local_account_id, username: i2.username, authorityType: i2.authority_type, name: i2.name, clientInfo: i2.client_info, lastModificationTime: i2.last_modification_time, lastModificationApp: i2.last_modification_app }, s2 = new n.AccountEntity();
          n.CacheManager.toObject(s2, o2), t2[r2] = s2;
        }), t2;
      }
      static deserializeIdTokens(e2) {
        const t2 = {};
        return e2 && Object.keys(e2).map(function(r2) {
          const i2 = e2[r2], o2 = { homeAccountId: i2.home_account_id, environment: i2.environment, credentialType: i2.credential_type, clientId: i2.client_id, secret: i2.secret, realm: i2.realm }, s2 = new n.IdTokenEntity();
          n.CacheManager.toObject(s2, o2), t2[r2] = s2;
        }), t2;
      }
      static deserializeAccessTokens(e2) {
        const t2 = {};
        return e2 && Object.keys(e2).map(function(r2) {
          const i2 = e2[r2], o2 = { homeAccountId: i2.home_account_id, environment: i2.environment, credentialType: i2.credential_type, clientId: i2.client_id, secret: i2.secret, realm: i2.realm, target: i2.target, cachedAt: i2.cached_at, expiresOn: i2.expires_on, extendedExpiresOn: i2.extended_expires_on, refreshOn: i2.refresh_on, keyId: i2.key_id, tokenType: i2.token_type, requestedClaims: i2.requestedClaims, requestedClaimsHash: i2.requestedClaimsHash }, s2 = new n.AccessTokenEntity();
          n.CacheManager.toObject(s2, o2), t2[r2] = s2;
        }), t2;
      }
      static deserializeRefreshTokens(e2) {
        const t2 = {};
        return e2 && Object.keys(e2).map(function(r2) {
          const i2 = e2[r2], o2 = { homeAccountId: i2.home_account_id, environment: i2.environment, credentialType: i2.credential_type, clientId: i2.client_id, secret: i2.secret, familyId: i2.family_id, target: i2.target, realm: i2.realm }, s2 = new n.RefreshTokenEntity();
          n.CacheManager.toObject(s2, o2), t2[r2] = s2;
        }), t2;
      }
      static deserializeAppMetadata(e2) {
        const t2 = {};
        return e2 && Object.keys(e2).map(function(r2) {
          const i2 = e2[r2], o2 = { clientId: i2.client_id, environment: i2.environment, familyId: i2.family_id }, s2 = new n.AppMetadataEntity();
          n.CacheManager.toObject(s2, o2), t2[r2] = s2;
        }), t2;
      }
      static deserializeAllCache(e2) {
        return { accounts: e2.Account ? this.deserializeAccounts(e2.Account) : {}, idTokens: e2.IdToken ? this.deserializeIdTokens(e2.IdToken) : {}, accessTokens: e2.AccessToken ? this.deserializeAccessTokens(e2.AccessToken) : {}, refreshTokens: e2.RefreshToken ? this.deserializeRefreshTokens(e2.RefreshToken) : {}, appMetadata: e2.AppMetadata ? this.deserializeAppMetadata(e2.AppMetadata) : {} };
      }
    };
    var b = class {
      static serializeJSONBlob(e2) {
        return JSON.stringify(e2);
      }
      static serializeAccounts(e2) {
        const t2 = {};
        return Object.keys(e2).map(function(r2) {
          const n2 = e2[r2];
          t2[r2] = { home_account_id: n2.homeAccountId, environment: n2.environment, realm: n2.realm, local_account_id: n2.localAccountId, username: n2.username, authority_type: n2.authorityType, name: n2.name, client_info: n2.clientInfo, last_modification_time: n2.lastModificationTime, last_modification_app: n2.lastModificationApp };
        }), t2;
      }
      static serializeIdTokens(e2) {
        const t2 = {};
        return Object.keys(e2).map(function(r2) {
          const n2 = e2[r2];
          t2[r2] = { home_account_id: n2.homeAccountId, environment: n2.environment, credential_type: n2.credentialType, client_id: n2.clientId, secret: n2.secret, realm: n2.realm };
        }), t2;
      }
      static serializeAccessTokens(e2) {
        const t2 = {};
        return Object.keys(e2).map(function(r2) {
          const n2 = e2[r2];
          t2[r2] = { home_account_id: n2.homeAccountId, environment: n2.environment, credential_type: n2.credentialType, client_id: n2.clientId, secret: n2.secret, realm: n2.realm, target: n2.target, cached_at: n2.cachedAt, expires_on: n2.expiresOn, extended_expires_on: n2.extendedExpiresOn, refresh_on: n2.refreshOn, key_id: n2.keyId, token_type: n2.tokenType, requestedClaims: n2.requestedClaims, requestedClaimsHash: n2.requestedClaimsHash };
        }), t2;
      }
      static serializeRefreshTokens(e2) {
        const t2 = {};
        return Object.keys(e2).map(function(r2) {
          const n2 = e2[r2];
          t2[r2] = { home_account_id: n2.homeAccountId, environment: n2.environment, credential_type: n2.credentialType, client_id: n2.clientId, secret: n2.secret, family_id: n2.familyId, target: n2.target, realm: n2.realm };
        }), t2;
      }
      static serializeAppMetadata(e2) {
        const t2 = {};
        return Object.keys(e2).map(function(r2) {
          const n2 = e2[r2];
          t2[r2] = { client_id: n2.clientId, environment: n2.environment, family_id: n2.familyId };
        }), t2;
      }
      static serializeAllCache(e2) {
        return { Account: this.serializeAccounts(e2.accounts), IdToken: this.serializeIdTokens(e2.idTokens), AccessToken: this.serializeAccessTokens(e2.accessTokens), RefreshToken: this.serializeRefreshTokens(e2.refreshTokens), AppMetadata: this.serializeAppMetadata(e2.appMetadata) };
      }
    };
    var S = class extends n.CacheManager {
      constructor(e2, t2, r2) {
        super(t2, r2), this.cache = {}, this.changeEmitters = [], this.logger = e2;
      }
      registerChangeEmitter(e2) {
        this.changeEmitters.push(e2);
      }
      emitChange() {
        this.changeEmitters.forEach((e2) => e2.call(null));
      }
      cacheToInMemoryCache(e2) {
        const t2 = { accounts: {}, idTokens: {}, accessTokens: {}, refreshTokens: {}, appMetadata: {} };
        for (const r2 in e2)
          if (e2[r2] instanceof n.AccountEntity)
            t2.accounts[r2] = e2[r2];
          else if (e2[r2] instanceof n.IdTokenEntity)
            t2.idTokens[r2] = e2[r2];
          else if (e2[r2] instanceof n.AccessTokenEntity)
            t2.accessTokens[r2] = e2[r2];
          else if (e2[r2] instanceof n.RefreshTokenEntity)
            t2.refreshTokens[r2] = e2[r2];
          else {
            if (!(e2[r2] instanceof n.AppMetadataEntity))
              continue;
            t2.appMetadata[r2] = e2[r2];
          }
        return t2;
      }
      inMemoryCacheToCache(e2) {
        let t2 = this.getCache();
        return t2 = { ...t2, ...e2.accounts, ...e2.idTokens, ...e2.accessTokens, ...e2.refreshTokens, ...e2.appMetadata }, t2;
      }
      getInMemoryCache() {
        return this.logger.trace("Getting in-memory cache"), this.cacheToInMemoryCache(this.getCache());
      }
      setInMemoryCache(e2) {
        this.logger.trace("Setting in-memory cache");
        const t2 = this.inMemoryCacheToCache(e2);
        this.setCache(t2), this.emitChange();
      }
      getCache() {
        return this.logger.trace("Getting cache key-value store"), this.cache;
      }
      setCache(e2) {
        this.logger.trace("Setting cache key value store"), this.cache = e2, this.emitChange();
      }
      getItem(e2) {
        return this.logger.tracePii("Item key: " + e2), this.getCache()[e2];
      }
      setItem(e2, t2) {
        this.logger.tracePii("Item key: " + e2);
        const r2 = this.getCache();
        r2[e2] = t2, this.setCache(r2);
      }
      getAccount(e2) {
        const t2 = this.getItem(e2);
        return n.AccountEntity.isAccountEntity(t2) ? t2 : null;
      }
      setAccount(e2) {
        const t2 = e2.generateAccountKey();
        this.setItem(t2, e2);
      }
      getIdTokenCredential(e2) {
        const t2 = this.getItem(e2);
        return n.IdTokenEntity.isIdTokenEntity(t2) ? t2 : null;
      }
      setIdTokenCredential(e2) {
        const t2 = e2.generateCredentialKey();
        this.setItem(t2, e2);
      }
      getAccessTokenCredential(e2) {
        const t2 = this.getItem(e2);
        return n.AccessTokenEntity.isAccessTokenEntity(t2) ? t2 : null;
      }
      setAccessTokenCredential(e2) {
        const t2 = e2.generateCredentialKey();
        this.setItem(t2, e2);
      }
      getRefreshTokenCredential(e2) {
        const t2 = this.getItem(e2);
        return n.RefreshTokenEntity.isRefreshTokenEntity(t2) ? t2 : null;
      }
      setRefreshTokenCredential(e2) {
        const t2 = e2.generateCredentialKey();
        this.setItem(t2, e2);
      }
      getAppMetadata(e2) {
        const t2 = this.getItem(e2);
        return n.AppMetadataEntity.isAppMetadataEntity(e2, t2) ? t2 : null;
      }
      setAppMetadata(e2) {
        const t2 = e2.generateAppMetadataKey();
        this.setItem(t2, e2);
      }
      getServerTelemetry(e2) {
        const t2 = this.getItem(e2);
        return t2 && n.ServerTelemetryEntity.isServerTelemetryEntity(e2, t2) ? t2 : null;
      }
      setServerTelemetry(e2, t2) {
        this.setItem(e2, t2);
      }
      getAuthorityMetadata(e2) {
        const t2 = this.getItem(e2);
        return t2 && n.AuthorityMetadataEntity.isAuthorityMetadataEntity(e2, t2) ? t2 : null;
      }
      getAuthorityMetadataKeys() {
        return this.getKeys().filter((e2) => this.isAuthorityMetadata(e2));
      }
      setAuthorityMetadata(e2, t2) {
        this.setItem(e2, t2);
      }
      getThrottlingCache(e2) {
        const t2 = this.getItem(e2);
        return t2 && n.ThrottlingEntity.isThrottlingEntity(e2, t2) ? t2 : null;
      }
      setThrottlingCache(e2, t2) {
        this.setItem(e2, t2);
      }
      removeItem(e2) {
        this.logger.tracePii("Item key: " + e2);
        let t2 = false;
        const r2 = this.getCache();
        return r2[e2] && (delete r2[e2], t2 = true), t2 && (this.setCache(r2), this.emitChange()), t2;
      }
      containsKey(e2) {
        return this.getKeys().includes(e2);
      }
      getKeys() {
        this.logger.trace("Retrieving all cache keys");
        const e2 = this.getCache();
        return [...Object.keys(e2)];
      }
      async clear() {
        this.logger.trace("Clearing cache entries created by MSAL"), this.getKeys().forEach((e2) => {
          this.removeItem(e2);
        }), this.emitChange();
      }
      static generateInMemoryCache(e2) {
        return w.deserializeAllCache(w.deserializeJSONBlob(e2));
      }
      static generateJsonCache(e2) {
        return b.serializeAllCache(e2);
      }
      updateCredentialCacheKey(e2, t2) {
        const r2 = t2.generateCredentialKey();
        if (e2 !== r2) {
          const n2 = this.getItem(e2);
          if (n2)
            return this.removeItem(e2), this.setItem(r2, n2), this.logger.verbose(`Updated an outdated ${t2.credentialType} cache key`), r2;
          this.logger.error(`Attempted to update an outdated ${t2.credentialType} cache key but no item matching the outdated key was found in storage`);
        }
        return e2;
      }
    };
    var R = {};
    var M = {};
    var _ = {};
    var O = {};
    var P = {};
    var q2 = class {
      constructor(e2, t2, r2) {
        this.cacheHasChanged = false, this.storage = e2, this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this)), r2 && (this.persistence = r2), this.logger = t2;
      }
      hasChanged() {
        return this.cacheHasChanged;
      }
      serialize() {
        this.logger.trace("Serializing in-memory cache");
        let e2 = b.serializeAllCache(this.storage.getInMemoryCache());
        return n.StringUtils.isEmpty(this.cacheSnapshot) ? this.logger.trace("No cache snapshot to merge") : (this.logger.trace("Reading cache snapshot from disk"), e2 = this.mergeState(JSON.parse(this.cacheSnapshot), e2)), this.cacheHasChanged = false, JSON.stringify(e2);
      }
      deserialize(e2) {
        if (this.logger.trace("Deserializing JSON to in-memory cache"), this.cacheSnapshot = e2, n.StringUtils.isEmpty(this.cacheSnapshot))
          this.logger.trace("No cache snapshot to deserialize");
        else {
          this.logger.trace("Reading cache snapshot from disk");
          const e3 = w.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
          this.storage.setInMemoryCache(e3);
        }
      }
      getKVStore() {
        return this.storage.getCache();
      }
      async getAllAccounts() {
        let e2;
        this.logger.trace("getAllAccounts called");
        try {
          return this.persistence && (e2 = new n.TokenCacheContext(this, false), await this.persistence.beforeCacheAccess(e2)), this.storage.getAllAccounts();
        } finally {
          this.persistence && e2 && await this.persistence.afterCacheAccess(e2);
        }
      }
      async getAccountByHomeId(e2) {
        const t2 = await this.getAllAccounts();
        return !n.StringUtils.isEmpty(e2) && t2 && t2.length && t2.filter((t3) => t3.homeAccountId === e2)[0] || null;
      }
      async getAccountByLocalId(e2) {
        const t2 = await this.getAllAccounts();
        return !n.StringUtils.isEmpty(e2) && t2 && t2.length && t2.filter((t3) => t3.localAccountId === e2)[0] || null;
      }
      async removeAccount(e2) {
        let t2;
        this.logger.trace("removeAccount called");
        try {
          this.persistence && (t2 = new n.TokenCacheContext(this, true), await this.persistence.beforeCacheAccess(t2)), await this.storage.removeAccount(n.AccountEntity.generateAccountCacheKey(e2));
        } finally {
          this.persistence && t2 && await this.persistence.afterCacheAccess(t2);
        }
      }
      handleChangeEvent() {
        this.cacheHasChanged = true;
      }
      mergeState(e2, t2) {
        this.logger.trace("Merging in-memory cache with cache snapshot");
        const r2 = this.mergeRemovals(e2, t2);
        return this.mergeUpdates(r2, t2);
      }
      mergeUpdates(e2, t2) {
        return Object.keys(t2).forEach((r2) => {
          const n2 = t2[r2];
          if (e2.hasOwnProperty(r2)) {
            const t3 = null !== n2, i2 = "object" == typeof n2, o2 = !Array.isArray(n2), s2 = null != e2[r2];
            t3 && i2 && o2 && s2 ? this.mergeUpdates(e2[r2], n2) : e2[r2] = n2;
          } else
            null !== n2 && (e2[r2] = n2);
        }), e2;
      }
      mergeRemovals(e2, t2) {
        this.logger.trace("Remove updated entries in cache");
        const r2 = e2.Account ? this.mergeRemovalsDict(e2.Account, t2.Account) : e2.Account, n2 = e2.AccessToken ? this.mergeRemovalsDict(e2.AccessToken, t2.AccessToken) : e2.AccessToken, i2 = e2.RefreshToken ? this.mergeRemovalsDict(e2.RefreshToken, t2.RefreshToken) : e2.RefreshToken, o2 = e2.IdToken ? this.mergeRemovalsDict(e2.IdToken, t2.IdToken) : e2.IdToken, s2 = e2.AppMetadata ? this.mergeRemovalsDict(e2.AppMetadata, t2.AppMetadata) : e2.AppMetadata;
        return { ...e2, Account: r2, AccessToken: n2, RefreshToken: i2, IdToken: o2, AppMetadata: s2 };
      }
      mergeRemovalsDict(e2, t2) {
        const r2 = { ...e2 };
        return Object.keys(e2).forEach((e3) => {
          t2 && t2.hasOwnProperty(e3) || delete r2[e3];
        }), r2;
      }
      overlayDefaults(e2) {
        return this.logger.trace("Overlaying input cache with the default cache"), { Account: { ...R, ...e2.Account }, IdToken: { ...M, ...e2.IdToken }, AccessToken: { ..._, ...e2.AccessToken }, RefreshToken: { ...O, ...e2.RefreshToken }, AppMetadata: { ...P, ...e2.AppMetadata } };
      }
    };
    var x = class {
      constructor(e2) {
        this.config = T(e2), this.cryptoProvider = new v(), this.logger = new n.Logger(this.config.system.loggerOptions, "@azure/msal-node", "1.13.0"), this.storage = new S(this.logger, this.config.auth.clientId, this.cryptoProvider), this.tokenCache = new q2(this.storage, this.logger, this.config.cache.cachePlugin);
      }
      async getAuthCodeUrl(e2) {
        this.logger.info("getAuthCodeUrl called", e2.correlationId);
        const t2 = { ...e2, ...await this.initializeBaseRequest(e2), responseMode: e2.responseMode || n.ResponseMode.QUERY, authenticationScheme: n.AuthenticationScheme.BEARER }, r2 = await this.buildOauthClientConfiguration(t2.authority, t2.correlationId, void 0, void 0, e2.azureCloudOptions), i2 = new n.AuthorizationCodeClient(r2);
        return this.logger.verbose("Auth code client created", t2.correlationId), i2.getAuthCodeUrl(t2);
      }
      async acquireTokenByCode(e2, t2) {
        this.logger.info("acquireTokenByCode called", e2.correlationId);
        const r2 = { ...e2, ...await this.initializeBaseRequest(e2), authenticationScheme: n.AuthenticationScheme.BEARER }, i2 = this.initializeServerTelemetryManager(u.acquireTokenByCode, r2.correlationId);
        try {
          const o2 = await this.buildOauthClientConfiguration(r2.authority, r2.correlationId, i2, void 0, e2.azureCloudOptions), s2 = new n.AuthorizationCodeClient(o2);
          return this.logger.verbose("Auth code client created", r2.correlationId), s2.acquireToken(r2, t2);
        } catch (e3) {
          throw e3 instanceof n.AuthError && e3.setCorrelationId(r2.correlationId), i2.cacheFailedRequest(e3), e3;
        }
      }
      async acquireTokenByRefreshToken(e2) {
        this.logger.info("acquireTokenByRefreshToken called", e2.correlationId);
        const t2 = { ...e2, ...await this.initializeBaseRequest(e2), authenticationScheme: n.AuthenticationScheme.BEARER }, r2 = this.initializeServerTelemetryManager(u.acquireTokenByRefreshToken, t2.correlationId);
        try {
          const i2 = await this.buildOauthClientConfiguration(t2.authority, t2.correlationId, r2, void 0, e2.azureCloudOptions), o2 = new n.RefreshTokenClient(i2);
          return this.logger.verbose("Refresh token client created", t2.correlationId), o2.acquireToken(t2);
        } catch (e3) {
          throw e3 instanceof n.AuthError && e3.setCorrelationId(t2.correlationId), r2.cacheFailedRequest(e3), e3;
        }
      }
      async acquireTokenSilent(e2) {
        const t2 = { ...e2, ...await this.initializeBaseRequest(e2), forceRefresh: e2.forceRefresh || false }, r2 = this.initializeServerTelemetryManager(u.acquireTokenSilent, t2.correlationId, t2.forceRefresh);
        try {
          const i2 = await this.buildOauthClientConfiguration(t2.authority, t2.correlationId, r2, void 0, e2.azureCloudOptions), o2 = new n.SilentFlowClient(i2);
          return this.logger.verbose("Silent flow client created", t2.correlationId), o2.acquireToken(t2);
        } catch (e3) {
          throw e3 instanceof n.AuthError && e3.setCorrelationId(t2.correlationId), r2.cacheFailedRequest(e3), e3;
        }
      }
      async acquireTokenByUsernamePassword(e2) {
        this.logger.info("acquireTokenByUsernamePassword called", e2.correlationId);
        const t2 = { ...e2, ...await this.initializeBaseRequest(e2) }, r2 = this.initializeServerTelemetryManager(u.acquireTokenByUsernamePassword, t2.correlationId);
        try {
          const i2 = await this.buildOauthClientConfiguration(t2.authority, t2.correlationId, r2, void 0, e2.azureCloudOptions), o2 = new n.UsernamePasswordClient(i2);
          return this.logger.verbose("Username password client created", t2.correlationId), o2.acquireToken(t2);
        } catch (e3) {
          throw e3 instanceof n.AuthError && e3.setCorrelationId(t2.correlationId), r2.cacheFailedRequest(e3), e3;
        }
      }
      getTokenCache() {
        return this.logger.info("getTokenCache called"), this.tokenCache;
      }
      getLogger() {
        return this.logger;
      }
      setLogger(e2) {
        this.logger = e2;
      }
      async buildOauthClientConfiguration(e2, t2, r2, i2, o2) {
        this.logger.verbose("buildOauthClientConfiguration called", t2);
        const s2 = o2 || this.config.auth.azureCloudOptions;
        this.logger.verbose("building oauth client configuration with the authority: " + e2, t2);
        const a2 = await this.createAuthority(e2, i2, t2, s2);
        return null == r2 || r2.updateRegionDiscoveryMetadata(a2.regionDiscoveryMetadata), { authOptions: { clientId: this.config.auth.clientId, authority: a2, clientCapabilities: this.config.auth.clientCapabilities }, systemOptions: { proxyUrl: this.config.system.proxyUrl }, loggerOptions: { logLevel: this.config.system.loggerOptions.logLevel, loggerCallback: this.config.system.loggerOptions.loggerCallback, piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled, correlationId: t2 }, cryptoInterface: this.cryptoProvider, networkInterface: this.config.system.networkClient, storageInterface: this.storage, serverTelemetryManager: r2, clientCredentials: { clientSecret: this.clientSecret, clientAssertion: this.clientAssertion ? this.getClientAssertion(a2) : void 0 }, libraryInfo: { sku: "msal.js.node", version: "1.13.0", cpu: process.arch || n.Constants.EMPTY_STRING, os: process.platform || n.Constants.EMPTY_STRING }, telemetry: this.config.telemetry, persistencePlugin: this.config.cache.cachePlugin, serializableCache: this.tokenCache };
      }
      getClientAssertion(e2) {
        return { assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, e2.tokenEndpoint), assertionType: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer" };
      }
      async initializeBaseRequest(e2) {
        return this.logger.verbose("initializeRequestScopes called", e2.correlationId), e2.authenticationScheme && e2.authenticationScheme === n.AuthenticationScheme.POP && this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", e2.correlationId), e2.authenticationScheme = n.AuthenticationScheme.BEARER, e2.claims && !n.StringUtils.isEmpty(e2.claims) && (e2.requestedClaimsHash = await this.cryptoProvider.hashString(e2.claims)), { ...e2, scopes: [...e2 && e2.scopes || [], ...n.OIDC_DEFAULT_SCOPES], correlationId: e2 && e2.correlationId || this.cryptoProvider.createNewGuid(), authority: e2.authority || this.config.auth.authority };
      }
      initializeServerTelemetryManager(e2, t2, r2) {
        return new n.ServerTelemetryManager({ clientId: this.config.auth.clientId, correlationId: t2, apiId: e2, forceRefresh: r2 || false }, this.storage);
      }
      async createAuthority(e2, t2, r2, i2) {
        this.logger.verbose("createAuthority called", r2);
        const o2 = n.Authority.generateAuthority(e2, i2), s2 = { protocolMode: this.config.auth.protocolMode, knownAuthorities: this.config.auth.knownAuthorities, cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata, authorityMetadata: this.config.auth.authorityMetadata, azureRegionConfiguration: t2, skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache };
        return await n.AuthorityFactory.createDiscoveredInstance(o2, this.config.system.networkClient, this.storage, s2, this.config.system.proxyUrl);
      }
      clearCache() {
        this.storage.clear();
      }
    };
    var z = class extends n.AuthError {
      constructor(e2, t2) {
        super(e2, t2), this.name = "NodeAuthError";
      }
      static createInvalidLoopbackAddressTypeError() {
        return new z("invalid_loopback_server_address_type", "Loopback server address is not type string. This is unexpected.");
      }
      static createUnableToLoadRedirectUrlError() {
        return new z("unable_to_load_redirectUrl", "Loopback server callback was invoked without a url. This is unexpected.");
      }
      static createNoAuthCodeInResponseError() {
        return new z("no_auth_code_in_response", "No auth code found in the server response. Please check your network trace to determine what happened.");
      }
      static createNoLoopbackServerExistsError() {
        return new z("no_loopback_server_exists", "No loopback server exists yet.");
      }
      static createLoopbackServerAlreadyExistsError() {
        return new z("loopback_server_already_exists", "Loopback server already exists. Cannot create another.");
      }
      static createLoopbackServerTimeoutError() {
        return new z("loopback_server_timeout", "Timed out waiting for auth code listener to be registered.");
      }
    };
    var U = class {
      async listenForAuthCode(e2, t2) {
        if (this.server)
          throw z.createLoopbackServerAlreadyExistsError();
        const o2 = new Promise((o3, s2) => {
          this.server = i.createServer(async (i2, a2) => {
            const c2 = i2.url;
            if (!c2)
              return a2.end(t2 || "Error occurred loading redirectUrl"), void s2(z.createUnableToLoadRedirectUrlError());
            if (c2 === n.Constants.FORWARD_SLASH)
              return void a2.end(e2 || "Auth code was successfully acquired. You can close this window now.");
            const l2 = n.UrlString.getDeserializedQueryString(c2);
            if (l2.code) {
              const e3 = await this.getRedirectUri();
              a2.writeHead(r.REDIRECT, { location: e3 }), a2.end();
            }
            o3(l2);
          }), this.server.listen(0);
        });
        return await new Promise((e3) => {
          let t3 = 0;
          const r2 = setInterval(() => {
            if (50 < t3)
              throw z.createLoopbackServerTimeoutError();
            this.server.listening && (clearInterval(r2), e3()), t3++;
          }, 100);
        }), o2;
      }
      getRedirectUri() {
        if (!this.server)
          throw z.createNoLoopbackServerExistsError();
        const e2 = this.server.address();
        if (!e2 || "string" == typeof e2 || !e2.port)
          throw this.closeServer(), z.createInvalidLoopbackAddressTypeError();
        return "http://localhost:" + (e2 && e2.port);
      }
      closeServer() {
        this.server && this.server.close();
      }
    };
    var j = class {
      static fromAssertion(e2) {
        const t2 = new j();
        return t2.jwt = e2, t2;
      }
      static fromCertificate(e2, t2, r2) {
        const n2 = new j();
        return n2.privateKey = t2, n2.thumbprint = e2, r2 && (n2.publicCertificate = this.parseCertificate(r2)), n2;
      }
      getJwt(e2, t2, r2) {
        if (this.privateKey && this.thumbprint)
          return this.jwt && !this.isExpired() && t2 === this.issuer && r2 === this.jwtAudience ? this.jwt : this.createJwt(e2, t2, r2);
        if (this.jwt)
          return this.jwt;
        throw n.ClientAuthError.createInvalidAssertionError();
      }
      createJwt(e2, t2, r2) {
        this.issuer = t2, this.jwtAudience = r2;
        const i2 = n.TimeUtils.nowSeconds();
        this.expirationTime = i2 + 600;
        const o2 = { alg: "RS256", x5t: k.base64EncodeUrl(this.thumbprint, "hex") };
        this.publicCertificate && Object.assign(o2, { x5c: this.publicCertificate });
        const s2 = { aud: this.jwtAudience, exp: this.expirationTime, iss: this.issuer, sub: this.issuer, nbf: i2, jti: e2.createNewGuid() };
        return this.jwt = l.sign(s2, this.privateKey, { header: o2 }), this.jwt;
      }
      isExpired() {
        return this.expirationTime < n.TimeUtils.nowSeconds();
      }
      static parseCertificate(e2) {
        const t2 = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs, r2 = [];
        let i2;
        for (; null !== (i2 = t2.exec(e2)); )
          r2.push(i2[1].replace(/\r*\n/g, n.Constants.EMPTY_STRING));
        return r2;
      }
    };
    Object.defineProperty(exports2, "AuthError", { enumerable: true, get: function() {
      return n.AuthError;
    } }), Object.defineProperty(exports2, "AuthErrorMessage", { enumerable: true, get: function() {
      return n.AuthErrorMessage;
    } }), Object.defineProperty(exports2, "AzureCloudInstance", { enumerable: true, get: function() {
      return n.AzureCloudInstance;
    } }), Object.defineProperty(exports2, "ClientAuthError", { enumerable: true, get: function() {
      return n.ClientAuthError;
    } }), Object.defineProperty(exports2, "ClientAuthErrorMessage", { enumerable: true, get: function() {
      return n.ClientAuthErrorMessage;
    } }), Object.defineProperty(exports2, "ClientConfigurationError", { enumerable: true, get: function() {
      return n.ClientConfigurationError;
    } }), Object.defineProperty(exports2, "ClientConfigurationErrorMessage", { enumerable: true, get: function() {
      return n.ClientConfigurationErrorMessage;
    } }), Object.defineProperty(exports2, "InteractionRequiredAuthError", { enumerable: true, get: function() {
      return n.InteractionRequiredAuthError;
    } }), Object.defineProperty(exports2, "InteractionRequiredAuthErrorMessage", { enumerable: true, get: function() {
      return n.InteractionRequiredAuthErrorMessage;
    } }), Object.defineProperty(exports2, "LogLevel", { enumerable: true, get: function() {
      return n.LogLevel;
    } }), Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
      return n.Logger;
    } }), Object.defineProperty(exports2, "PromptValue", { enumerable: true, get: function() {
      return n.PromptValue;
    } }), Object.defineProperty(exports2, "ProtocolMode", { enumerable: true, get: function() {
      return n.ProtocolMode;
    } }), Object.defineProperty(exports2, "ResponseMode", { enumerable: true, get: function() {
      return n.ResponseMode;
    } }), Object.defineProperty(exports2, "ServerError", { enumerable: true, get: function() {
      return n.ServerError;
    } }), Object.defineProperty(exports2, "TokenCacheContext", { enumerable: true, get: function() {
      return n.TokenCacheContext;
    } }), exports2.ClientApplication = x, exports2.ClientAssertion = j, exports2.ConfidentialClientApplication = class extends x {
      constructor(e2) {
        super(e2), this.setClientCredential(this.config), this.appTokenProvider = void 0;
      }
      SetAppTokenProvider(e2) {
        this.appTokenProvider = e2;
      }
      async acquireTokenByClientCredential(e2) {
        let t2;
        this.logger.info("acquireTokenByClientCredential called", e2.correlationId), e2.clientAssertion && (t2 = { assertion: e2.clientAssertion, assertionType: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer" });
        const r2 = { ...e2, ...await this.initializeBaseRequest(e2), clientAssertion: t2 }, i2 = { azureRegion: r2.azureRegion, environmentRegion: process.env.REGION_NAME }, o2 = this.initializeServerTelemetryManager(u.acquireTokenByClientCredential, r2.correlationId, r2.skipCache);
        try {
          const t3 = await this.buildOauthClientConfiguration(r2.authority, r2.correlationId, o2, i2, e2.azureCloudOptions), s2 = new n.ClientCredentialClient(t3, this.appTokenProvider);
          return this.logger.verbose("Client credential client created", r2.correlationId), s2.acquireToken(r2);
        } catch (e3) {
          throw e3 instanceof n.AuthError && e3.setCorrelationId(r2.correlationId), o2.cacheFailedRequest(e3), e3;
        }
      }
      async acquireTokenOnBehalfOf(e2) {
        this.logger.info("acquireTokenOnBehalfOf called", e2.correlationId);
        const t2 = { ...e2, ...await this.initializeBaseRequest(e2) };
        try {
          const r2 = await this.buildOauthClientConfiguration(t2.authority, t2.correlationId, void 0, void 0, e2.azureCloudOptions), i2 = new n.OnBehalfOfClient(r2);
          return this.logger.verbose("On behalf of client created", t2.correlationId), i2.acquireToken(t2);
        } catch (e3) {
          throw e3 instanceof n.AuthError && e3.setCorrelationId(t2.correlationId), e3;
        }
      }
      setClientCredential(e2) {
        const t2 = !n.StringUtils.isEmpty(e2.auth.clientSecret), r2 = !n.StringUtils.isEmpty(e2.auth.clientAssertion), i2 = e2.auth.clientCertificate || { thumbprint: n.Constants.EMPTY_STRING, privateKey: n.Constants.EMPTY_STRING }, o2 = !n.StringUtils.isEmpty(i2.thumbprint) || !n.StringUtils.isEmpty(i2.privateKey);
        if (!this.appTokenProvider) {
          if (t2 && r2 || r2 && o2 || t2 && o2)
            throw n.ClientAuthError.createInvalidCredentialError();
          if (e2.auth.clientSecret)
            this.clientSecret = e2.auth.clientSecret;
          else if (e2.auth.clientAssertion)
            this.clientAssertion = j.fromAssertion(e2.auth.clientAssertion);
          else {
            if (!o2)
              throw n.ClientAuthError.createInvalidCredentialError();
            var s2;
            this.clientAssertion = j.fromCertificate(i2.thumbprint, i2.privateKey, null == (s2 = e2.auth.clientCertificate) ? void 0 : s2.x5c);
          }
        }
      }
    }, exports2.CryptoProvider = v, exports2.DistributedCachePlugin = class {
      constructor(e2, t2) {
        this.client = e2, this.partitionManager = t2;
      }
      async beforeCacheAccess(e2) {
        const t2 = await this.partitionManager.getKey(), r2 = await this.client.get(t2);
        e2.tokenCache.deserialize(r2);
      }
      async afterCacheAccess(e2) {
        if (e2.cacheHasChanged) {
          const t2 = e2.tokenCache.getKVStore(), r2 = Object.values(t2).filter((e3) => n.AccountEntity.isAccountEntity(e3));
          if (r2.length > 0) {
            const t3 = r2[0], n2 = await this.partitionManager.extractKey(t3);
            await this.client.set(n2, e2.tokenCache.serialize());
          }
        }
      }
    }, exports2.NodeStorage = S, exports2.PublicClientApplication = class extends x {
      constructor(e2) {
        super(e2);
      }
      async acquireTokenByDeviceCode(e2) {
        this.logger.info("acquireTokenByDeviceCode called", e2.correlationId);
        const t2 = Object.assign(e2, await this.initializeBaseRequest(e2)), r2 = this.initializeServerTelemetryManager(u.acquireTokenByDeviceCode, t2.correlationId);
        try {
          const i2 = await this.buildOauthClientConfiguration(t2.authority, t2.correlationId, r2, void 0, e2.azureCloudOptions), o2 = new n.DeviceCodeClient(i2);
          return this.logger.verbose("Device code client created", t2.correlationId), o2.acquireToken(t2);
        } catch (e3) {
          throw e3 instanceof n.AuthError && e3.setCorrelationId(t2.correlationId), r2.cacheFailedRequest(e3), e3;
        }
      }
      async acquireTokenInteractive(e2) {
        const { verifier: t2, challenge: r2 } = await this.cryptoProvider.generatePkceCodes(), { openBrowser: i2, successTemplate: o2, errorTemplate: s2, ...a2 } = e2, c2 = new U(), l2 = c2.listenForAuthCode(o2, s2), h2 = c2.getRedirectUri(), u2 = { ...a2, scopes: e2.scopes || [], redirectUri: h2, responseMode: n.ResponseMode.QUERY, codeChallenge: r2, codeChallengeMethod: n.CodeChallengeMethodValues.S256 }, d2 = await this.getAuthCodeUrl(u2);
        await i2(d2);
        const g2 = await l2.finally(() => {
          c2.closeServer();
        });
        if (g2.error)
          throw new n.ServerError(g2.error, g2.error_description, g2.suberror);
        if (!g2.code)
          throw z.createNoAuthCodeInResponseError();
        return this.acquireTokenByCode({ code: g2.code, scopes: n.OIDC_DEFAULT_SCOPES, redirectUri: u2.redirectUri, codeVerifier: t2, clientInfo: g2.client_info || n.Constants.EMPTY_STRING });
      }
    }, exports2.TokenCache = q2, exports2.buildAppConfiguration = T, exports2.version = "1.13.0";
  }
});

// ../node_modules/@azure/msal-node/dist/msal-node.cjs.development.js
var require_msal_node_cjs_development = __commonJS({
  "../node_modules/@azure/msal-node/dist/msal-node.cjs.development.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var msalCommon = require_index_cjs();
    var http = require("http");
    var http__default = _interopDefault(http);
    var https = _interopDefault(require("https"));
    var uuid = require_dist4();
    var crypto = _interopDefault(require("crypto"));
    var jsonwebtoken = require_jsonwebtoken();
    var HttpMethod;
    (function(HttpMethod2) {
      HttpMethod2["GET"] = "get";
      HttpMethod2["POST"] = "post";
    })(HttpMethod || (HttpMethod = {}));
    var HttpStatus;
    (function(HttpStatus2) {
      HttpStatus2[HttpStatus2["OK"] = 200] = "OK";
      HttpStatus2[HttpStatus2["REDIRECT"] = 302] = "REDIRECT";
    })(HttpStatus || (HttpStatus = {}));
    var REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";
    var RANDOM_OCTET_SIZE = 32;
    var Hash = {
      SHA256: "sha256"
    };
    var CharSet = {
      CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
    };
    var Constants = {
      MSAL_SKU: "msal.js.node",
      JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
      AUTHORIZATION_PENDING: "authorization_pending",
      HTTP_PROTOCOL: "http://",
      LOCALHOST: "localhost"
    };
    var ApiId;
    (function(ApiId2) {
      ApiId2[ApiId2["acquireTokenSilent"] = 62] = "acquireTokenSilent";
      ApiId2[ApiId2["acquireTokenByUsernamePassword"] = 371] = "acquireTokenByUsernamePassword";
      ApiId2[ApiId2["acquireTokenByDeviceCode"] = 671] = "acquireTokenByDeviceCode";
      ApiId2[ApiId2["acquireTokenByClientCredential"] = 771] = "acquireTokenByClientCredential";
      ApiId2[ApiId2["acquireTokenByCode"] = 871] = "acquireTokenByCode";
      ApiId2[ApiId2["acquireTokenByRefreshToken"] = 872] = "acquireTokenByRefreshToken";
    })(ApiId || (ApiId = {}));
    var JwtConstants = {
      ALGORITHM: "alg",
      RSA_256: "RS256",
      X5T: "x5t",
      X5C: "x5c",
      AUDIENCE: "aud",
      EXPIRATION_TIME: "exp",
      ISSUER: "iss",
      SUBJECT: "sub",
      NOT_BEFORE: "nbf",
      JWT_ID: "jti"
    };
    var LOOPBACK_SERVER_CONSTANTS = {
      INTERVAL_MS: 100,
      TIMEOUT_MS: 5e3
    };
    var HttpClient = class {
      async sendGetRequestAsync(url, options) {
        if (options != null && options.proxyUrl) {
          return networkRequestViaProxy(url, HttpMethod.GET, options);
        } else {
          return networkRequestViaHttps(url, HttpMethod.GET, options);
        }
      }
      async sendPostRequestAsync(url, options, cancellationToken) {
        if (options != null && options.proxyUrl) {
          return networkRequestViaProxy(url, HttpMethod.POST, options, cancellationToken);
        } else {
          return networkRequestViaHttps(url, HttpMethod.POST, options, cancellationToken);
        }
      }
    };
    var networkRequestViaProxy = (url, httpMethod, options, timeout) => {
      const headers = (options == null ? void 0 : options.headers) || {};
      const proxyUrl = new URL((options == null ? void 0 : options.proxyUrl) || "");
      const destinationUrl = new URL(url);
      const tunnelRequestOptions = {
        host: proxyUrl.hostname,
        port: proxyUrl.port,
        method: "CONNECT",
        path: destinationUrl.hostname,
        headers
      };
      if (timeout) {
        tunnelRequestOptions.timeout = timeout;
      }
      let postRequestStringContent = "";
      if (httpMethod === HttpMethod.POST) {
        const body = (options == null ? void 0 : options.body) || "";
        postRequestStringContent = `Content-Type: application/x-www-form-urlencoded\r
Content-Length: ${body.length}\r
\r
${body}`;
      }
      const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r
Host: ${destinationUrl.host}\r
Connection: close\r
` + postRequestStringContent + "\r\n";
      return new Promise((resolve, reject) => {
        const request = http__default.request(tunnelRequestOptions);
        if (tunnelRequestOptions.timeout) {
          request.on("timeout", () => {
            request.destroy();
            reject(new Error("Request time out"));
          });
        }
        request.end();
        request.on("connect", (response, socket) => {
          const statusCode = (response == null ? void 0 : response.statusCode) || 500;
          if (statusCode < 200 || statusCode > 299) {
            request.destroy();
            socket.destroy();
            reject(new Error(`HTTP status code ${statusCode}`));
          }
          if (tunnelRequestOptions.timeout) {
            socket.setTimeout(tunnelRequestOptions.timeout);
            socket.on("timeout", () => {
              request.destroy();
              socket.destroy();
              reject(new Error("Request time out"));
            });
          }
          socket.write(outgoingRequestString);
          const data = [];
          socket.on("data", (chunk) => {
            data.push(chunk);
          });
          socket.on("end", () => {
            const dataString = Buffer.concat([...data]).toString();
            const dataStringArray = dataString.split("\r\n");
            const statusCode2 = parseInt(dataStringArray[0].split(" ")[1]);
            const body = dataStringArray[dataStringArray.length - 1];
            const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
            const entries = /* @__PURE__ */ new Map();
            headersArray.forEach((header) => {
              const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
              const headerKey = headerKeyValue[0];
              let headerValue = headerKeyValue[1];
              try {
                const object = JSON.parse(headerValue);
                if (object && typeof object === "object") {
                  headerValue = object;
                }
              } catch (e) {
              }
              entries.set(headerKey, headerValue);
            });
            const headers2 = Object.fromEntries(entries);
            const networkResponse = {
              headers: headers2,
              body: JSON.parse(body),
              status: statusCode2
            };
            if ((statusCode2 < 200 || statusCode2 > 299) && networkResponse.body["error"] !== Constants.AUTHORIZATION_PENDING) {
              request.destroy();
              socket.destroy();
              reject(new Error(`HTTP status code ${statusCode2}`));
            }
            resolve(networkResponse);
          });
          socket.on("error", (chunk) => {
            request.destroy();
            socket.destroy();
            reject(new Error(chunk.toString()));
          });
        });
        request.on("error", (chunk) => {
          request.destroy();
          reject(new Error(chunk.toString()));
        });
      });
    };
    var networkRequestViaHttps = (url, httpMethod, options, timeout) => {
      const isPostRequest = httpMethod === HttpMethod.POST;
      const body = (options == null ? void 0 : options.body) || "";
      const emptyHeaders = {};
      const customOptions = {
        method: httpMethod,
        headers: (options == null ? void 0 : options.headers) || emptyHeaders
      };
      if (timeout) {
        customOptions.timeout = timeout;
      }
      if (isPostRequest) {
        customOptions.headers = {
          ...customOptions.headers,
          "Content-Length": body.length
        };
      }
      return new Promise((resolve, reject) => {
        const request = https.request(url, customOptions);
        if (timeout) {
          request.on("timeout", () => {
            request.destroy();
            reject(new Error("Request time out"));
          });
        }
        if (isPostRequest) {
          request.write(body);
        }
        request.end();
        request.on("response", (response) => {
          const headers = response.headers;
          const statusCode = response.statusCode;
          const data = [];
          response.on("data", (chunk) => {
            data.push(chunk);
          });
          response.on("end", () => {
            const body2 = Buffer.concat([...data]).toString();
            const networkResponse = {
              headers,
              body: JSON.parse(body2),
              status: statusCode
            };
            if ((statusCode < 200 || statusCode > 299) && networkResponse.body["error"] !== Constants.AUTHORIZATION_PENDING) {
              request.destroy();
              reject(new Error(`HTTP status code ${statusCode}`));
            }
            resolve(networkResponse);
          });
        });
        request.on("error", (chunk) => {
          request.destroy();
          reject(new Error(chunk.toString()));
        });
      });
    };
    var NetworkUtils = class {
      static getNetworkClient() {
        return new HttpClient();
      }
    };
    var DEFAULT_AUTH_OPTIONS = {
      clientId: msalCommon.Constants.EMPTY_STRING,
      authority: msalCommon.Constants.DEFAULT_AUTHORITY,
      clientSecret: msalCommon.Constants.EMPTY_STRING,
      clientAssertion: msalCommon.Constants.EMPTY_STRING,
      clientCertificate: {
        thumbprint: msalCommon.Constants.EMPTY_STRING,
        privateKey: msalCommon.Constants.EMPTY_STRING,
        x5c: msalCommon.Constants.EMPTY_STRING
      },
      knownAuthorities: [],
      cloudDiscoveryMetadata: msalCommon.Constants.EMPTY_STRING,
      authorityMetadata: msalCommon.Constants.EMPTY_STRING,
      clientCapabilities: [],
      protocolMode: msalCommon.ProtocolMode.AAD,
      azureCloudOptions: {
        azureCloudInstance: msalCommon.AzureCloudInstance.None,
        tenant: msalCommon.Constants.EMPTY_STRING
      },
      skipAuthorityMetadataCache: false
    };
    var DEFAULT_CACHE_OPTIONS = {};
    var DEFAULT_LOGGER_OPTIONS = {
      loggerCallback: () => {
      },
      piiLoggingEnabled: false,
      logLevel: msalCommon.LogLevel.Info
    };
    var DEFAULT_SYSTEM_OPTIONS = {
      loggerOptions: DEFAULT_LOGGER_OPTIONS,
      networkClient: /* @__PURE__ */ NetworkUtils.getNetworkClient(),
      proxyUrl: msalCommon.Constants.EMPTY_STRING
    };
    var DEFAULT_TELEMETRY_OPTIONS = {
      application: {
        appName: msalCommon.Constants.EMPTY_STRING,
        appVersion: msalCommon.Constants.EMPTY_STRING
      }
    };
    function buildAppConfiguration({
      auth,
      cache,
      system,
      telemetry
    }) {
      return {
        auth: {
          ...DEFAULT_AUTH_OPTIONS,
          ...auth
        },
        cache: {
          ...DEFAULT_CACHE_OPTIONS,
          ...cache
        },
        system: {
          ...DEFAULT_SYSTEM_OPTIONS,
          ...system
        },
        telemetry: {
          ...DEFAULT_TELEMETRY_OPTIONS,
          ...telemetry
        }
      };
    }
    var GuidGenerator = class {
      generateGuid() {
        return uuid.v4();
      }
      isGuid(guid) {
        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return regexGuid.test(guid);
      }
    };
    var EncodingUtils = class {
      static base64Encode(str, encoding) {
        return Buffer.from(str, encoding).toString("base64");
      }
      static base64EncodeUrl(str, encoding) {
        return EncodingUtils.base64Encode(str, encoding).replace(/=/g, msalCommon.Constants.EMPTY_STRING).replace(/\+/g, "-").replace(/\//g, "_");
      }
      static base64Decode(base64Str) {
        return Buffer.from(base64Str, "base64").toString("utf8");
      }
      static base64DecodeUrl(base64Str) {
        let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");
        while (str.length % 4) {
          str += "=";
        }
        return EncodingUtils.base64Decode(str);
      }
    };
    var HashUtils = class {
      sha256(buffer) {
        return crypto.createHash(Hash.SHA256).update(buffer).digest();
      }
    };
    var PkceGenerator = class {
      constructor() {
        this.hashUtils = new HashUtils();
      }
      async generatePkceCodes() {
        const verifier = this.generateCodeVerifier();
        const challenge = this.generateCodeChallengeFromVerifier(verifier);
        return {
          verifier,
          challenge
        };
      }
      generateCodeVerifier() {
        const charArr = [];
        const maxNumber = 256 - 256 % CharSet.CV_CHARSET.length;
        while (charArr.length <= RANDOM_OCTET_SIZE) {
          const byte = crypto.randomBytes(1)[0];
          if (byte >= maxNumber) {
            continue;
          }
          const index = byte % CharSet.CV_CHARSET.length;
          charArr.push(CharSet.CV_CHARSET[index]);
        }
        const verifier = charArr.join(msalCommon.Constants.EMPTY_STRING);
        return EncodingUtils.base64EncodeUrl(verifier);
      }
      generateCodeChallengeFromVerifier(codeVerifier) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString("base64"), "base64");
      }
    };
    var CryptoProvider = class {
      constructor() {
        this.pkceGenerator = new PkceGenerator();
        this.guidGenerator = new GuidGenerator();
        this.hashUtils = new HashUtils();
      }
      createNewGuid() {
        return this.guidGenerator.generateGuid();
      }
      base64Encode(input) {
        return EncodingUtils.base64Encode(input);
      }
      base64Decode(input) {
        return EncodingUtils.base64Decode(input);
      }
      generatePkceCodes() {
        return this.pkceGenerator.generatePkceCodes();
      }
      getPublicKeyThumbprint() {
        throw new Error("Method not implemented.");
      }
      removeTokenBindingKey() {
        throw new Error("Method not implemented.");
      }
      clearKeystore() {
        throw new Error("Method not implemented.");
      }
      signJwt() {
        throw new Error("Method not implemented.");
      }
      async hashString(plainText) {
        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString("base64"), "base64");
      }
    };
    var Deserializer = class {
      static deserializeJSONBlob(jsonFile) {
        const deserializedCache = msalCommon.StringUtils.isEmpty(jsonFile) ? {} : JSON.parse(jsonFile);
        return deserializedCache;
      }
      static deserializeAccounts(accounts) {
        const accountObjects = {};
        if (accounts) {
          Object.keys(accounts).map(function(key) {
            const serializedAcc = accounts[key];
            const mappedAcc = {
              homeAccountId: serializedAcc.home_account_id,
              environment: serializedAcc.environment,
              realm: serializedAcc.realm,
              localAccountId: serializedAcc.local_account_id,
              username: serializedAcc.username,
              authorityType: serializedAcc.authority_type,
              name: serializedAcc.name,
              clientInfo: serializedAcc.client_info,
              lastModificationTime: serializedAcc.last_modification_time,
              lastModificationApp: serializedAcc.last_modification_app
            };
            const account = new msalCommon.AccountEntity();
            msalCommon.CacheManager.toObject(account, mappedAcc);
            accountObjects[key] = account;
          });
        }
        return accountObjects;
      }
      static deserializeIdTokens(idTokens) {
        const idObjects = {};
        if (idTokens) {
          Object.keys(idTokens).map(function(key) {
            const serializedIdT = idTokens[key];
            const mappedIdT = {
              homeAccountId: serializedIdT.home_account_id,
              environment: serializedIdT.environment,
              credentialType: serializedIdT.credential_type,
              clientId: serializedIdT.client_id,
              secret: serializedIdT.secret,
              realm: serializedIdT.realm
            };
            const idToken = new msalCommon.IdTokenEntity();
            msalCommon.CacheManager.toObject(idToken, mappedIdT);
            idObjects[key] = idToken;
          });
        }
        return idObjects;
      }
      static deserializeAccessTokens(accessTokens) {
        const atObjects = {};
        if (accessTokens) {
          Object.keys(accessTokens).map(function(key) {
            const serializedAT = accessTokens[key];
            const mappedAT = {
              homeAccountId: serializedAT.home_account_id,
              environment: serializedAT.environment,
              credentialType: serializedAT.credential_type,
              clientId: serializedAT.client_id,
              secret: serializedAT.secret,
              realm: serializedAT.realm,
              target: serializedAT.target,
              cachedAt: serializedAT.cached_at,
              expiresOn: serializedAT.expires_on,
              extendedExpiresOn: serializedAT.extended_expires_on,
              refreshOn: serializedAT.refresh_on,
              keyId: serializedAT.key_id,
              tokenType: serializedAT.token_type,
              requestedClaims: serializedAT.requestedClaims,
              requestedClaimsHash: serializedAT.requestedClaimsHash
            };
            const accessToken = new msalCommon.AccessTokenEntity();
            msalCommon.CacheManager.toObject(accessToken, mappedAT);
            atObjects[key] = accessToken;
          });
        }
        return atObjects;
      }
      static deserializeRefreshTokens(refreshTokens) {
        const rtObjects = {};
        if (refreshTokens) {
          Object.keys(refreshTokens).map(function(key) {
            const serializedRT = refreshTokens[key];
            const mappedRT = {
              homeAccountId: serializedRT.home_account_id,
              environment: serializedRT.environment,
              credentialType: serializedRT.credential_type,
              clientId: serializedRT.client_id,
              secret: serializedRT.secret,
              familyId: serializedRT.family_id,
              target: serializedRT.target,
              realm: serializedRT.realm
            };
            const refreshToken = new msalCommon.RefreshTokenEntity();
            msalCommon.CacheManager.toObject(refreshToken, mappedRT);
            rtObjects[key] = refreshToken;
          });
        }
        return rtObjects;
      }
      static deserializeAppMetadata(appMetadata) {
        const appMetadataObjects = {};
        if (appMetadata) {
          Object.keys(appMetadata).map(function(key) {
            const serializedAmdt = appMetadata[key];
            const mappedAmd = {
              clientId: serializedAmdt.client_id,
              environment: serializedAmdt.environment,
              familyId: serializedAmdt.family_id
            };
            const amd = new msalCommon.AppMetadataEntity();
            msalCommon.CacheManager.toObject(amd, mappedAmd);
            appMetadataObjects[key] = amd;
          });
        }
        return appMetadataObjects;
      }
      static deserializeAllCache(jsonCache) {
        return {
          accounts: jsonCache.Account ? this.deserializeAccounts(jsonCache.Account) : {},
          idTokens: jsonCache.IdToken ? this.deserializeIdTokens(jsonCache.IdToken) : {},
          accessTokens: jsonCache.AccessToken ? this.deserializeAccessTokens(jsonCache.AccessToken) : {},
          refreshTokens: jsonCache.RefreshToken ? this.deserializeRefreshTokens(jsonCache.RefreshToken) : {},
          appMetadata: jsonCache.AppMetadata ? this.deserializeAppMetadata(jsonCache.AppMetadata) : {}
        };
      }
    };
    var Serializer = class {
      static serializeJSONBlob(data) {
        return JSON.stringify(data);
      }
      static serializeAccounts(accCache) {
        const accounts = {};
        Object.keys(accCache).map(function(key) {
          const accountEntity = accCache[key];
          accounts[key] = {
            home_account_id: accountEntity.homeAccountId,
            environment: accountEntity.environment,
            realm: accountEntity.realm,
            local_account_id: accountEntity.localAccountId,
            username: accountEntity.username,
            authority_type: accountEntity.authorityType,
            name: accountEntity.name,
            client_info: accountEntity.clientInfo,
            last_modification_time: accountEntity.lastModificationTime,
            last_modification_app: accountEntity.lastModificationApp
          };
        });
        return accounts;
      }
      static serializeIdTokens(idTCache) {
        const idTokens = {};
        Object.keys(idTCache).map(function(key) {
          const idTEntity = idTCache[key];
          idTokens[key] = {
            home_account_id: idTEntity.homeAccountId,
            environment: idTEntity.environment,
            credential_type: idTEntity.credentialType,
            client_id: idTEntity.clientId,
            secret: idTEntity.secret,
            realm: idTEntity.realm
          };
        });
        return idTokens;
      }
      static serializeAccessTokens(atCache) {
        const accessTokens = {};
        Object.keys(atCache).map(function(key) {
          const atEntity = atCache[key];
          accessTokens[key] = {
            home_account_id: atEntity.homeAccountId,
            environment: atEntity.environment,
            credential_type: atEntity.credentialType,
            client_id: atEntity.clientId,
            secret: atEntity.secret,
            realm: atEntity.realm,
            target: atEntity.target,
            cached_at: atEntity.cachedAt,
            expires_on: atEntity.expiresOn,
            extended_expires_on: atEntity.extendedExpiresOn,
            refresh_on: atEntity.refreshOn,
            key_id: atEntity.keyId,
            token_type: atEntity.tokenType,
            requestedClaims: atEntity.requestedClaims,
            requestedClaimsHash: atEntity.requestedClaimsHash
          };
        });
        return accessTokens;
      }
      static serializeRefreshTokens(rtCache) {
        const refreshTokens = {};
        Object.keys(rtCache).map(function(key) {
          const rtEntity = rtCache[key];
          refreshTokens[key] = {
            home_account_id: rtEntity.homeAccountId,
            environment: rtEntity.environment,
            credential_type: rtEntity.credentialType,
            client_id: rtEntity.clientId,
            secret: rtEntity.secret,
            family_id: rtEntity.familyId,
            target: rtEntity.target,
            realm: rtEntity.realm
          };
        });
        return refreshTokens;
      }
      static serializeAppMetadata(amdtCache) {
        const appMetadata = {};
        Object.keys(amdtCache).map(function(key) {
          const amdtEntity = amdtCache[key];
          appMetadata[key] = {
            client_id: amdtEntity.clientId,
            environment: amdtEntity.environment,
            family_id: amdtEntity.familyId
          };
        });
        return appMetadata;
      }
      static serializeAllCache(inMemCache) {
        return {
          Account: this.serializeAccounts(inMemCache.accounts),
          IdToken: this.serializeIdTokens(inMemCache.idTokens),
          AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
          RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
          AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata)
        };
      }
    };
    var NodeStorage = class extends msalCommon.CacheManager {
      constructor(logger2, clientId, cryptoImpl) {
        super(clientId, cryptoImpl);
        this.cache = {};
        this.changeEmitters = [];
        this.logger = logger2;
      }
      registerChangeEmitter(func) {
        this.changeEmitters.push(func);
      }
      emitChange() {
        this.changeEmitters.forEach((func) => func.call(null));
      }
      cacheToInMemoryCache(cache) {
        const inMemoryCache = {
          accounts: {},
          idTokens: {},
          accessTokens: {},
          refreshTokens: {},
          appMetadata: {}
        };
        for (const key in cache) {
          if (cache[key] instanceof msalCommon.AccountEntity) {
            inMemoryCache.accounts[key] = cache[key];
          } else if (cache[key] instanceof msalCommon.IdTokenEntity) {
            inMemoryCache.idTokens[key] = cache[key];
          } else if (cache[key] instanceof msalCommon.AccessTokenEntity) {
            inMemoryCache.accessTokens[key] = cache[key];
          } else if (cache[key] instanceof msalCommon.RefreshTokenEntity) {
            inMemoryCache.refreshTokens[key] = cache[key];
          } else if (cache[key] instanceof msalCommon.AppMetadataEntity) {
            inMemoryCache.appMetadata[key] = cache[key];
          } else {
            continue;
          }
        }
        return inMemoryCache;
      }
      inMemoryCacheToCache(inMemoryCache) {
        let cache = this.getCache();
        cache = {
          ...cache,
          ...inMemoryCache.accounts,
          ...inMemoryCache.idTokens,
          ...inMemoryCache.accessTokens,
          ...inMemoryCache.refreshTokens,
          ...inMemoryCache.appMetadata
        };
        return cache;
      }
      getInMemoryCache() {
        this.logger.trace("Getting in-memory cache");
        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
        return inMemoryCache;
      }
      setInMemoryCache(inMemoryCache) {
        this.logger.trace("Setting in-memory cache");
        const cache = this.inMemoryCacheToCache(inMemoryCache);
        this.setCache(cache);
        this.emitChange();
      }
      getCache() {
        this.logger.trace("Getting cache key-value store");
        return this.cache;
      }
      setCache(cache) {
        this.logger.trace("Setting cache key value store");
        this.cache = cache;
        this.emitChange();
      }
      getItem(key) {
        this.logger.tracePii(`Item key: ${key}`);
        const cache = this.getCache();
        return cache[key];
      }
      setItem(key, value) {
        this.logger.tracePii(`Item key: ${key}`);
        const cache = this.getCache();
        cache[key] = value;
        this.setCache(cache);
      }
      getAccount(accountKey) {
        const account = this.getItem(accountKey);
        if (msalCommon.AccountEntity.isAccountEntity(account)) {
          return account;
        }
        return null;
      }
      setAccount(account) {
        const accountKey = account.generateAccountKey();
        this.setItem(accountKey, account);
      }
      getIdTokenCredential(idTokenKey) {
        const idToken = this.getItem(idTokenKey);
        if (msalCommon.IdTokenEntity.isIdTokenEntity(idToken)) {
          return idToken;
        }
        return null;
      }
      setIdTokenCredential(idToken) {
        const idTokenKey = idToken.generateCredentialKey();
        this.setItem(idTokenKey, idToken);
      }
      getAccessTokenCredential(accessTokenKey) {
        const accessToken = this.getItem(accessTokenKey);
        if (msalCommon.AccessTokenEntity.isAccessTokenEntity(accessToken)) {
          return accessToken;
        }
        return null;
      }
      setAccessTokenCredential(accessToken) {
        const accessTokenKey = accessToken.generateCredentialKey();
        this.setItem(accessTokenKey, accessToken);
      }
      getRefreshTokenCredential(refreshTokenKey) {
        const refreshToken = this.getItem(refreshTokenKey);
        if (msalCommon.RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {
          return refreshToken;
        }
        return null;
      }
      setRefreshTokenCredential(refreshToken) {
        const refreshTokenKey = refreshToken.generateCredentialKey();
        this.setItem(refreshTokenKey, refreshToken);
      }
      getAppMetadata(appMetadataKey) {
        const appMetadata = this.getItem(appMetadataKey);
        if (msalCommon.AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {
          return appMetadata;
        }
        return null;
      }
      setAppMetadata(appMetadata) {
        const appMetadataKey = appMetadata.generateAppMetadataKey();
        this.setItem(appMetadataKey, appMetadata);
      }
      getServerTelemetry(serverTelemetrykey) {
        const serverTelemetryEntity = this.getItem(serverTelemetrykey);
        if (serverTelemetryEntity && msalCommon.ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
          return serverTelemetryEntity;
        }
        return null;
      }
      setServerTelemetry(serverTelemetryKey, serverTelemetry) {
        this.setItem(serverTelemetryKey, serverTelemetry);
      }
      getAuthorityMetadata(key) {
        const authorityMetadataEntity = this.getItem(key);
        if (authorityMetadataEntity && msalCommon.AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {
          return authorityMetadataEntity;
        }
        return null;
      }
      getAuthorityMetadataKeys() {
        return this.getKeys().filter((key) => {
          return this.isAuthorityMetadata(key);
        });
      }
      setAuthorityMetadata(key, metadata) {
        this.setItem(key, metadata);
      }
      getThrottlingCache(throttlingCacheKey) {
        const throttlingCache = this.getItem(throttlingCacheKey);
        if (throttlingCache && msalCommon.ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
          return throttlingCache;
        }
        return null;
      }
      setThrottlingCache(throttlingCacheKey, throttlingCache) {
        this.setItem(throttlingCacheKey, throttlingCache);
      }
      removeItem(key) {
        this.logger.tracePii(`Item key: ${key}`);
        let result = false;
        const cache = this.getCache();
        if (!!cache[key]) {
          delete cache[key];
          result = true;
        }
        if (result) {
          this.setCache(cache);
          this.emitChange();
        }
        return result;
      }
      containsKey(key) {
        return this.getKeys().includes(key);
      }
      getKeys() {
        this.logger.trace("Retrieving all cache keys");
        const cache = this.getCache();
        return [...Object.keys(cache)];
      }
      async clear() {
        this.logger.trace("Clearing cache entries created by MSAL");
        const cacheKeys = this.getKeys();
        cacheKeys.forEach((key) => {
          this.removeItem(key);
        });
        this.emitChange();
      }
      static generateInMemoryCache(cache) {
        return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
      }
      static generateJsonCache(inMemoryCache) {
        return Serializer.serializeAllCache(inMemoryCache);
      }
      updateCredentialCacheKey(currentCacheKey, credential) {
        const updatedCacheKey = credential.generateCredentialKey();
        if (currentCacheKey !== updatedCacheKey) {
          const cacheItem = this.getItem(currentCacheKey);
          if (cacheItem) {
            this.removeItem(currentCacheKey);
            this.setItem(updatedCacheKey, cacheItem);
            this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
            return updatedCacheKey;
          } else {
            this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
          }
        }
        return currentCacheKey;
      }
    };
    var defaultSerializedCache = {
      Account: {},
      IdToken: {},
      AccessToken: {},
      RefreshToken: {},
      AppMetadata: {}
    };
    var TokenCache = class {
      constructor(storage, logger2, cachePlugin) {
        this.cacheHasChanged = false;
        this.storage = storage;
        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
        if (cachePlugin) {
          this.persistence = cachePlugin;
        }
        this.logger = logger2;
      }
      hasChanged() {
        return this.cacheHasChanged;
      }
      serialize() {
        this.logger.trace("Serializing in-memory cache");
        let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
        if (!msalCommon.StringUtils.isEmpty(this.cacheSnapshot)) {
          this.logger.trace("Reading cache snapshot from disk");
          finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
        } else {
          this.logger.trace("No cache snapshot to merge");
        }
        this.cacheHasChanged = false;
        return JSON.stringify(finalState);
      }
      deserialize(cache) {
        this.logger.trace("Deserializing JSON to in-memory cache");
        this.cacheSnapshot = cache;
        if (!msalCommon.StringUtils.isEmpty(this.cacheSnapshot)) {
          this.logger.trace("Reading cache snapshot from disk");
          const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
          this.storage.setInMemoryCache(deserializedCache);
        } else {
          this.logger.trace("No cache snapshot to deserialize");
        }
      }
      getKVStore() {
        return this.storage.getCache();
      }
      async getAllAccounts() {
        this.logger.trace("getAllAccounts called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new msalCommon.TokenCacheContext(this, false);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          return this.storage.getAllAccounts();
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      async getAccountByHomeId(homeAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (!msalCommon.StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null;
        } else {
          return null;
        }
      }
      async getAccountByLocalId(localAccountId) {
        const allAccounts = await this.getAllAccounts();
        if (!msalCommon.StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {
          return allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null;
        } else {
          return null;
        }
      }
      async removeAccount(account) {
        this.logger.trace("removeAccount called");
        let cacheContext;
        try {
          if (this.persistence) {
            cacheContext = new msalCommon.TokenCacheContext(this, true);
            await this.persistence.beforeCacheAccess(cacheContext);
          }
          await this.storage.removeAccount(msalCommon.AccountEntity.generateAccountCacheKey(account));
        } finally {
          if (this.persistence && cacheContext) {
            await this.persistence.afterCacheAccess(cacheContext);
          }
        }
      }
      handleChangeEvent() {
        this.cacheHasChanged = true;
      }
      mergeState(oldState, currentState) {
        this.logger.trace("Merging in-memory cache with cache snapshot");
        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
        return this.mergeUpdates(stateAfterRemoval, currentState);
      }
      mergeUpdates(oldState, newState) {
        Object.keys(newState).forEach((newKey) => {
          const newValue = newState[newKey];
          if (!oldState.hasOwnProperty(newKey)) {
            if (newValue !== null) {
              oldState[newKey] = newValue;
            }
          } else {
            const newValueNotNull = newValue !== null;
            const newValueIsObject = typeof newValue === "object";
            const newValueIsNotArray = !Array.isArray(newValue);
            const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" && oldState[newKey] !== null;
            if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {
              this.mergeUpdates(oldState[newKey], newValue);
            } else {
              oldState[newKey] = newValue;
            }
          }
        });
        return oldState;
      }
      mergeRemovals(oldState, newState) {
        this.logger.trace("Remove updated entries in cache");
        const accounts = oldState.Account ? this.mergeRemovalsDict(oldState.Account, newState.Account) : oldState.Account;
        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;
        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;
        const idTokens = oldState.IdToken ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken) : oldState.IdToken;
        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;
        return {
          ...oldState,
          Account: accounts,
          AccessToken: accessTokens,
          RefreshToken: refreshTokens,
          IdToken: idTokens,
          AppMetadata: appMetadata
        };
      }
      mergeRemovalsDict(oldState, newState) {
        const finalState = {
          ...oldState
        };
        Object.keys(oldState).forEach((oldKey) => {
          if (!newState || !newState.hasOwnProperty(oldKey)) {
            delete finalState[oldKey];
          }
        });
        return finalState;
      }
      overlayDefaults(passedInCache) {
        this.logger.trace("Overlaying input cache with the default cache");
        return {
          Account: {
            ...defaultSerializedCache.Account,
            ...passedInCache.Account
          },
          IdToken: {
            ...defaultSerializedCache.IdToken,
            ...passedInCache.IdToken
          },
          AccessToken: {
            ...defaultSerializedCache.AccessToken,
            ...passedInCache.AccessToken
          },
          RefreshToken: {
            ...defaultSerializedCache.RefreshToken,
            ...passedInCache.RefreshToken
          },
          AppMetadata: {
            ...defaultSerializedCache.AppMetadata,
            ...passedInCache.AppMetadata
          }
        };
      }
    };
    var name = "@azure/msal-node";
    var version = "1.13.0";
    var ClientApplication = class {
      constructor(configuration) {
        this.config = buildAppConfiguration(configuration);
        this.cryptoProvider = new CryptoProvider();
        this.logger = new msalCommon.Logger(this.config.system.loggerOptions, name, version);
        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);
        this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
      }
      async getAuthCodeUrl(request) {
        this.logger.info("getAuthCodeUrl called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          responseMode: request.responseMode || msalCommon.ResponseMode.QUERY,
          authenticationScheme: msalCommon.AuthenticationScheme.BEARER
        };
        const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request.azureCloudOptions);
        const authorizationCodeClient = new msalCommon.AuthorizationCodeClient(authClientConfig);
        this.logger.verbose("Auth code client created", validRequest.correlationId);
        return authorizationCodeClient.getAuthCodeUrl(validRequest);
      }
      async acquireTokenByCode(request, authCodePayLoad) {
        this.logger.info("acquireTokenByCode called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          authenticationScheme: msalCommon.AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
        try {
          const authClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
          const authorizationCodeClient = new msalCommon.AuthorizationCodeClient(authClientConfig);
          this.logger.verbose("Auth code client created", validRequest.correlationId);
          return authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
        } catch (e) {
          if (e instanceof msalCommon.AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      async acquireTokenByRefreshToken(request) {
        this.logger.info("acquireTokenByRefreshToken called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          authenticationScheme: msalCommon.AuthenticationScheme.BEARER
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
        try {
          const refreshTokenClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
          const refreshTokenClient = new msalCommon.RefreshTokenClient(refreshTokenClientConfig);
          this.logger.verbose("Refresh token client created", validRequest.correlationId);
          return refreshTokenClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof msalCommon.AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      async acquireTokenSilent(request) {
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          forceRefresh: request.forceRefresh || false
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
        try {
          const silentFlowClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
          const silentFlowClient = new msalCommon.SilentFlowClient(silentFlowClientConfig);
          this.logger.verbose("Silent flow client created", validRequest.correlationId);
          return silentFlowClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof msalCommon.AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      async acquireTokenByUsernamePassword(request) {
        this.logger.info("acquireTokenByUsernamePassword called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request)
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
        try {
          const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
          const usernamePasswordClient = new msalCommon.UsernamePasswordClient(usernamePasswordClientConfig);
          this.logger.verbose("Username password client created", validRequest.correlationId);
          return usernamePasswordClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof msalCommon.AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      getTokenCache() {
        this.logger.info("getTokenCache called");
        return this.tokenCache;
      }
      getLogger() {
        return this.logger;
      }
      setLogger(logger2) {
        this.logger = logger2;
      }
      async buildOauthClientConfiguration(authority, requestCorrelationId, serverTelemetryManager, azureRegionConfiguration, azureCloudOptions) {
        this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
        const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions;
        this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);
        const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);
        serverTelemetryManager == null ? void 0 : serverTelemetryManager.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
        const clientConfiguration = {
          authOptions: {
            clientId: this.config.auth.clientId,
            authority: discoveredAuthority,
            clientCapabilities: this.config.auth.clientCapabilities
          },
          systemOptions: {
            proxyUrl: this.config.system.proxyUrl
          },
          loggerOptions: {
            logLevel: this.config.system.loggerOptions.logLevel,
            loggerCallback: this.config.system.loggerOptions.loggerCallback,
            piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
            correlationId: requestCorrelationId
          },
          cryptoInterface: this.cryptoProvider,
          networkInterface: this.config.system.networkClient,
          storageInterface: this.storage,
          serverTelemetryManager,
          clientCredentials: {
            clientSecret: this.clientSecret,
            clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : void 0
          },
          libraryInfo: {
            sku: Constants.MSAL_SKU,
            version,
            cpu: process.arch || msalCommon.Constants.EMPTY_STRING,
            os: process.platform || msalCommon.Constants.EMPTY_STRING
          },
          telemetry: this.config.telemetry,
          persistencePlugin: this.config.cache.cachePlugin,
          serializableCache: this.tokenCache
        };
        return clientConfiguration;
      }
      getClientAssertion(authority) {
        return {
          assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
          assertionType: Constants.JWT_BEARER_ASSERTION_TYPE
        };
      }
      async initializeBaseRequest(authRequest) {
        this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
        if (authRequest.authenticationScheme && authRequest.authenticationScheme === msalCommon.AuthenticationScheme.POP) {
          this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
        }
        authRequest.authenticationScheme = msalCommon.AuthenticationScheme.BEARER;
        if (authRequest.claims && !msalCommon.StringUtils.isEmpty(authRequest.claims)) {
          authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);
        }
        return {
          ...authRequest,
          scopes: [...authRequest && authRequest.scopes || [], ...msalCommon.OIDC_DEFAULT_SCOPES],
          correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),
          authority: authRequest.authority || this.config.auth.authority
        };
      }
      initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
        const telemetryPayload = {
          clientId: this.config.auth.clientId,
          correlationId,
          apiId,
          forceRefresh: forceRefresh || false
        };
        return new msalCommon.ServerTelemetryManager(telemetryPayload, this.storage);
      }
      async createAuthority(authorityString, azureRegionConfiguration, requestCorrelationId, azureCloudOptions) {
        this.logger.verbose("createAuthority called", requestCorrelationId);
        const authorityUrl = msalCommon.Authority.generateAuthority(authorityString, azureCloudOptions);
        const authorityOptions = {
          protocolMode: this.config.auth.protocolMode,
          knownAuthorities: this.config.auth.knownAuthorities,
          cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
          authorityMetadata: this.config.auth.authorityMetadata,
          azureRegionConfiguration,
          skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
        };
        return await msalCommon.AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.config.system.proxyUrl);
      }
      clearCache() {
        this.storage.clear();
      }
    };
    var NodeAuthErrorMessage = {
      invalidLoopbackAddressType: {
        code: "invalid_loopback_server_address_type",
        desc: "Loopback server address is not type string. This is unexpected."
      },
      unableToLoadRedirectUri: {
        code: "unable_to_load_redirectUrl",
        desc: "Loopback server callback was invoked without a url. This is unexpected."
      },
      noAuthCodeInResponse: {
        code: "no_auth_code_in_response",
        desc: "No auth code found in the server response. Please check your network trace to determine what happened."
      },
      noLoopbackServerExists: {
        code: "no_loopback_server_exists",
        desc: "No loopback server exists yet."
      },
      loopbackServerAlreadyExists: {
        code: "loopback_server_already_exists",
        desc: "Loopback server already exists. Cannot create another."
      },
      loopbackServerTimeout: {
        code: "loopback_server_timeout",
        desc: "Timed out waiting for auth code listener to be registered."
      }
    };
    var NodeAuthError = class extends msalCommon.AuthError {
      constructor(errorCode, errorMessage) {
        super(errorCode, errorMessage);
        this.name = "NodeAuthError";
      }
      static createInvalidLoopbackAddressTypeError() {
        return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
      }
      static createUnableToLoadRedirectUrlError() {
        return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
      }
      static createNoAuthCodeInResponseError() {
        return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
      }
      static createNoLoopbackServerExistsError() {
        return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
      }
      static createLoopbackServerAlreadyExistsError() {
        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
      }
      static createLoopbackServerTimeoutError() {
        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
      }
    };
    var LoopbackClient = class {
      async listenForAuthCode(successTemplate, errorTemplate) {
        if (!!this.server) {
          throw NodeAuthError.createLoopbackServerAlreadyExistsError();
        }
        const authCodeListener = new Promise((resolve, reject) => {
          this.server = http.createServer(async (req, res) => {
            const url = req.url;
            if (!url) {
              res.end(errorTemplate || "Error occurred loading redirectUrl");
              reject(NodeAuthError.createUnableToLoadRedirectUrlError());
              return;
            } else if (url === msalCommon.Constants.FORWARD_SLASH) {
              res.end(successTemplate || "Auth code was successfully acquired. You can close this window now.");
              return;
            }
            const authCodeResponse = msalCommon.UrlString.getDeserializedQueryString(url);
            if (authCodeResponse.code) {
              const redirectUri = await this.getRedirectUri();
              res.writeHead(HttpStatus.REDIRECT, {
                location: redirectUri
              });
              res.end();
            }
            resolve(authCodeResponse);
          });
          this.server.listen(0);
        });
        await new Promise((resolve) => {
          let ticks = 0;
          const id = setInterval(() => {
            if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS < ticks) {
              throw NodeAuthError.createLoopbackServerTimeoutError();
            }
            if (this.server.listening) {
              clearInterval(id);
              resolve();
            }
            ticks++;
          }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
        });
        return authCodeListener;
      }
      getRedirectUri() {
        if (!this.server) {
          throw NodeAuthError.createNoLoopbackServerExistsError();
        }
        const address = this.server.address();
        if (!address || typeof address === "string" || !address.port) {
          this.closeServer();
          throw NodeAuthError.createInvalidLoopbackAddressTypeError();
        }
        const port = address && address.port;
        return `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}:${port}`;
      }
      closeServer() {
        if (!!this.server) {
          this.server.close();
        }
      }
    };
    var PublicClientApplication = class extends ClientApplication {
      constructor(configuration) {
        super(configuration);
      }
      async acquireTokenByDeviceCode(request) {
        this.logger.info("acquireTokenByDeviceCode called", request.correlationId);
        const validRequest = Object.assign(request, await this.initializeBaseRequest(request));
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);
        try {
          const deviceCodeConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, void 0, request.azureCloudOptions);
          const deviceCodeClient = new msalCommon.DeviceCodeClient(deviceCodeConfig);
          this.logger.verbose("Device code client created", validRequest.correlationId);
          return deviceCodeClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof msalCommon.AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      async acquireTokenInteractive(request) {
        const {
          verifier,
          challenge
        } = await this.cryptoProvider.generatePkceCodes();
        const {
          openBrowser,
          successTemplate,
          errorTemplate,
          ...remainingProperties
        } = request;
        const loopbackClient = new LoopbackClient();
        const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate);
        const redirectUri = loopbackClient.getRedirectUri();
        const validRequest = {
          ...remainingProperties,
          scopes: request.scopes || [],
          redirectUri,
          responseMode: msalCommon.ResponseMode.QUERY,
          codeChallenge: challenge,
          codeChallengeMethod: msalCommon.CodeChallengeMethodValues.S256
        };
        const authCodeUrl = await this.getAuthCodeUrl(validRequest);
        await openBrowser(authCodeUrl);
        const authCodeResponse = await authCodeListener.finally(() => {
          loopbackClient.closeServer();
        });
        if (authCodeResponse.error) {
          throw new msalCommon.ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
        } else if (!authCodeResponse.code) {
          throw NodeAuthError.createNoAuthCodeInResponseError();
        }
        const clientInfo = authCodeResponse.client_info;
        const tokenRequest = {
          code: authCodeResponse.code,
          scopes: msalCommon.OIDC_DEFAULT_SCOPES,
          redirectUri: validRequest.redirectUri,
          codeVerifier: verifier,
          clientInfo: clientInfo || msalCommon.Constants.EMPTY_STRING
        };
        return this.acquireTokenByCode(tokenRequest);
      }
    };
    var ClientAssertion = class {
      static fromAssertion(assertion) {
        const clientAssertion = new ClientAssertion();
        clientAssertion.jwt = assertion;
        return clientAssertion;
      }
      static fromCertificate(thumbprint, privateKey, publicCertificate) {
        const clientAssertion = new ClientAssertion();
        clientAssertion.privateKey = privateKey;
        clientAssertion.thumbprint = thumbprint;
        if (publicCertificate) {
          clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);
        }
        return clientAssertion;
      }
      getJwt(cryptoProvider, issuer, jwtAudience) {
        if (this.privateKey && this.thumbprint) {
          if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {
            return this.jwt;
          }
          return this.createJwt(cryptoProvider, issuer, jwtAudience);
        }
        if (this.jwt) {
          return this.jwt;
        }
        throw msalCommon.ClientAuthError.createInvalidAssertionError();
      }
      createJwt(cryptoProvider, issuer, jwtAudience) {
        this.issuer = issuer;
        this.jwtAudience = jwtAudience;
        const issuedAt = msalCommon.TimeUtils.nowSeconds();
        this.expirationTime = issuedAt + 600;
        const header = {
          alg: JwtConstants.RSA_256,
          x5t: EncodingUtils.base64EncodeUrl(this.thumbprint, "hex")
        };
        if (this.publicCertificate) {
          Object.assign(header, {
            x5c: this.publicCertificate
          });
        }
        const payload = {
          [JwtConstants.AUDIENCE]: this.jwtAudience,
          [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
          [JwtConstants.ISSUER]: this.issuer,
          [JwtConstants.SUBJECT]: this.issuer,
          [JwtConstants.NOT_BEFORE]: issuedAt,
          [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()
        };
        this.jwt = jsonwebtoken.sign(payload, this.privateKey, {
          header
        });
        return this.jwt;
      }
      isExpired() {
        return this.expirationTime < msalCommon.TimeUtils.nowSeconds();
      }
      static parseCertificate(publicCertificate) {
        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
        const certs = [];
        let matches;
        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
          certs.push(matches[1].replace(/\r*\n/g, msalCommon.Constants.EMPTY_STRING));
        }
        return certs;
      }
    };
    var ConfidentialClientApplication = class extends ClientApplication {
      constructor(configuration) {
        super(configuration);
        this.setClientCredential(this.config);
        this.appTokenProvider = void 0;
      }
      SetAppTokenProvider(provider) {
        this.appTokenProvider = provider;
      }
      async acquireTokenByClientCredential(request) {
        this.logger.info("acquireTokenByClientCredential called", request.correlationId);
        let clientAssertion;
        if (request.clientAssertion) {
          clientAssertion = {
            assertion: request.clientAssertion,
            assertionType: Constants.JWT_BEARER_ASSERTION_TYPE
          };
        }
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request),
          clientAssertion
        };
        const azureRegionConfiguration = {
          azureRegion: validRequest.azureRegion,
          environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]
        };
        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);
        try {
          const clientCredentialConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, serverTelemetryManager, azureRegionConfiguration, request.azureCloudOptions);
          const clientCredentialClient = new msalCommon.ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);
          this.logger.verbose("Client credential client created", validRequest.correlationId);
          return clientCredentialClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof msalCommon.AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          serverTelemetryManager.cacheFailedRequest(e);
          throw e;
        }
      }
      async acquireTokenOnBehalfOf(request) {
        this.logger.info("acquireTokenOnBehalfOf called", request.correlationId);
        const validRequest = {
          ...request,
          ...await this.initializeBaseRequest(request)
        };
        try {
          const onBehalfOfConfig = await this.buildOauthClientConfiguration(validRequest.authority, validRequest.correlationId, void 0, void 0, request.azureCloudOptions);
          const oboClient = new msalCommon.OnBehalfOfClient(onBehalfOfConfig);
          this.logger.verbose("On behalf of client created", validRequest.correlationId);
          return oboClient.acquireToken(validRequest);
        } catch (e) {
          if (e instanceof msalCommon.AuthError) {
            e.setCorrelationId(validRequest.correlationId);
          }
          throw e;
        }
      }
      setClientCredential(configuration) {
        const clientSecretNotEmpty = !msalCommon.StringUtils.isEmpty(configuration.auth.clientSecret);
        const clientAssertionNotEmpty = !msalCommon.StringUtils.isEmpty(configuration.auth.clientAssertion);
        const certificate = configuration.auth.clientCertificate || {
          thumbprint: msalCommon.Constants.EMPTY_STRING,
          privateKey: msalCommon.Constants.EMPTY_STRING
        };
        const certificateNotEmpty = !msalCommon.StringUtils.isEmpty(certificate.thumbprint) || !msalCommon.StringUtils.isEmpty(certificate.privateKey);
        if (this.appTokenProvider) {
          return;
        }
        if (clientSecretNotEmpty && clientAssertionNotEmpty || clientAssertionNotEmpty && certificateNotEmpty || clientSecretNotEmpty && certificateNotEmpty) {
          throw msalCommon.ClientAuthError.createInvalidCredentialError();
        }
        if (configuration.auth.clientSecret) {
          this.clientSecret = configuration.auth.clientSecret;
          return;
        }
        if (configuration.auth.clientAssertion) {
          this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);
          return;
        }
        if (!certificateNotEmpty) {
          throw msalCommon.ClientAuthError.createInvalidCredentialError();
        } else {
          var _configuration$auth$c;
          this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, (_configuration$auth$c = configuration.auth.clientCertificate) == null ? void 0 : _configuration$auth$c.x5c);
        }
      }
    };
    var DistributedCachePlugin = class {
      constructor(client, partitionManager) {
        this.client = client;
        this.partitionManager = partitionManager;
      }
      async beforeCacheAccess(cacheContext) {
        const partitionKey = await this.partitionManager.getKey();
        const cacheData = await this.client.get(partitionKey);
        cacheContext.tokenCache.deserialize(cacheData);
      }
      async afterCacheAccess(cacheContext) {
        if (cacheContext.cacheHasChanged) {
          const kvStore = cacheContext.tokenCache.getKVStore();
          const accountEntities = Object.values(kvStore).filter((value) => msalCommon.AccountEntity.isAccountEntity(value));
          if (accountEntities.length > 0) {
            const accountEntity = accountEntities[0];
            const partitionKey = await this.partitionManager.extractKey(accountEntity);
            await this.client.set(partitionKey, cacheContext.tokenCache.serialize());
          }
        }
      }
    };
    Object.defineProperty(exports2, "AuthError", {
      enumerable: true,
      get: function() {
        return msalCommon.AuthError;
      }
    });
    Object.defineProperty(exports2, "AuthErrorMessage", {
      enumerable: true,
      get: function() {
        return msalCommon.AuthErrorMessage;
      }
    });
    Object.defineProperty(exports2, "AzureCloudInstance", {
      enumerable: true,
      get: function() {
        return msalCommon.AzureCloudInstance;
      }
    });
    Object.defineProperty(exports2, "ClientAuthError", {
      enumerable: true,
      get: function() {
        return msalCommon.ClientAuthError;
      }
    });
    Object.defineProperty(exports2, "ClientAuthErrorMessage", {
      enumerable: true,
      get: function() {
        return msalCommon.ClientAuthErrorMessage;
      }
    });
    Object.defineProperty(exports2, "ClientConfigurationError", {
      enumerable: true,
      get: function() {
        return msalCommon.ClientConfigurationError;
      }
    });
    Object.defineProperty(exports2, "ClientConfigurationErrorMessage", {
      enumerable: true,
      get: function() {
        return msalCommon.ClientConfigurationErrorMessage;
      }
    });
    Object.defineProperty(exports2, "InteractionRequiredAuthError", {
      enumerable: true,
      get: function() {
        return msalCommon.InteractionRequiredAuthError;
      }
    });
    Object.defineProperty(exports2, "InteractionRequiredAuthErrorMessage", {
      enumerable: true,
      get: function() {
        return msalCommon.InteractionRequiredAuthErrorMessage;
      }
    });
    Object.defineProperty(exports2, "LogLevel", {
      enumerable: true,
      get: function() {
        return msalCommon.LogLevel;
      }
    });
    Object.defineProperty(exports2, "Logger", {
      enumerable: true,
      get: function() {
        return msalCommon.Logger;
      }
    });
    Object.defineProperty(exports2, "PromptValue", {
      enumerable: true,
      get: function() {
        return msalCommon.PromptValue;
      }
    });
    Object.defineProperty(exports2, "ProtocolMode", {
      enumerable: true,
      get: function() {
        return msalCommon.ProtocolMode;
      }
    });
    Object.defineProperty(exports2, "ResponseMode", {
      enumerable: true,
      get: function() {
        return msalCommon.ResponseMode;
      }
    });
    Object.defineProperty(exports2, "ServerError", {
      enumerable: true,
      get: function() {
        return msalCommon.ServerError;
      }
    });
    Object.defineProperty(exports2, "TokenCacheContext", {
      enumerable: true,
      get: function() {
        return msalCommon.TokenCacheContext;
      }
    });
    exports2.ClientApplication = ClientApplication;
    exports2.ClientAssertion = ClientAssertion;
    exports2.ConfidentialClientApplication = ConfidentialClientApplication;
    exports2.CryptoProvider = CryptoProvider;
    exports2.DistributedCachePlugin = DistributedCachePlugin;
    exports2.NodeStorage = NodeStorage;
    exports2.PublicClientApplication = PublicClientApplication;
    exports2.TokenCache = TokenCache;
    exports2.buildAppConfiguration = buildAppConfiguration;
    exports2.version = version;
  }
});

// ../node_modules/@azure/msal-node/dist/index.js
var require_dist5 = __commonJS({
  "../node_modules/@azure/msal-node/dist/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_msal_node_cjs_production_min();
    } else {
      module2.exports = require_msal_node_cjs_development();
    }
  }
});

// ../node_modules/prismarine-auth/src/TokenManagers/MsaTokenManager.js
var require_MsaTokenManager = __commonJS({
  "../node_modules/prismarine-auth/src/TokenManagers/MsaTokenManager.js"(exports2, module2) {
    var msal = require_dist5();
    var debug = require_src()("prismarine-auth");
    var MsaTokenManager = class {
      constructor(msalConfig, scopes, cache) {
        this.msaClientId = msalConfig.auth.clientId;
        this.scopes = scopes;
        this.cache = cache;
        const beforeCacheAccess = async (cacheContext) => {
          cacheContext.tokenCache.deserialize(JSON.stringify(await this.cache.getCached()));
        };
        const afterCacheAccess = async (cacheContext) => {
          if (cacheContext.cacheHasChanged) {
            await this.cache.setCachedPartial(JSON.parse(cacheContext.tokenCache.serialize()));
          }
        };
        const cachePlugin = {
          beforeCacheAccess,
          afterCacheAccess
        };
        msalConfig.cache = {
          cachePlugin
        };
        this.msalApp = new msal.PublicClientApplication(msalConfig);
        this.msalConfig = msalConfig;
      }
      getUsers() {
        const accounts = this.msaCache.Account;
        const users = [];
        if (!accounts)
          return users;
        for (const account of Object.values(accounts)) {
          users.push(account);
        }
        return users;
      }
      async getAccessToken() {
        const { AccessToken: tokens } = await this.cache.getCached();
        if (!tokens)
          return;
        const account = Object.values(tokens).filter((t) => t.client_id === this.msaClientId)[0];
        if (!account) {
          debug("[msa] No valid access token found", tokens);
          return;
        }
        const until = new Date(account.expires_on * 1e3) - Date.now();
        const valid = until > 1e3;
        return { valid, until, token: account.secret };
      }
      async getRefreshToken() {
        const { RefreshToken: tokens } = await this.cache.getCached();
        if (!tokens)
          return;
        const account = Object.values(tokens).filter((t) => t.client_id === this.msaClientId)[0];
        if (!account) {
          debug("[msa] No valid refresh token found", tokens);
          return;
        }
        return { token: account.secret };
      }
      async refreshTokens() {
        const rtoken = await this.getRefreshToken();
        if (!rtoken) {
          throw new Error("Cannot refresh without refresh token");
        }
        const refreshTokenRequest = {
          refreshToken: rtoken.token,
          scopes: this.scopes
        };
        return new Promise((resolve, reject) => {
          this.msalApp.acquireTokenByRefreshToken(refreshTokenRequest).then((response) => {
            debug("[msa] refreshed token", JSON.stringify(response));
            resolve(response);
          }).catch((error) => {
            debug("[msa] failed to refresh", JSON.stringify(error));
            reject(error);
          });
        });
      }
      async verifyTokens() {
        if (this.forceRefresh)
          try {
            await this.refreshTokens();
          } catch {
          }
        const at = await this.getAccessToken();
        const rt = await this.getRefreshToken();
        if (!at || !rt) {
          return false;
        }
        debug("[msa] have at, rt", at, rt);
        if (at.valid && rt) {
          return true;
        } else {
          try {
            await this.refreshTokens();
            return true;
          } catch (e) {
            console.warn("Error refreshing token", e);
            return false;
          }
        }
      }
      async authDeviceCode(dataCallback) {
        const deviceCodeRequest = {
          deviceCodeCallback: (resp) => {
            debug("[msa] device_code response: ", resp);
            dataCallback(resp);
          },
          scopes: this.scopes
        };
        return new Promise((resolve, reject) => {
          this.msalApp.acquireTokenByDeviceCode(deviceCodeRequest).then((response) => {
            debug("[msa] device_code resp", JSON.stringify(response));
            this.cache.getCached().then((cached) => {
              if (!cached.Account) {
                cached.Account = { "": response.account };
                this.cache.setCachedPartial(cached);
              }
              resolve(response);
            });
          }).catch((error) => {
            console.warn("[msa] Error getting device code");
            console.debug(JSON.stringify(error));
            reject(error);
          });
        });
      }
    };
    module2.exports = MsaTokenManager;
  }
});

// ../node_modules/prismarine-auth/src/TokenManagers/MinecraftBedrockTokenManager.js
var require_MinecraftBedrockTokenManager = __commonJS({
  "../node_modules/prismarine-auth/src/TokenManagers/MinecraftBedrockTokenManager.js"(exports2, module2) {
    var debug = require_src()("prismarine-auth");
    var fetch = require_lib2();
    var { Endpoints } = require_Constants();
    var { checkStatus } = require_Util();
    var BedrockTokenManager = class {
      constructor(cache) {
        this.cache = cache;
      }
      async getCachedAccessToken() {
        const { mca: token } = await this.cache.getCached();
        debug("[mc] token cache", token);
        if (!token)
          return;
        debug("Auth token", token);
        const jwt = token.chain[0];
        const [header, payload, signature] = jwt.split(".").map((k) => Buffer.from(k, "base64"));
        const body = JSON.parse(String(payload));
        const expires = new Date(body.exp * 1e3);
        const remainingMs = expires - Date.now();
        const valid = remainingMs > 1e3;
        return { valid, until: expires, chain: token.chain };
      }
      async setCachedAccessToken(data) {
        await this.cache.setCachedPartial({
          mca: {
            ...data,
            obtainedOn: Date.now()
          }
        });
      }
      async verifyTokens() {
        const at = await this.getCachedAccessToken();
        if (!at || this.forceRefresh) {
          return false;
        }
        debug("[mc] have user access token", at);
        if (at.valid) {
          return true;
        }
        return false;
      }
      async getAccessToken(clientPublicKey, xsts) {
        debug("[mc] authing to minecraft", clientPublicKey, xsts);
        const headers = {
          "Content-Type": "application/json",
          "User-Agent": "MCPE/UWP",
          Authorization: `XBL3.0 x=${xsts.userHash};${xsts.XSTSToken}`
        };
        const MineServicesResponse = await fetch(Endpoints.BedrockAuth, {
          method: "post",
          headers,
          body: JSON.stringify({ identityPublicKey: clientPublicKey })
        }).then(checkStatus);
        debug("[mc] mc auth response", MineServicesResponse);
        await this.setCachedAccessToken(MineServicesResponse);
        return MineServicesResponse;
      }
    };
    module2.exports = BedrockTokenManager;
  }
});

// ../node_modules/prismarine-auth/src/MicrosoftAuthFlow.js
var require_MicrosoftAuthFlow = __commonJS({
  "../node_modules/prismarine-auth/src/MicrosoftAuthFlow.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var crypto = require("crypto");
    var assert = require("assert");
    var debug = require_src()("prismarine-auth");
    var { createHash } = require_Util();
    var { Endpoints, msalConfig } = require_Constants();
    var FileCache = require_FileCache();
    var LiveTokenManager = require_LiveTokenManager();
    var JavaTokenManager = require_MinecraftJavaTokenManager();
    var XboxTokenManager = require_XboxTokenManager();
    var MsaTokenManager = require_MsaTokenManager();
    var BedrockTokenManager = require_MinecraftBedrockTokenManager();
    async function retry(methodFn, beforeRetry, times) {
      while (times--) {
        if (times !== 0) {
          try {
            return await methodFn();
          } catch (e) {
            if (e instanceof URIError) {
              throw e;
            } else {
              debug(e);
            }
          }
          await new Promise((resolve) => setTimeout(resolve, 2e3));
          await beforeRetry();
        } else {
          return await methodFn();
        }
      }
    }
    var MicrosoftAuthFlow = class {
      constructor(username = "", cache = __dirname, options = {}, codeCallback) {
        this.username = username;
        this.options = options;
        this.initTokenManagers(username, cache);
        this.codeCallback = codeCallback;
      }
      initTokenManagers(username, cache) {
        if (typeof cache !== "function") {
          let cachePath = cache;
          debug(`Using cache path: ${cachePath}`);
          try {
            if (!fs.existsSync(cachePath)) {
              fs.mkdirSync(cachePath, { recursive: true });
            }
          } catch (e) {
            console.log("Failed to open cache dir", e);
            cachePath = __dirname;
          }
          cache = ({ cacheName, username: username2 }) => {
            const hash = createHash(username2);
            return new FileCache(path.join(cachePath, `./${hash}_${cacheName}-cache.json`));
          };
        }
        if (this.options.authTitle) {
          const scopes = ["service::user.auth.xboxlive.com::MBI_SSL"];
          this.msa = new LiveTokenManager(this.options.authTitle, scopes, cache({ cacheName: "live", username }));
        } else {
          const scopes = ["XboxLive.signin", "offline_access"];
          this.msa = new MsaTokenManager(msalConfig, scopes, cache({ cacheName: "msa", username }));
        }
        const keyPair = crypto.generateKeyPairSync("ec", { namedCurve: "P-256" });
        this.xbl = new XboxTokenManager(keyPair, cache({ cacheName: "xbl", username }));
        this.mba = new BedrockTokenManager(cache({ cacheName: "bed", username }));
        this.mca = new JavaTokenManager(cache({ cacheName: "mca", username }));
      }
      static resetTokenCaches(cache) {
        if (!cache)
          throw new Error("You must provide a cache directory to reset.");
        try {
          if (fs.existsSync(cache)) {
            fs.rmSync(cache, { recursive: true });
            return true;
          }
        } catch (e) {
          console.log("Failed to clear cache dir", e);
          return false;
        }
      }
      async getMsaToken() {
        if (await this.msa.verifyTokens()) {
          debug("[msa] Using existing tokens");
          const { token } = await this.msa.getAccessToken();
          return token;
        } else {
          debug("[msa] No valid cached tokens, need to sign in");
          const ret = await this.msa.authDeviceCode((response) => {
            if (this.codeCallback)
              return this.codeCallback(response);
            console.info("[msa] First time signing in. Please authenticate now:");
            console.info(response.message);
          });
          if (ret.account) {
            console.info(`[msa] Signed in as ${ret.account.username}`);
          } else {
            console.info("[msa] Signed in with Microsoft");
          }
          debug("[msa] got auth result", ret);
          return ret.accessToken;
        }
      }
      async getXboxToken(relyingParty = this.options.relyingParty || Endpoints.XboxRelyingParty) {
        const options = { ...this.options, relyingParty };
        if (await this.xbl.verifyTokens(relyingParty)) {
          debug("[xbl] Using existing XSTS token");
          const { data } = await this.xbl.getCachedXstsToken(relyingParty);
          return data;
        } else if (options.password) {
          debug("[xbl] password is present, trying to authenticate using xboxreplay/xboxlive-auth");
          const xsts = await this.xbl.doReplayAuth(this.username, options.password, options);
          return xsts;
        } else {
          debug("[xbl] Need to obtain tokens");
          return await retry(async () => {
            const msaToken = await this.getMsaToken();
            if (options.doSisuAuth) {
              assert(options.authTitle !== void 0, 'Please specify an "authTitle" in Authflow constructor when using sisu authentication');
              debug(`[xbl] Sisu flow selected, trying to authenticate with authTitle ID ${options.authTitle}`);
              const deviceToken = await this.xbl.getDeviceToken(options);
              const sisu = await this.xbl.doSisuAuth(msaToken, deviceToken, options);
              return sisu;
            }
            const userToken = await this.xbl.getUserToken(msaToken, !options.authTitle);
            if (options.authTitle) {
              const deviceToken = await this.xbl.getDeviceToken(options);
              const titleToken = await this.xbl.getTitleToken(msaToken, deviceToken);
              const xsts = await this.xbl.getXSTSToken({ userToken, deviceToken, titleToken }, options);
              return xsts;
            } else {
              const xsts = await this.xbl.getXSTSToken({ userToken }, options);
              return xsts;
            }
          }, () => {
            this.msa.forceRefresh = true;
          }, 2);
        }
      }
      async getMinecraftJavaToken(options = {}) {
        assert(this.options.authTitle !== void 0, 'Please specify an "authTitle" in Authflow constructor');
        const response = { token: "", entitlements: {}, profile: {} };
        if (await this.mca.verifyTokens()) {
          debug("[mc] Using existing tokens");
          const { token } = await this.mca.getCachedAccessToken();
          response.token = token;
        } else {
          debug("[mc] Need to obtain tokens");
          await retry(async () => {
            const xsts = await this.getXboxToken(Endpoints.PCXSTSRelyingParty);
            debug("[xbl] xsts data", xsts);
            response.token = await this.mca.getAccessToken(xsts);
          }, () => {
            this.xbl.forceRefresh = true;
          }, 2);
        }
        if (options.fetchEntitlements) {
          response.entitlements = await this.mca.fetchEntitlements(response.token).catch((e) => debug("Failed to obtain entitlement data", e));
        }
        if (options.fetchProfile) {
          response.profile = await this.mca.fetchProfile(response.token).catch((e) => debug("Failed to obtain profile data", e));
        }
        if (options.fetchCertificates) {
          response.certificates = await this.mca.fetchCertificates(response.token).catch((e) => debug("Failed to obtain keypair data", e));
        }
        return response;
      }
      async getMinecraftBedrockToken(publicKey) {
        assert(this.options.authTitle !== void 0, 'Please specify an "authTitle" in Authflow constructor');
        if (await this.mba.verifyTokens() && false) {
          debug("[mc] Using existing tokens");
          const { chain } = this.mba.getCachedAccessToken();
          return chain;
        } else {
          if (!publicKey)
            throw new Error("Need to specifiy a ECDH x509 URL encoded public key");
          debug("[mc] Need to obtain tokens");
          return await retry(async () => {
            const xsts = await this.getXboxToken(Endpoints.BedrockXSTSRelyingParty);
            debug("[xbl] xsts data", xsts);
            const token = await this.mba.getAccessToken(publicKey, xsts);
            const body = JSON.parse(Buffer.from(token.chain[1].split(".")[1], "base64").toString());
            if (!body.extraData.titleId && this.options.authTitle) {
              throw Error("missing titleId in response");
            }
            return token.chain;
          }, () => {
            this.xbl.forceRefresh = true;
          }, 2);
        }
      }
    };
    module2.exports = MicrosoftAuthFlow;
  }
});

// ../node_modules/prismarine-auth/src/common/Titles.js
var require_Titles = __commonJS({
  "../node_modules/prismarine-auth/src/common/Titles.js"(exports2, module2) {
    module2.exports = {
      MinecraftNintendoSwitch: "00000000441cc96b",
      MinecraftJava: "00000000402b5328",
      XboxAppIOS: "000000004c12ae6f",
      XboxGamepassIOS: "000000004c20a908"
    };
  }
});

// ../node_modules/prismarine-auth/index.js
var require_prismarine_auth = __commonJS({
  "../node_modules/prismarine-auth/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && parseInt(process.versions.node.split(".")[0]) < 14) {
      console.error("Your node version is currently", process.versions.node);
      console.error("Please update it to a version >= 14.x.x from https://nodejs.org/");
      process.exit(1);
    }
    module2.exports = {
      Authflow: require_MicrosoftAuthFlow(),
      Titles: require_Titles()
    };
  }
});

// ../node_modules/minecraft-protocol/src/client/microsoftAuth.js
var require_microsoftAuth = __commonJS({
  "../node_modules/minecraft-protocol/src/client/microsoftAuth.js"(exports2, module2) {
    var path = require("path");
    var { Authflow: PrismarineAuth, Titles } = require_prismarine_auth();
    var minecraftFolderPath = require_minecraft_folder_path();
    var debug = require_src()("minecraft-protocol");
    async function authenticate(client, options) {
      if (!options.profilesFolder) {
        options.profilesFolder = path.join(minecraftFolderPath, "nmp-cache");
      }
      if (options.authTitle === void 0) {
        options.authTitle = Titles.MinecraftNintendoSwitch;
        options.deviceType = "Nintendo";
      }
      const Authflow = new PrismarineAuth(options.username, options.profilesFolder, options, options.onMsaCode);
      const { token, entitlements, profile, certificates } = await Authflow.getMinecraftJavaToken({ fetchProfile: true, fetchCertificates: !options.disableChatSigning }).catch((e) => {
        if (options.password)
          console.warn("Sign in failed, try removing the password field\n");
        if (e.toString().includes("Not Found"))
          console.warn(`Please verify that the account ${options.username} owns Minecraft
`);
        throw e;
      });
      debug("[mc] entitlements", entitlements);
      debug("[mc] profile", profile);
      if (!profile || profile.error)
        throw Error(`Failed to obtain profile data for ${options.username}, does the account own minecraft?`);
      options.haveCredentials = token !== null;
      const session = {
        accessToken: token,
        selectedProfile: profile,
        availableProfile: [profile]
      };
      Object.assign(client, certificates);
      client.session = session;
      client.username = profile.name;
      options.accessToken = token;
      client.emit("session", session);
      options.connect(client);
    }
    module2.exports = {
      authenticate
    };
  }
});

// ../node_modules/minecraft-protocol/src/client/setProtocol.js
var require_setProtocol = __commonJS({
  "../node_modules/minecraft-protocol/src/client/setProtocol.js"(exports2, module2) {
    "use strict";
    var states = require_states();
    module2.exports = function(client, options) {
      client.on("connect", onConnect);
      function onConnect() {
        if (client.wait_connect) {
          client.on("connect_allowed", next);
        } else {
          next();
        }
        function next() {
          let taggedHost = options.host;
          if (client.tagHost)
            taggedHost += client.tagHost;
          if (client.fakeHost)
            taggedHost = options.fakeHost;
          client.write("set_protocol", {
            protocolVersion: options.protocolVersion,
            serverHost: taggedHost,
            serverPort: options.port,
            nextState: 2
          });
          client.state = states.LOGIN;
          client.write("login_start", {
            username: client.username,
            signature: client.profileKeys ? {
              timestamp: BigInt(client.profileKeys.expiresOn.getTime()),
              publicKey: client.profileKeys.publicDER,
              signature: client.profileKeys.signature
            } : null
          });
        }
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/client/play.js
var require_play = __commonJS({
  "../node_modules/minecraft-protocol/src/client/play.js"(exports2, module2) {
    var states = require_states();
    var crypto = require("crypto");
    var concat = require_binaryStream().concat;
    module2.exports = function(client, options) {
      client.once("success", onLogin);
      function onLogin(packet) {
        client.state = states.PLAY;
        client.uuid = packet.uuid;
        client.username = packet.username;
        client.signMessage = (message, timestamp, salt = 0) => {
          if (!client.profileKeys)
            throw Error("Can't sign message without profile keys, please set valid auth mode");
          const signable = concat(
            "i64",
            salt,
            "UUID",
            client.uuid,
            "i64",
            timestamp / 1000n,
            "pstring",
            JSON.stringify({ text: message })
          );
          return crypto.sign("RSA-SHA256", signable, client.profileKeys.private);
        };
        client.verifyMessage = (pubKey, packet2) => {
          if (pubKey instanceof Buffer)
            pubKey = crypto.createPublicKey({ key: pubKey, format: "der", type: "spki" });
          const signable = concat(
            "i64",
            packet2.salt,
            "UUID",
            packet2.senderUuid,
            "i64",
            packet2.timestamp / 1000n,
            "pstring",
            packet2.signedChatContent
          );
          return crypto.verify("RSA-SHA256", signable, pubKey, packet2.signature);
        };
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/version.js
var require_version3 = __commonJS({
  "../node_modules/minecraft-protocol/src/version.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      defaultVersion: "1.19",
      supportedVersions: ["1.7", "1.8", "1.9", "1.10", "1.11.2", "1.12.2", "1.13.2", "1.14.4", "1.15.2", "1.16.5", "1.17.1", "1.18.2", "1.19"]
    };
  }
});

// ../node_modules/minecraft-protocol/src/ping.js
var require_ping = __commonJS({
  "../node_modules/minecraft-protocol/src/ping.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var states = require_states();
    var tcpDns = require_tcp_dns();
    module2.exports = cbPing;
    function cbPing(options, cb) {
      const pingPromise = ping(options);
      if (cb) {
        pingPromise.then((d) => {
          cb(null, d);
        }).catch((err) => {
          cb(err, null);
        });
      }
      return pingPromise;
    }
    function ping(options) {
      options.host = options.host || "localhost";
      options.port = options.port || 25565;
      const optVersion = options.version || require_version3().defaultVersion;
      const mcData = require_minecraft_data()(optVersion);
      const version = mcData.version;
      options.majorVersion = version.majorVersion;
      options.protocolVersion = version.version;
      let closeTimer = null;
      options.closeTimeout = options.closeTimeout || 120 * 1e3;
      options.noPongTimeout = options.noPongTimeout || 5 * 1e3;
      const client = new Client(false, version.minecraftVersion);
      return new Promise((resolve, reject) => {
        client.on("error", function(err) {
          clearTimeout(closeTimer);
          client.end();
          reject(err);
        });
        client.once("server_info", function(packet) {
          const data = JSON.parse(packet.response);
          const start = Date.now();
          const maxTime = setTimeout(() => {
            clearTimeout(closeTimer);
            client.end();
            resolve(data);
          }, options.noPongTimeout);
          client.once("ping", function(packet2) {
            data.latency = Date.now() - start;
            clearTimeout(maxTime);
            clearTimeout(closeTimer);
            client.end();
            resolve(data);
          });
          client.write("ping", { time: [0, 0] });
        });
        client.on("state", function(newState) {
          if (newState === states.STATUS) {
            client.write("ping_start", {});
          }
        });
        client.on("connect", function() {
          client.write("set_protocol", {
            protocolVersion: options.protocolVersion,
            serverHost: options.host,
            serverPort: options.port,
            nextState: 1
          });
          client.state = states.STATUS;
        });
        closeTimer = setTimeout(function() {
          client.end();
          reject(new Error("ETIMEDOUT"));
        }, options.closeTimeout);
        tcpDns(client, options);
        options.connect(client);
      });
    }
  }
});

// ../node_modules/minecraft-protocol/src/client/autoVersion.js
var require_autoVersion = __commonJS({
  "../node_modules/minecraft-protocol/src/client/autoVersion.js"(exports2, module2) {
    "use strict";
    var ping = require_ping();
    var debug = require_src()("minecraft-protocol");
    var states = require_states();
    var minecraftData = require_minecraft_data();
    module2.exports = function(client, options) {
      client.wait_connect = true;
      debug("pinging", options.host);
      ping(options, function(err, response) {
        if (err) {
          return client.emit("error", err);
        }
        debug("ping response", response);
        const motd = response.description;
        debug("Server description:", motd);
        const brandedMinecraftVersion = response.version.name;
        const protocolVersion = response.version.protocol;
        const guessFromName = [brandedMinecraftVersion].concat(brandedMinecraftVersion.match(/((\d+\.)+\d+)/g) || []).map(function(version) {
          return minecraftData.versionsByMinecraftVersion.pc[version];
        }).filter(function(info) {
          return info;
        }).sort(function(a, b) {
          return b.version - a.version;
        });
        const versions = (minecraftData.postNettyVersionsByProtocolVersion.pc[protocolVersion] || []).concat(guessFromName);
        if (versions.length === 0) {
          client.emit("error", new Error(`unsupported/unknown protocol version: ${protocolVersion}, update minecraft-data`));
        }
        const minecraftVersion = versions[0].minecraftVersion;
        debug(`Server version: ${minecraftVersion}, protocol: ${protocolVersion}`);
        options.version = minecraftVersion;
        options.protocolVersion = protocolVersion;
        client.version = minecraftVersion;
        client.state = states.HANDSHAKING;
        if (client.autoVersionHooks) {
          client.autoVersionHooks.forEach((hook) => {
            hook(response, client, options);
          });
        }
        client.emit("connect_allowed");
        client.wait_connect = false;
      });
      return client;
    };
  }
});

// ../node_modules/minecraft-protocol/src/client/pluginChannels.js
var require_pluginChannels = __commonJS({
  "../node_modules/minecraft-protocol/src/client/pluginChannels.js"(exports2, module2) {
    var ProtoDef = require_protodef2().ProtoDef;
    var minecraft = require_minecraft();
    var debug = require_src()("minecraft-protocol");
    module2.exports = function(client, options) {
      const mcdata = require_minecraft_data()(options.version || require_version3().defaultVersion);
      const channels = [];
      const proto = new ProtoDef(options.validateChannelProtocol ?? true);
      proto.addTypes(mcdata.protocol.types);
      proto.addTypes(minecraft);
      proto.addType("registerarr", [readDumbArr, writeDumbArr, sizeOfDumbArr]);
      client.registerChannel = registerChannel;
      client.unregisterChannel = unregisterChannel;
      client.writeChannel = writeChannel;
      client.registerChannel("REGISTER", ["registerarr", []]);
      client.registerChannel("UNREGISTER", ["registerarr", []]);
      const above385 = options.protocolVersion >= 385;
      if (above385) {
        client.on("login_plugin_request", onLoginPluginRequest);
      }
      const channelNames = above385 ? ["minecraft:register", "minecraft:unregister"] : ["REGISTER", "UNREGISTER"];
      function registerChannel(name, parser, custom) {
        if (custom) {
          client.writeChannel(channelNames[0], [name]);
        }
        if (parser)
          proto.addType(name, parser);
        channels.push(name);
        if (channels.length === 1) {
          client.on("custom_payload", onCustomPayload);
        }
      }
      function unregisterChannel(channel, custom) {
        if (custom) {
          client.writeChannel(channelNames[1], [channel]);
        }
        const index = channels.find(function(name) {
          return channel === name;
        });
        if (index) {
          proto.types[channel] = void 0;
          channels.splice(index, 1);
          if (channels.length === 0) {
            client.removeListener("custom_payload", onCustomPayload);
          }
        }
      }
      function onCustomPayload(packet) {
        const channel = channels.find(function(channel2) {
          return channel2 === packet.channel;
        });
        if (channel) {
          if (proto.types[channel]) {
            packet.data = proto.parsePacketBuffer(channel, packet.data).data;
          }
          debug("read custom payload " + channel + " " + packet.data);
          client.emit(channel, packet.data);
        }
      }
      function onLoginPluginRequest(packet) {
        client.write("login_plugin_response", {
          messageId: packet.messageId
        });
      }
      function writeChannel(channel, params) {
        debug("write custom payload " + channel + " " + params);
        client.write("custom_payload", {
          channel,
          data: proto.createPacketBuffer(channel, params)
        });
      }
      function readDumbArr(buf, offset) {
        const ret = {
          value: [],
          size: 0
        };
        let results;
        while (offset < buf.length) {
          if (buf.indexOf(0, offset) === -1) {
            results = this.read(buf, offset, "restBuffer", {});
          } else {
            results = this.read(buf, offset, "cstring", {});
          }
          ret.size += results.size;
          ret.value.push(results.value.toString());
          offset += results.size;
        }
        return ret;
      }
      function writeDumbArr(value, buf, offset) {
        value.forEach(function(v) {
          offset += proto.write(v, buf, offset, "cstring");
        });
        return offset;
      }
      function sizeOfDumbArr(value) {
        return value.reduce((acc, v) => acc + this.sizeOf(v, "cstring", {}), 0);
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/client/versionChecking.js
var require_versionChecking = __commonJS({
  "../node_modules/minecraft-protocol/src/client/versionChecking.js"(exports2, module2) {
    module2.exports = function(client, options) {
      client.on("disconnect", (message) => {
        if (!message.reason) {
          return;
        }
        const parsed = JSON.parse(message.reason);
        let text = parsed.text ? parsed.text : parsed;
        let versionRequired;
        if (text.translate && text.translate.startsWith("multiplayer.disconnect.outdated_")) {
          versionRequired = text.with[0];
        } else {
          if (text.extra)
            text = text.extra[0].text;
          versionRequired = /(?:Outdated client! Please use|Outdated server! I'm still on) (.+)/.exec(text);
          versionRequired = versionRequired ? versionRequired[1] : null;
        }
        if (!versionRequired) {
          return;
        }
        client.emit("error", new Error("This server is version " + versionRequired + ", you are using version " + client.version + ", please specify the correct version in the options."));
        client.end("differentVersionError");
      });
    };
  }
});

// ../node_modules/minecraft-protocol/src/createClient.js
var require_createClient = __commonJS({
  "../node_modules/minecraft-protocol/src/createClient.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var assert = require("assert");
    var encrypt = require_encrypt();
    var keepalive = require_keepalive();
    var compress = require_compress();
    var auth = require_mojangAuth();
    var microsoftAuth = require_microsoftAuth();
    var setProtocol = require_setProtocol();
    var play = require_play();
    var tcpDns = require_tcp_dns();
    var autoVersion = require_autoVersion();
    var pluginChannels = require_pluginChannels();
    var versionChecking = require_versionChecking();
    module2.exports = createClient;
    function createClient(options) {
      assert.ok(options, "options is required");
      assert.ok(options.username, "username is required");
      if (!options.version) {
        options.version = false;
      }
      const optVersion = options.version || require_version3().defaultVersion;
      const mcData = require_minecraft_data()(optVersion);
      if (!mcData)
        throw new Error(`unsupported protocol version: ${optVersion}`);
      const version = mcData.version;
      options.majorVersion = version.majorVersion;
      options.protocolVersion = version.version;
      const hideErrors = options.hideErrors || false;
      const client = new Client(false, version.minecraftVersion, options.customPackets, hideErrors);
      tcpDns(client, options);
      if (options.auth instanceof Function) {
        options.auth(client, options);
      } else {
        switch (options.auth) {
          case "mojang":
            console.warn("[deprecated] mojang auth servers no longer accept mojang accounts to login. convert your account.\nhttps://help.minecraft.net/hc/en-us/articles/4403181904525-How-to-Migrate-Your-Mojang-Account-to-a-Microsoft-Account");
            auth(client, options);
            break;
          case "microsoft":
            microsoftAuth.authenticate(client, options).catch((err) => client.emit("error", err));
            break;
          case "offline":
          default:
            client.username = options.username;
            options.connect(client);
            break;
        }
      }
      if (options.version === false)
        autoVersion(client, options);
      setProtocol(client, options);
      keepalive(client, options);
      encrypt(client, options);
      play(client, options);
      compress(client, options);
      pluginChannels(client, options);
      versionChecking(client, options);
      return client;
    }
  }
});

// ../node_modules/node-rsa/src/utils.js
var require_utils10 = __commonJS({
  "../node_modules/node-rsa/src/utils.js"(exports2, module2) {
    var crypt = require("crypto");
    module2.exports.linebrk = function(str, maxLen) {
      var res = "";
      var i = 0;
      while (i + maxLen < str.length) {
        res += str.substring(i, i + maxLen) + "\n";
        i += maxLen;
      }
      return res + str.substring(i, str.length);
    };
    module2.exports.detectEnvironment = function() {
      if (process && process.title === "browser" || typeof window !== "undefined" && window) {
        return "browser";
      }
      return "node";
    };
    module2.exports.get32IntFromBuffer = function(buffer, offset) {
      offset = offset || 0;
      var size = 0;
      if ((size = buffer.length - offset) > 0) {
        if (size >= 4) {
          return buffer.readUInt32BE(offset);
        } else {
          var res = 0;
          for (var i = offset + size, d = 0; i > offset; i--, d += 2) {
            res += buffer[i - 1] * Math.pow(16, d);
          }
          return res;
        }
      } else {
        return NaN;
      }
    };
    module2.exports._ = {
      isObject: function(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      },
      isString: function(value) {
        return typeof value == "string" || value instanceof String;
      },
      isNumber: function(value) {
        return typeof value == "number" || !isNaN(parseFloat(value)) && isFinite(value);
      },
      omit: function(obj, removeProp) {
        var newObj = {};
        for (var prop in obj) {
          if (!obj.hasOwnProperty(prop) || prop === removeProp) {
            continue;
          }
          newObj[prop] = obj[prop];
        }
        return newObj;
      }
    };
  }
});

// ../node_modules/node-rsa/src/libs/jsbn.js
var require_jsbn = __commonJS({
  "../node_modules/node-rsa/src/libs/jsbn.js"(exports2, module2) {
    var crypt = require("crypto");
    var _ = require_utils10()._;
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b) {
      if (a != null) {
        if ("number" == typeof a) {
          this.fromNumber(a, b);
        } else if (Buffer.isBuffer(a)) {
          this.fromBuffer(a);
        } else if (b == null && "string" != typeof a) {
          this.fromByteArray(a);
        } else {
          this.fromString(a, b);
        }
      }
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this[i] & 16383;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 268435455;
      }
      return c;
    }
    BigInteger.prototype.am = am3;
    dbits = 28;
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this[0] = x;
      else if (x < -1)
        this[0] = x + DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(data, radix, unsigned) {
      var k;
      switch (radix) {
        case 2:
          k = 1;
          break;
        case 4:
          k = 2;
          break;
        case 8:
          k = 3;
          break;
        case 16:
          k = 4;
          break;
        case 32:
          k = 5;
          break;
        case 256:
          k = 8;
          break;
        default:
          this.fromRadix(data, radix);
          return;
      }
      this.t = 0;
      this.s = 0;
      var i = data.length;
      var mi = false;
      var sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? data[i] & 255 : intAt(data, i);
        if (x < 0) {
          if (data.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh === 0)
          this[this.t++] = x;
        else if (sh + k > this.DB) {
          this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this[this.t++] = x >> this.DB - sh;
        } else
          this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (!unsigned && k == 8 && (data[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromByteArray(a, unsigned) {
      this.fromString(a, 256, unsigned);
    }
    function bnpFromBuffer(a) {
      this.fromString(a, 256, true);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this[i] & (1 << p) - 1) << k - p;
            d |= this[--i] >> (p += this.DB - k);
          } else {
            d = this[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this[i] - a[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r[i + n] = this[i];
      for (i = n - 1; i >= 0; --i)
        r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r[i + ds + 1] = this[i] >> cbs | c;
        c = (this[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r[i] = 0;
      r[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = this[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
      }
      if (bs > 0)
        r[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r[i++] = this.DV + c;
      else if (c > 0)
        r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0; i < y.t; ++i)
        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q2, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q2 != null)
          q2.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y[ys - 1];
      if (y0 === 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t = q2 == null ? nbi() : q2;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y[y.t++] = 0;
      while (--j >= 0) {
        var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r[i] < --qd)
            r.subTo(t, r);
        }
      }
      if (q2 != null) {
        r.drShiftTo(ys, q2);
        if (ts != ms)
          BigInteger.ZERO.subTo(q2, q2);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this[0];
      if ((x & 1) === 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] >= x.DV) {
          x[j] -= x.DV;
          x[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) === 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        else if (this.t === 0)
          return -1;
      } else if (this.t == 1)
        return this[0];
      else if (this.t === 0)
        return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() === 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() === 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b) {
      if ("number" == typeof b) {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = crypt.randomBytes((a >> 3) + 1);
        var t = a & 7;
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        this.fromByteArray(x);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this[i] & (1 << p) - 1) << 8 - p;
            d |= this[--i] >> (p += this.DB - 8);
          } else {
            d = this[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k === 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnToBuffer(trimOrSize) {
      var res = new Buffer(this.toByteArray());
      if (trimOrSize === true && res[0] === 0) {
        res = res.slice(1);
      } else if (_.isNumber(trimOrSize)) {
        if (res.length > trimOrSize) {
          for (var i = 0; i < res.length - trimOrSize; i++) {
            if (res[i] !== 0) {
              return null;
            }
          }
          return res.slice(res.length - trimOrSize);
        } else if (res.length < trimOrSize) {
          var padded = new Buffer(trimOrSize);
          padded.fill(0, 0, trimOrSize - res.length);
          res.copy(padded, trimOrSize - res.length);
          return padded;
        }
      }
      return res;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f, m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r[i] = op(this[i], a[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r[i] = op(this[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r[i] = op(f, a[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x === 0)
        return -1;
      var r = 0;
      if ((x & 65535) === 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) === 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) === 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) === 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) === 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this[i] != 0)
          return i * this.DB + lbit(this[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r[i++] = c;
      else if (c < -1)
        r[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = nbi();
      this.squareTo(r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q2 = nbi(), r = nbi();
      this.divRemTo(a, q2, r);
      return new Array(q2, r);
    }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n === 0)
        return;
      while (this.t <= w)
        this[this.t++] = 0;
      this[w] += n;
      while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t)
          this[this.t++] = 0;
        ++this[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e[j] >> i - k1 & km;
        else {
          w = (e[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) === 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e[j] & 1 << i) === 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d === 0)
          r = this[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() === 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] === 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      t = t + 1 >> 1;
      if (t > lowprimes.length)
        t = lowprimes.length;
      var a = nbi();
      for (var i = 0; i < t; ++i) {
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) === 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.fromByteArray = bnpFromByteArray;
    BigInteger.prototype.fromBuffer = bnpFromBuffer;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.toBuffer = bnToBuffer;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.int2char = int2char;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    BigInteger.prototype.square = bnSquare;
    module2.exports = BigInteger;
  }
});

// ../node_modules/node-rsa/src/schemes/pkcs1.js
var require_pkcs1 = __commonJS({
  "../node_modules/node-rsa/src/schemes/pkcs1.js"(exports2, module2) {
    var BigInteger = require_jsbn();
    var crypt = require("crypto");
    var constants = require("constants");
    var SIGN_INFO_HEAD = {
      md2: new Buffer("3020300c06082a864886f70d020205000410", "hex"),
      md5: new Buffer("3020300c06082a864886f70d020505000410", "hex"),
      sha1: new Buffer("3021300906052b0e03021a05000414", "hex"),
      sha224: new Buffer("302d300d06096086480165030402040500041c", "hex"),
      sha256: new Buffer("3031300d060960864801650304020105000420", "hex"),
      sha384: new Buffer("3041300d060960864801650304020205000430", "hex"),
      sha512: new Buffer("3051300d060960864801650304020305000440", "hex"),
      ripemd160: new Buffer("3021300906052b2403020105000414", "hex"),
      rmd160: new Buffer("3021300906052b2403020105000414", "hex")
    };
    var SIGN_ALG_TO_HASH_ALIASES = {
      "ripemd160": "rmd160"
    };
    var DEFAULT_HASH_FUNCTION = "sha256";
    module2.exports = {
      isEncryption: true,
      isSignature: true
    };
    module2.exports.makeScheme = function(key, options) {
      function Scheme(key2, options2) {
        this.key = key2;
        this.options = options2;
      }
      Scheme.prototype.maxMessageLength = function() {
        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {
          return this.key.encryptedDataLength;
        }
        return this.key.encryptedDataLength - 11;
      };
      Scheme.prototype.encPad = function(buffer, options2) {
        options2 = options2 || {};
        var filled;
        if (buffer.length > this.key.maxMessageLength) {
          throw new Error("Message too long for RSA (n=" + this.key.encryptedDataLength + ", l=" + buffer.length + ")");
        }
        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {
          return this.pkcs0pad(buffer);
        }
        if (options2.type === 1) {
          filled = new Buffer(this.key.encryptedDataLength - buffer.length - 1);
          filled.fill(255, 0, filled.length - 1);
          filled[0] = 1;
          filled[filled.length - 1] = 0;
          return Buffer.concat([filled, buffer]);
        } else {
          filled = new Buffer(this.key.encryptedDataLength - buffer.length);
          filled[0] = 0;
          filled[1] = 2;
          var rand = crypt.randomBytes(filled.length - 3);
          for (var i = 0; i < rand.length; i++) {
            var r = rand[i];
            while (r === 0) {
              r = crypt.randomBytes(1)[0];
            }
            filled[i + 2] = r;
          }
          filled[filled.length - 1] = 0;
          return Buffer.concat([filled, buffer]);
        }
      };
      Scheme.prototype.encUnPad = function(buffer, options2) {
        options2 = options2 || {};
        var i = 0;
        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {
          return this.pkcs0unpad(buffer);
        }
        if (buffer.length < 4) {
          return null;
        }
        if (options2.type === 1) {
          if (buffer[0] !== 0 && buffer[1] !== 1) {
            return null;
          }
          i = 3;
          while (buffer[i] !== 0) {
            if (buffer[i] != 255 || ++i >= buffer.length) {
              return null;
            }
          }
        } else {
          if (buffer[0] !== 0 && buffer[1] !== 2) {
            return null;
          }
          i = 3;
          while (buffer[i] !== 0) {
            if (++i >= buffer.length) {
              return null;
            }
          }
        }
        return buffer.slice(i + 1, buffer.length);
      };
      Scheme.prototype.sign = function(buffer) {
        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        if (this.options.environment === "browser") {
          hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;
          var hasher = crypt.createHash(hashAlgorithm);
          hasher.update(buffer);
          var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);
          var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);
          return res;
        } else {
          var signer = crypt.createSign("RSA-" + hashAlgorithm.toUpperCase());
          signer.update(buffer);
          return signer.sign(this.options.rsaUtils.exportKey("private"));
        }
      };
      Scheme.prototype.verify = function(buffer, signature, signature_encoding) {
        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {
          return false;
        }
        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        if (this.options.environment === "browser") {
          hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;
          if (signature_encoding) {
            signature = new Buffer(signature, signature_encoding);
          }
          var hasher = crypt.createHash(hashAlgorithm);
          hasher.update(buffer);
          var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);
          var m = this.key.$doPublic(new BigInteger(signature));
          return m.toBuffer().toString("hex") == hash.toString("hex");
        } else {
          var verifier = crypt.createVerify("RSA-" + hashAlgorithm.toUpperCase());
          verifier.update(buffer);
          return verifier.verify(this.options.rsaUtils.exportKey("public"), signature, signature_encoding);
        }
      };
      Scheme.prototype.pkcs0pad = function(buffer) {
        var filled = new Buffer(this.key.maxMessageLength - buffer.length);
        filled.fill(0);
        return Buffer.concat([filled, buffer]);
        return filled;
      };
      Scheme.prototype.pkcs0unpad = function(buffer) {
        var unPad;
        if (typeof buffer.lastIndexOf == "function") {
          unPad = buffer.slice(buffer.lastIndexOf("\0") + 1, buffer.length);
        } else {
          unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, "\0") + 1, buffer.length);
        }
        return unPad;
      };
      Scheme.prototype.pkcs1pad = function(hashBuf, hashAlgorithm) {
        var digest = SIGN_INFO_HEAD[hashAlgorithm];
        if (!digest) {
          throw Error("Unsupported hash algorithm");
        }
        var data = Buffer.concat([digest, hashBuf]);
        if (data.length + 10 > this.key.encryptedDataLength) {
          throw Error("Key is too short for signing algorithm (" + hashAlgorithm + ")");
        }
        var filled = new Buffer(this.key.encryptedDataLength - data.length - 1);
        filled.fill(255, 0, filled.length - 1);
        filled[0] = 1;
        filled[filled.length - 1] = 0;
        var res = Buffer.concat([filled, data]);
        return res;
      };
      return new Scheme(key, options);
    };
  }
});

// ../node_modules/node-rsa/src/schemes/oaep.js
var require_oaep = __commonJS({
  "../node_modules/node-rsa/src/schemes/oaep.js"(exports2, module2) {
    var BigInteger = require_jsbn();
    var crypt = require("crypto");
    module2.exports = {
      isEncryption: true,
      isSignature: false
    };
    module2.exports.digestLength = {
      md4: 16,
      md5: 16,
      ripemd160: 20,
      rmd160: 20,
      sha: 20,
      sha1: 20,
      sha224: 28,
      sha256: 32,
      sha384: 48,
      sha512: 64
    };
    var DEFAULT_HASH_FUNCTION = "sha1";
    module2.exports.eme_oaep_mgf1 = function(seed, maskLength, hashFunction) {
      hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
      var hLen = module2.exports.digestLength[hashFunction];
      var count = Math.ceil(maskLength / hLen);
      var T = new Buffer(hLen * count);
      var c = new Buffer(4);
      for (var i = 0; i < count; ++i) {
        var hash = crypt.createHash(hashFunction);
        hash.update(seed);
        c.writeUInt32BE(i, 0);
        hash.update(c);
        hash.digest().copy(T, i * hLen);
      }
      return T.slice(0, maskLength);
    };
    module2.exports.makeScheme = function(key, options) {
      function Scheme(key2, options2) {
        this.key = key2;
        this.options = options2;
      }
      Scheme.prototype.maxMessageLength = function() {
        return this.key.encryptedDataLength - 2 * module2.exports.digestLength[this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION] - 2;
      };
      Scheme.prototype.encPad = function(buffer) {
        var hash = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        var mgf = this.options.encryptionSchemeOptions.mgf || module2.exports.eme_oaep_mgf1;
        var label = this.options.encryptionSchemeOptions.label || new Buffer(0);
        var emLen = this.key.encryptedDataLength;
        var hLen = module2.exports.digestLength[hash];
        if (buffer.length > emLen - 2 * hLen - 2) {
          throw new Error("Message is too long to encode into an encoded message with a length of " + emLen + " bytes, increaseemLen to fix this error (minimum value for given parameters and options: " + (emLen - 2 * hLen - 2) + ")");
        }
        var lHash = crypt.createHash(hash);
        lHash.update(label);
        lHash = lHash.digest();
        var PS = new Buffer(emLen - buffer.length - 2 * hLen - 1);
        PS.fill(0);
        PS[PS.length - 1] = 1;
        var DB = Buffer.concat([lHash, PS, buffer]);
        var seed = crypt.randomBytes(hLen);
        var mask = mgf(seed, DB.length, hash);
        for (var i = 0; i < DB.length; i++) {
          DB[i] ^= mask[i];
        }
        mask = mgf(DB, hLen, hash);
        for (i = 0; i < seed.length; i++) {
          seed[i] ^= mask[i];
        }
        var em = new Buffer(1 + seed.length + DB.length);
        em[0] = 0;
        seed.copy(em, 1);
        DB.copy(em, 1 + seed.length);
        return em;
      };
      Scheme.prototype.encUnPad = function(buffer) {
        var hash = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        var mgf = this.options.encryptionSchemeOptions.mgf || module2.exports.eme_oaep_mgf1;
        var label = this.options.encryptionSchemeOptions.label || new Buffer(0);
        var hLen = module2.exports.digestLength[hash];
        if (buffer.length < 2 * hLen + 2) {
          throw new Error("Error decoding message, the supplied message is not long enough to be a valid OAEP encoded message");
        }
        var seed = buffer.slice(1, hLen + 1);
        var DB = buffer.slice(1 + hLen);
        var mask = mgf(DB, hLen, hash);
        for (var i = 0; i < seed.length; i++) {
          seed[i] ^= mask[i];
        }
        mask = mgf(seed, DB.length, hash);
        for (i = 0; i < DB.length; i++) {
          DB[i] ^= mask[i];
        }
        var lHash = crypt.createHash(hash);
        lHash.update(label);
        lHash = lHash.digest();
        var lHashEM = DB.slice(0, hLen);
        if (lHashEM.toString("hex") != lHash.toString("hex")) {
          throw new Error("Error decoding message, the lHash calculated from the label provided and the lHash in the encrypted data do not match.");
        }
        i = hLen;
        while (DB[i++] === 0 && i < DB.length)
          ;
        if (DB[i - 1] != 1) {
          throw new Error("Error decoding message, there is no padding message separator byte");
        }
        return DB.slice(i);
      };
      return new Scheme(key, options);
    };
  }
});

// ../node_modules/node-rsa/src/schemes/pss.js
var require_pss = __commonJS({
  "../node_modules/node-rsa/src/schemes/pss.js"(exports2, module2) {
    var BigInteger = require_jsbn();
    var crypt = require("crypto");
    module2.exports = {
      isEncryption: false,
      isSignature: true
    };
    var DEFAULT_HASH_FUNCTION = "sha1";
    var DEFAULT_SALT_LENGTH = 20;
    module2.exports.makeScheme = function(key, options) {
      var OAEP = require_schemes().pkcs1_oaep;
      function Scheme(key2, options2) {
        this.key = key2;
        this.options = options2;
      }
      Scheme.prototype.sign = function(buffer) {
        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);
        mHash.update(buffer);
        var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);
        return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);
      };
      Scheme.prototype.verify = function(buffer, signature, signature_encoding) {
        if (signature_encoding) {
          signature = new Buffer(signature, signature_encoding);
        }
        signature = new BigInteger(signature);
        var emLen = Math.ceil((this.key.keySize - 1) / 8);
        var m = this.key.$doPublic(signature).toBuffer(emLen);
        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);
        mHash.update(buffer);
        return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);
      };
      Scheme.prototype.emsa_pss_encode = function(mHash, emBits) {
        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;
        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;
        var hLen = OAEP.digestLength[hash];
        var emLen = Math.ceil(emBits / 8);
        if (emLen < hLen + sLen + 2) {
          throw new Error(
            "Output length passed to emBits(" + emBits + ") is too small for the options specified(" + hash + ", " + sLen + "). To fix this issue increase the value of emBits. (minimum size: " + (8 * hLen + 8 * sLen + 9) + ")"
          );
        }
        var salt = crypt.randomBytes(sLen);
        var Mapostrophe = new Buffer(8 + hLen + sLen);
        Mapostrophe.fill(0, 0, 8);
        mHash.copy(Mapostrophe, 8);
        salt.copy(Mapostrophe, 8 + mHash.length);
        var H = crypt.createHash(hash);
        H.update(Mapostrophe);
        H = H.digest();
        var PS = new Buffer(emLen - salt.length - hLen - 2);
        PS.fill(0);
        var DB = new Buffer(PS.length + 1 + salt.length);
        PS.copy(DB);
        DB[PS.length] = 1;
        salt.copy(DB, PS.length + 1);
        var dbMask = mgf(H, DB.length, hash);
        var maskedDB = new Buffer(DB.length);
        for (var i = 0; i < dbMask.length; i++) {
          maskedDB[i] = DB[i] ^ dbMask[i];
        }
        var bits = 8 * emLen - emBits;
        var mask = 255 ^ 255 >> 8 - bits << 8 - bits;
        maskedDB[0] = maskedDB[0] & mask;
        var EM = new Buffer(maskedDB.length + H.length + 1);
        maskedDB.copy(EM, 0);
        H.copy(EM, maskedDB.length);
        EM[EM.length - 1] = 188;
        return EM;
      };
      Scheme.prototype.emsa_pss_verify = function(mHash, EM, emBits) {
        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;
        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;
        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;
        var hLen = OAEP.digestLength[hash];
        var emLen = Math.ceil(emBits / 8);
        if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 188) {
          return false;
        }
        var DB = new Buffer(emLen - hLen - 1);
        EM.copy(DB, 0, 0, emLen - hLen - 1);
        var mask = 0;
        for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {
          mask |= 1 << 7 - i;
        }
        if ((DB[0] & mask) !== 0) {
          return false;
        }
        var H = EM.slice(emLen - hLen - 1, emLen - 1);
        var dbMask = mgf(H, DB.length, hash);
        for (i = 0; i < DB.length; i++) {
          DB[i] ^= dbMask[i];
        }
        bits = 8 * emLen - emBits;
        mask = 255 ^ 255 >> 8 - bits << 8 - bits;
        DB[0] = DB[0] & mask;
        for (i = 0; DB[i] === 0 && i < DB.length; i++)
          ;
        if (DB[i] != 1) {
          return false;
        }
        var salt = DB.slice(DB.length - sLen);
        var Mapostrophe = new Buffer(8 + hLen + sLen);
        Mapostrophe.fill(0, 0, 8);
        mHash.copy(Mapostrophe, 8);
        salt.copy(Mapostrophe, 8 + mHash.length);
        var Hapostrophe = crypt.createHash(hash);
        Hapostrophe.update(Mapostrophe);
        Hapostrophe = Hapostrophe.digest();
        return H.toString("hex") === Hapostrophe.toString("hex");
      };
      return new Scheme(key, options);
    };
  }
});

// ../node_modules/node-rsa/src/schemes/schemes.js
var require_schemes = __commonJS({
  "../node_modules/node-rsa/src/schemes/schemes.js"(exports2, module2) {
    module2.exports = {
      pkcs1: require_pkcs1(),
      pkcs1_oaep: require_oaep(),
      pss: require_pss(),
      isEncryption: function(scheme) {
        return module2.exports[scheme] && module2.exports[scheme].isEncryption;
      },
      isSignature: function(scheme) {
        return module2.exports[scheme] && module2.exports[scheme].isSignature;
      }
    };
  }
});

// ../node_modules/node-rsa/src/encryptEngines/js.js
var require_js = __commonJS({
  "../node_modules/node-rsa/src/encryptEngines/js.js"(exports2, module2) {
    var BigInteger = require_jsbn();
    var schemes = require_schemes();
    module2.exports = function(keyPair, options) {
      var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);
      return {
        encrypt: function(buffer, usePrivate) {
          var m, c;
          if (usePrivate) {
            m = new BigInteger(pkcs1Scheme.encPad(buffer, { type: 1 }));
            c = keyPair.$doPrivate(m);
          } else {
            m = new BigInteger(keyPair.encryptionScheme.encPad(buffer));
            c = keyPair.$doPublic(m);
          }
          return c.toBuffer(keyPair.encryptedDataLength);
        },
        decrypt: function(buffer, usePublic) {
          var m, c = new BigInteger(buffer);
          if (usePublic) {
            m = keyPair.$doPublic(c);
            return pkcs1Scheme.encUnPad(m.toBuffer(keyPair.encryptedDataLength), { type: 1 });
          } else {
            m = keyPair.$doPrivate(c);
            return keyPair.encryptionScheme.encUnPad(m.toBuffer(keyPair.encryptedDataLength));
          }
        }
      };
    };
  }
});

// ../node_modules/node-rsa/src/encryptEngines/io.js
var require_io = __commonJS({
  "../node_modules/node-rsa/src/encryptEngines/io.js"(exports2, module2) {
    var crypto = require("crypto");
    var constants = require("constants");
    var schemes = require_schemes();
    module2.exports = function(keyPair, options) {
      var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);
      return {
        encrypt: function(buffer, usePrivate) {
          if (usePrivate) {
            var padding = constants.RSA_PKCS1_PADDING;
            if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
              padding = options.encryptionSchemeOptions.padding;
            }
            return crypto.privateEncrypt({
              key: options.rsaUtils.exportKey("private"),
              padding
            }, buffer);
          } else {
            var padding = constants.RSA_PKCS1_OAEP_PADDING;
            if (options.encryptionScheme === "pkcs1") {
              padding = constants.RSA_PKCS1_PADDING;
            }
            if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
              padding = options.encryptionSchemeOptions.padding;
            }
            var data = buffer;
            if (padding === constants.RSA_NO_PADDING) {
              data = pkcs1Scheme.pkcs0pad(buffer);
            }
            return crypto.publicEncrypt({
              key: options.rsaUtils.exportKey("public"),
              padding
            }, data);
          }
        },
        decrypt: function(buffer, usePublic) {
          if (usePublic) {
            var padding = constants.RSA_PKCS1_PADDING;
            if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
              padding = options.encryptionSchemeOptions.padding;
            }
            return crypto.publicDecrypt({
              key: options.rsaUtils.exportKey("public"),
              padding
            }, buffer);
          } else {
            var padding = constants.RSA_PKCS1_OAEP_PADDING;
            if (options.encryptionScheme === "pkcs1") {
              padding = constants.RSA_PKCS1_PADDING;
            }
            if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
              padding = options.encryptionSchemeOptions.padding;
            }
            var res = crypto.privateDecrypt({
              key: options.rsaUtils.exportKey("private"),
              padding
            }, buffer);
            if (padding === constants.RSA_NO_PADDING) {
              return pkcs1Scheme.pkcs0unpad(res);
            }
            return res;
          }
        }
      };
    };
  }
});

// ../node_modules/node-rsa/src/encryptEngines/node12.js
var require_node12 = __commonJS({
  "../node_modules/node-rsa/src/encryptEngines/node12.js"(exports2, module2) {
    var crypto = require("crypto");
    var constants = require("constants");
    var schemes = require_schemes();
    module2.exports = function(keyPair, options) {
      var jsEngine = require_js()(keyPair, options);
      var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);
      return {
        encrypt: function(buffer, usePrivate) {
          if (usePrivate) {
            return jsEngine.encrypt(buffer, usePrivate);
          }
          var padding = constants.RSA_PKCS1_OAEP_PADDING;
          if (options.encryptionScheme === "pkcs1") {
            padding = constants.RSA_PKCS1_PADDING;
          }
          if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
            padding = options.encryptionSchemeOptions.padding;
          }
          var data = buffer;
          if (padding === constants.RSA_NO_PADDING) {
            data = pkcs1Scheme.pkcs0pad(buffer);
          }
          return crypto.publicEncrypt({
            key: options.rsaUtils.exportKey("public"),
            padding
          }, data);
        },
        decrypt: function(buffer, usePublic) {
          if (usePublic) {
            return jsEngine.decrypt(buffer, usePublic);
          }
          var padding = constants.RSA_PKCS1_OAEP_PADDING;
          if (options.encryptionScheme === "pkcs1") {
            padding = constants.RSA_PKCS1_PADDING;
          }
          if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {
            padding = options.encryptionSchemeOptions.padding;
          }
          var res = crypto.privateDecrypt({
            key: options.rsaUtils.exportKey("private"),
            padding
          }, buffer);
          if (padding === constants.RSA_NO_PADDING) {
            return pkcs1Scheme.pkcs0unpad(res);
          }
          return res;
        }
      };
    };
  }
});

// ../node_modules/node-rsa/src/encryptEngines/encryptEngines.js
var require_encryptEngines = __commonJS({
  "../node_modules/node-rsa/src/encryptEngines/encryptEngines.js"(exports2, module2) {
    var crypt = require("crypto");
    module2.exports = {
      getEngine: function(keyPair, options) {
        var engine = require_js();
        if (options.environment === "node") {
          if (typeof crypt.publicEncrypt === "function" && typeof crypt.privateDecrypt === "function") {
            if (typeof crypt.privateEncrypt === "function" && typeof crypt.publicDecrypt === "function") {
              engine = require_io();
            } else {
              engine = require_node12();
            }
          }
        }
        return engine(keyPair, options);
      }
    };
  }
});

// ../node_modules/node-rsa/src/libs/rsa.js
var require_rsa = __commonJS({
  "../node_modules/node-rsa/src/libs/rsa.js"(exports2, module2) {
    var _ = require_utils10()._;
    var crypt = require("crypto");
    var BigInteger = require_jsbn();
    var utils2 = require_utils10();
    var schemes = require_schemes();
    var encryptEngines = require_encryptEngines();
    exports2.BigInteger = BigInteger;
    module2.exports.Key = function() {
      function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
      }
      RSAKey.prototype.setOptions = function(options) {
        var signingSchemeProvider = schemes[options.signingScheme];
        var encryptionSchemeProvider = schemes[options.encryptionScheme];
        if (signingSchemeProvider === encryptionSchemeProvider) {
          this.signingScheme = this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);
        } else {
          this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);
          this.signingScheme = signingSchemeProvider.makeScheme(this, options);
        }
        this.encryptEngine = encryptEngines.getEngine(this, options);
      };
      RSAKey.prototype.generate = function(B, E) {
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        while (true) {
          while (true) {
            this.p = new BigInteger(B - qs, 1);
            if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.p.isProbablePrime(10))
              break;
          }
          while (true) {
            this.q = new BigInteger(qs, 1);
            if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.q.isProbablePrime(10))
              break;
          }
          if (this.p.compareTo(this.q) <= 0) {
            var t = this.p;
            this.p = this.q;
            this.q = t;
          }
          var p1 = this.p.subtract(BigInteger.ONE);
          var q1 = this.q.subtract(BigInteger.ONE);
          var phi = p1.multiply(q1);
          if (phi.gcd(ee).compareTo(BigInteger.ONE) === 0) {
            this.n = this.p.multiply(this.q);
            if (this.n.bitLength() < B) {
              continue;
            }
            this.d = ee.modInverse(phi);
            this.dmp1 = this.d.mod(p1);
            this.dmq1 = this.d.mod(q1);
            this.coeff = this.q.modInverse(this.p);
            break;
          }
        }
        this.$$recalculateCache();
      };
      RSAKey.prototype.setPrivate = function(N, E, D, P, Q, DP, DQ, C) {
        if (N && E && D && N.length > 0 && (_.isNumber(E) || E.length > 0) && D.length > 0) {
          this.n = new BigInteger(N);
          this.e = _.isNumber(E) ? E : utils2.get32IntFromBuffer(E, 0);
          this.d = new BigInteger(D);
          if (P && Q && DP && DQ && C) {
            this.p = new BigInteger(P);
            this.q = new BigInteger(Q);
            this.dmp1 = new BigInteger(DP);
            this.dmq1 = new BigInteger(DQ);
            this.coeff = new BigInteger(C);
          } else {
          }
          this.$$recalculateCache();
        } else {
          throw Error("Invalid RSA private key");
        }
      };
      RSAKey.prototype.setPublic = function(N, E) {
        if (N && E && N.length > 0 && (_.isNumber(E) || E.length > 0)) {
          this.n = new BigInteger(N);
          this.e = _.isNumber(E) ? E : utils2.get32IntFromBuffer(E, 0);
          this.$$recalculateCache();
        } else {
          throw Error("Invalid RSA public key");
        }
      };
      RSAKey.prototype.$doPrivate = function(x) {
        if (this.p || this.q) {
          return x.modPow(this.d, this.n);
        }
        var xp = x.mod(this.p).modPow(this.dmp1, this.p);
        var xq = x.mod(this.q).modPow(this.dmq1, this.q);
        while (xp.compareTo(xq) < 0) {
          xp = xp.add(this.p);
        }
        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
      };
      RSAKey.prototype.$doPublic = function(x) {
        return x.modPowInt(this.e, this.n);
      };
      RSAKey.prototype.encrypt = function(buffer, usePrivate) {
        var buffers = [];
        var results = [];
        var bufferSize = buffer.length;
        var buffersCount = Math.ceil(bufferSize / this.maxMessageLength) || 1;
        var dividedSize = Math.ceil(bufferSize / buffersCount || 1);
        if (buffersCount == 1) {
          buffers.push(buffer);
        } else {
          for (var bufNum = 0; bufNum < buffersCount; bufNum++) {
            buffers.push(buffer.slice(bufNum * dividedSize, (bufNum + 1) * dividedSize));
          }
        }
        for (var i = 0; i < buffers.length; i++) {
          results.push(this.encryptEngine.encrypt(buffers[i], usePrivate));
        }
        return Buffer.concat(results);
      };
      RSAKey.prototype.decrypt = function(buffer, usePublic) {
        if (buffer.length % this.encryptedDataLength > 0) {
          throw Error("Incorrect data or key");
        }
        var result = [];
        var offset = 0;
        var length = 0;
        var buffersCount = buffer.length / this.encryptedDataLength;
        for (var i = 0; i < buffersCount; i++) {
          offset = i * this.encryptedDataLength;
          length = offset + this.encryptedDataLength;
          result.push(this.encryptEngine.decrypt(buffer.slice(offset, Math.min(length, buffer.length)), usePublic));
        }
        return Buffer.concat(result);
      };
      RSAKey.prototype.sign = function(buffer) {
        return this.signingScheme.sign.apply(this.signingScheme, arguments);
      };
      RSAKey.prototype.verify = function(buffer, signature, signature_encoding) {
        return this.signingScheme.verify.apply(this.signingScheme, arguments);
      };
      RSAKey.prototype.isPrivate = function() {
        return this.n && this.e && this.d || false;
      };
      RSAKey.prototype.isPublic = function(strict) {
        return this.n && this.e && !(strict && this.d) || false;
      };
      Object.defineProperty(RSAKey.prototype, "keySize", {
        get: function() {
          return this.cache.keyBitLength;
        }
      });
      Object.defineProperty(RSAKey.prototype, "encryptedDataLength", {
        get: function() {
          return this.cache.keyByteLength;
        }
      });
      Object.defineProperty(RSAKey.prototype, "maxMessageLength", {
        get: function() {
          return this.encryptionScheme.maxMessageLength();
        }
      });
      RSAKey.prototype.$$recalculateCache = function() {
        this.cache = this.cache || {};
        this.cache.keyBitLength = this.n.bitLength();
        this.cache.keyByteLength = this.cache.keyBitLength + 6 >> 3;
      };
      return RSAKey;
    }();
  }
});

// ../node_modules/node-rsa/node_modules/asn1/lib/ber/errors.js
var require_errors4 = __commonJS({
  "../node_modules/node-rsa/node_modules/asn1/lib/ber/errors.js"(exports2, module2) {
    module2.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }
    };
  }
});

// ../node_modules/node-rsa/node_modules/asn1/lib/ber/types.js
var require_types = __commonJS({
  "../node_modules/node-rsa/node_modules/asn1/lib/ber/types.js"(exports2, module2) {
    module2.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// ../node_modules/node-rsa/node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS({
  "../node_modules/node-rsa/node_modules/asn1/lib/ber/reader.js"(exports2, module2) {
    var assert = require("assert");
    var ASN1 = require_types();
    var errors = require_errors4();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer.isBuffer(data))
        throw new TypeError("data must be a node Buffer");
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      if (!peek)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) == 128) {
        lenB &= 127;
        if (lenB == 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== void 0 && tag !== seq)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return retbuf ? new Buffer(0) : "";
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str : str.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null)
        return null;
      var values = [];
      var value = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value <<= 7;
        value += byte & 127;
        if ((byte & 128) == 0) {
          values.push(value);
          value = 0;
        }
      }
      value = values.shift();
      values.unshift(value % 40);
      values.unshift(value / 40 >> 0);
      return values.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value = 0;
      for (var i = 0; i < this.length; i++) {
        value <<= 8;
        value |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) == 128 && i !== 4)
        value -= 1 << i * 8;
      return value >> 0;
    };
    module2.exports = Reader;
  }
});

// ../node_modules/node-rsa/node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "../node_modules/node-rsa/node_modules/asn1/lib/ber/writer.js"(exports2, module2) {
    var assert = require("assert");
    var ASN1 = require_types();
    var errors = require_errors4();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge(from, to) {
      assert.ok(from);
      assert.equal(typeof from, "object");
      assert.ok(to);
      assert.equal(typeof to, "object");
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key])
          return;
        var value = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value);
      });
      return to;
    }
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
      this._buf = new Buffer(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw new InvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw new InvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean")
        throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number")
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number")
        tag = ASN1.OctetString;
      var len = Buffer.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number")
        throw new TypeError("tag must be a number");
      if (!Buffer.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string");
      if (typeof tag !== "number")
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw new InvalidAsn1ERror("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number")
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq] = 129;
        this._buf[seq + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq] = 130;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq] = 131;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw new InvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== void 0);
      assert.ok(len !== void 0);
      assert.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = new Buffer(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module2.exports = Writer;
  }
});

// ../node_modules/node-rsa/node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "../node_modules/node-rsa/node_modules/asn1/lib/ber/index.js"(exports2, module2) {
    var errors = require_errors4();
    var types = require_types();
    var Reader = require_reader();
    var Writer = require_writer();
    module2.exports = {
      Reader,
      Writer
    };
    for (t in types) {
      if (types.hasOwnProperty(t))
        module2.exports[t] = types[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e))
        module2.exports[e] = errors[e];
    }
    var e;
  }
});

// ../node_modules/node-rsa/node_modules/asn1/lib/index.js
var require_lib3 = __commonJS({
  "../node_modules/node-rsa/node_modules/asn1/lib/index.js"(exports2, module2) {
    var Ber = require_ber();
    module2.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// ../node_modules/node-rsa/src/formats/pkcs1.js
var require_pkcs12 = __commonJS({
  "../node_modules/node-rsa/src/formats/pkcs1.js"(exports2, module2) {
    var ber = require_lib3().Ber;
    var _ = require_utils10()._;
    var utils2 = require_utils10();
    module2.exports = {
      privateExport: function(key, options) {
        options = options || {};
        var n = key.n.toBuffer();
        var d = key.d.toBuffer();
        var p = key.p.toBuffer();
        var q2 = key.q.toBuffer();
        var dmp1 = key.dmp1.toBuffer();
        var dmq1 = key.dmq1.toBuffer();
        var coeff = key.coeff.toBuffer();
        var length = n.length + d.length + p.length + q2.length + dmp1.length + dmq1.length + coeff.length + 512;
        var writer = new ber.Writer({ size: length });
        writer.startSequence();
        writer.writeInt(0);
        writer.writeBuffer(n, 2);
        writer.writeInt(key.e);
        writer.writeBuffer(d, 2);
        writer.writeBuffer(p, 2);
        writer.writeBuffer(q2, 2);
        writer.writeBuffer(dmp1, 2);
        writer.writeBuffer(dmq1, 2);
        writer.writeBuffer(coeff, 2);
        writer.endSequence();
        if (options.type === "der") {
          return writer.buffer;
        } else {
          return "-----BEGIN RSA PRIVATE KEY-----\n" + utils2.linebrk(writer.buffer.toString("base64"), 64) + "\n-----END RSA PRIVATE KEY-----";
        }
      },
      privateImport: function(key, data, options) {
        options = options || {};
        var buffer;
        if (options.type !== "der") {
          if (Buffer.isBuffer(data)) {
            data = data.toString("utf8");
          }
          if (_.isString(data)) {
            var pem = data.replace("-----BEGIN RSA PRIVATE KEY-----", "").replace("-----END RSA PRIVATE KEY-----", "").replace(/\s+|\n\r|\n|\r$/gm, "");
            buffer = new Buffer(pem, "base64");
          } else {
            throw Error("Unsupported key format");
          }
        } else if (Buffer.isBuffer(data)) {
          buffer = data;
        } else {
          throw Error("Unsupported key format");
        }
        var reader = new ber.Reader(buffer);
        reader.readSequence();
        reader.readString(2, true);
        key.setPrivate(
          reader.readString(2, true),
          reader.readString(2, true),
          reader.readString(2, true),
          reader.readString(2, true),
          reader.readString(2, true),
          reader.readString(2, true),
          reader.readString(2, true),
          reader.readString(2, true)
        );
      },
      publicExport: function(key, options) {
        options = options || {};
        var n = key.n.toBuffer();
        var length = n.length + 512;
        var bodyWriter = new ber.Writer({ size: length });
        bodyWriter.startSequence();
        bodyWriter.writeBuffer(n, 2);
        bodyWriter.writeInt(key.e);
        bodyWriter.endSequence();
        if (options.type === "der") {
          return bodyWriter.buffer;
        } else {
          return "-----BEGIN RSA PUBLIC KEY-----\n" + utils2.linebrk(bodyWriter.buffer.toString("base64"), 64) + "\n-----END RSA PUBLIC KEY-----";
        }
      },
      publicImport: function(key, data, options) {
        options = options || {};
        var buffer;
        if (options.type !== "der") {
          if (Buffer.isBuffer(data)) {
            data = data.toString("utf8");
          }
          if (_.isString(data)) {
            var pem = data.replace("-----BEGIN RSA PUBLIC KEY-----", "").replace("-----END RSA PUBLIC KEY-----", "").replace(/\s+|\n\r|\n|\r$/gm, "");
            buffer = new Buffer(pem, "base64");
          }
        } else if (Buffer.isBuffer(data)) {
          buffer = data;
        } else {
          throw Error("Unsupported key format");
        }
        var body = new ber.Reader(buffer);
        body.readSequence();
        key.setPublic(
          body.readString(2, true),
          body.readString(2, true)
        );
      },
      autoImport: function(key, data) {
        if (/^\s*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----\s*$/g.test(data)) {
          module2.exports.privateImport(key, data);
          return true;
        }
        if (/^\s*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----\s*$/g.test(data)) {
          module2.exports.publicImport(key, data);
          return true;
        }
        return false;
      }
    };
  }
});

// ../node_modules/node-rsa/src/formats/pkcs8.js
var require_pkcs8 = __commonJS({
  "../node_modules/node-rsa/src/formats/pkcs8.js"(exports2, module2) {
    var ber = require_lib3().Ber;
    var _ = require_utils10()._;
    var PUBLIC_RSA_OID = "1.2.840.113549.1.1.1";
    var utils2 = require_utils10();
    module2.exports = {
      privateExport: function(key, options) {
        options = options || {};
        var n = key.n.toBuffer();
        var d = key.d.toBuffer();
        var p = key.p.toBuffer();
        var q2 = key.q.toBuffer();
        var dmp1 = key.dmp1.toBuffer();
        var dmq1 = key.dmq1.toBuffer();
        var coeff = key.coeff.toBuffer();
        var length = n.length + d.length + p.length + q2.length + dmp1.length + dmq1.length + coeff.length + 512;
        var bodyWriter = new ber.Writer({ size: length });
        bodyWriter.startSequence();
        bodyWriter.writeInt(0);
        bodyWriter.writeBuffer(n, 2);
        bodyWriter.writeInt(key.e);
        bodyWriter.writeBuffer(d, 2);
        bodyWriter.writeBuffer(p, 2);
        bodyWriter.writeBuffer(q2, 2);
        bodyWriter.writeBuffer(dmp1, 2);
        bodyWriter.writeBuffer(dmq1, 2);
        bodyWriter.writeBuffer(coeff, 2);
        bodyWriter.endSequence();
        var writer = new ber.Writer({ size: length });
        writer.startSequence();
        writer.writeInt(0);
        writer.startSequence();
        writer.writeOID(PUBLIC_RSA_OID);
        writer.writeNull();
        writer.endSequence();
        writer.writeBuffer(bodyWriter.buffer, 4);
        writer.endSequence();
        if (options.type === "der") {
          return writer.buffer;
        } else {
          return "-----BEGIN PRIVATE KEY-----\n" + utils2.linebrk(writer.buffer.toString("base64"), 64) + "\n-----END PRIVATE KEY-----";
        }
      },
      privateImport: function(key, data, options) {
        options = options || {};
        var buffer;
        if (options.type !== "der") {
          if (Buffer.isBuffer(data)) {
            data = data.toString("utf8");
          }
          if (_.isString(data)) {
            var pem = data.replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "").replace(/\s+|\n\r|\n|\r$/gm, "");
            buffer = new Buffer(pem, "base64");
          } else {
            throw Error("Unsupported key format");
          }
        } else if (Buffer.isBuffer(data)) {
          buffer = data;
        } else {
          throw Error("Unsupported key format");
        }
        var reader = new ber.Reader(buffer);
        reader.readSequence();
        reader.readInt(0);
        var header = new ber.Reader(reader.readString(48, true));
        if (header.readOID(6, true) !== PUBLIC_RSA_OID) {
          throw Error("Invalid Public key format");
        }
        var body = new ber.Reader(reader.readString(4, true));
        body.readSequence();
        body.readString(2, true);
        key.setPrivate(
          body.readString(2, true),
          body.readString(2, true),
          body.readString(2, true),
          body.readString(2, true),
          body.readString(2, true),
          body.readString(2, true),
          body.readString(2, true),
          body.readString(2, true)
        );
      },
      publicExport: function(key, options) {
        options = options || {};
        var n = key.n.toBuffer();
        var length = n.length + 512;
        var bodyWriter = new ber.Writer({ size: length });
        bodyWriter.writeByte(0);
        bodyWriter.startSequence();
        bodyWriter.writeBuffer(n, 2);
        bodyWriter.writeInt(key.e);
        bodyWriter.endSequence();
        var writer = new ber.Writer({ size: length });
        writer.startSequence();
        writer.startSequence();
        writer.writeOID(PUBLIC_RSA_OID);
        writer.writeNull();
        writer.endSequence();
        writer.writeBuffer(bodyWriter.buffer, 3);
        writer.endSequence();
        if (options.type === "der") {
          return writer.buffer;
        } else {
          return "-----BEGIN PUBLIC KEY-----\n" + utils2.linebrk(writer.buffer.toString("base64"), 64) + "\n-----END PUBLIC KEY-----";
        }
      },
      publicImport: function(key, data, options) {
        options = options || {};
        var buffer;
        if (options.type !== "der") {
          if (Buffer.isBuffer(data)) {
            data = data.toString("utf8");
          }
          if (_.isString(data)) {
            var pem = data.replace("-----BEGIN PUBLIC KEY-----", "").replace("-----END PUBLIC KEY-----", "").replace(/\s+|\n\r|\n|\r$/gm, "");
            buffer = new Buffer(pem, "base64");
          }
        } else if (Buffer.isBuffer(data)) {
          buffer = data;
        } else {
          throw Error("Unsupported key format");
        }
        var reader = new ber.Reader(buffer);
        reader.readSequence();
        var header = new ber.Reader(reader.readString(48, true));
        if (header.readOID(6, true) !== PUBLIC_RSA_OID) {
          throw Error("Invalid Public key format");
        }
        var body = new ber.Reader(reader.readString(3, true));
        body.readByte();
        body.readSequence();
        key.setPublic(
          body.readString(2, true),
          body.readString(2, true)
        );
      },
      autoImport: function(key, data) {
        if (/^\s*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----\s*$/g.test(data)) {
          module2.exports.privateImport(key, data);
          return true;
        }
        if (/^\s*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----\s*$/g.test(data)) {
          module2.exports.publicImport(key, data);
          return true;
        }
        return false;
      }
    };
  }
});

// ../node_modules/node-rsa/src/formats/components.js
var require_components = __commonJS({
  "../node_modules/node-rsa/src/formats/components.js"(exports2, module2) {
    var _ = require_utils10()._;
    var utils2 = require_utils10();
    module2.exports = {
      privateExport: function(key, options) {
        return {
          n: key.n.toBuffer(),
          e: key.e,
          d: key.d.toBuffer(),
          p: key.p.toBuffer(),
          q: key.q.toBuffer(),
          dmp1: key.dmp1.toBuffer(),
          dmq1: key.dmq1.toBuffer(),
          coeff: key.coeff.toBuffer()
        };
      },
      privateImport: function(key, data, options) {
        if (data.n && data.e && data.d && data.p && data.q && data.dmp1 && data.dmq1 && data.coeff) {
          key.setPrivate(
            data.n,
            data.e,
            data.d,
            data.p,
            data.q,
            data.dmp1,
            data.dmq1,
            data.coeff
          );
        } else {
          throw Error("Invalid key data");
        }
      },
      publicExport: function(key, options) {
        return {
          n: key.n.toBuffer(),
          e: key.e
        };
      },
      publicImport: function(key, data, options) {
        if (data.n && data.e) {
          key.setPublic(
            data.n,
            data.e
          );
        } else {
          throw Error("Invalid key data");
        }
      },
      autoImport: function(key, data) {
        if (data.n && data.e) {
          if (data.d && data.p && data.q && data.dmp1 && data.dmq1 && data.coeff) {
            module2.exports.privateImport(key, data);
            return true;
          } else {
            module2.exports.publicImport(key, data);
            return true;
          }
        }
        return false;
      }
    };
  }
});

// ../node_modules/node-rsa/src/formats/formats.js
var require_formats2 = __commonJS({
  "../node_modules/node-rsa/src/formats/formats.js"(exports2, module2) {
    var _ = require_utils10()._;
    function formatParse(format) {
      format = format.split("-");
      var keyType = "private";
      var keyOpt = { type: "default" };
      for (var i = 1; i < format.length; i++) {
        if (format[i]) {
          switch (format[i]) {
            case "public":
              keyType = format[i];
              break;
            case "private":
              keyType = format[i];
              break;
            case "pem":
              keyOpt.type = format[i];
              break;
            case "der":
              keyOpt.type = format[i];
              break;
          }
        }
      }
      return { scheme: format[0], keyType, keyOpt };
    }
    module2.exports = {
      pkcs1: require_pkcs12(),
      pkcs8: require_pkcs8(),
      components: require_components(),
      isPrivateExport: function(format) {
        return module2.exports[format] && typeof module2.exports[format].privateExport === "function";
      },
      isPrivateImport: function(format) {
        return module2.exports[format] && typeof module2.exports[format].privateImport === "function";
      },
      isPublicExport: function(format) {
        return module2.exports[format] && typeof module2.exports[format].publicExport === "function";
      },
      isPublicImport: function(format) {
        return module2.exports[format] && typeof module2.exports[format].publicImport === "function";
      },
      detectAndImport: function(key, data, format) {
        if (format === void 0) {
          for (var scheme in module2.exports) {
            if (typeof module2.exports[scheme].autoImport === "function" && module2.exports[scheme].autoImport(key, data)) {
              return true;
            }
          }
        } else if (format) {
          var fmt = formatParse(format);
          if (module2.exports[fmt.scheme]) {
            if (fmt.keyType === "private") {
              module2.exports[fmt.scheme].privateImport(key, data, fmt.keyOpt);
            } else {
              module2.exports[fmt.scheme].publicImport(key, data, fmt.keyOpt);
            }
          } else {
            throw Error("Unsupported key format");
          }
        }
        return false;
      },
      detectAndExport: function(key, format) {
        if (format) {
          var fmt = formatParse(format);
          if (module2.exports[fmt.scheme]) {
            if (fmt.keyType === "private") {
              if (!key.isPrivate()) {
                throw Error("This is not private key");
              }
              return module2.exports[fmt.scheme].privateExport(key, fmt.keyOpt);
            } else {
              if (!key.isPublic()) {
                throw Error("This is not public key");
              }
              return module2.exports[fmt.scheme].publicExport(key, fmt.keyOpt);
            }
          } else {
            throw Error("Unsupported key format");
          }
        }
      }
    };
  }
});

// ../node_modules/node-rsa/src/NodeRSA.js
var require_NodeRSA = __commonJS({
  "../node_modules/node-rsa/src/NodeRSA.js"(exports2, module2) {
    var constants = require("constants");
    var rsa = require_rsa();
    var crypt = require("crypto");
    var ber = require_lib3().Ber;
    var _ = require_utils10()._;
    var utils2 = require_utils10();
    var schemes = require_schemes();
    var formats = require_formats2();
    if (typeof constants.RSA_NO_PADDING == "undefined") {
      constants.RSA_NO_PADDING = 3;
    }
    module2.exports = function() {
      var SUPPORTED_HASH_ALGORITHMS = {
        node10: ["md4", "md5", "ripemd160", "sha", "sha1", "sha224", "sha256", "sha384", "sha512"],
        node: ["md4", "md5", "ripemd160", "sha", "sha1", "sha224", "sha256", "sha384", "sha512"],
        iojs: ["md4", "md5", "ripemd160", "sha", "sha1", "sha224", "sha256", "sha384", "sha512"],
        browser: ["md5", "ripemd160", "sha1", "sha256", "sha512"]
      };
      var DEFAULT_ENCRYPTION_SCHEME = "pkcs1_oaep";
      var DEFAULT_SIGNING_SCHEME = "pkcs1";
      var DEFAULT_EXPORT_FORMAT = "private";
      var EXPORT_FORMAT_ALIASES = {
        "private": "pkcs1-private-pem",
        "private-der": "pkcs1-private-der",
        "public": "pkcs8-public-pem",
        "public-der": "pkcs8-public-der"
      };
      function NodeRSA(key, format, options) {
        if (!(this instanceof NodeRSA)) {
          return new NodeRSA(key, format, options);
        }
        if (_.isObject(format)) {
          options = format;
          format = void 0;
        }
        this.$options = {
          signingScheme: DEFAULT_SIGNING_SCHEME,
          signingSchemeOptions: {
            hash: "sha256",
            saltLength: null
          },
          encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,
          encryptionSchemeOptions: {
            hash: "sha1",
            label: null
          },
          environment: utils2.detectEnvironment(),
          rsaUtils: this
        };
        this.keyPair = new rsa.Key();
        this.$cache = {};
        if (Buffer.isBuffer(key) || _.isString(key)) {
          this.importKey(key, format);
        } else if (_.isObject(key)) {
          this.generateKeyPair(key.b, key.e);
        }
        this.setOptions(options);
      }
      NodeRSA.prototype.setOptions = function(options) {
        options = options || {};
        if (options.environment) {
          this.$options.environment = options.environment;
        }
        if (options.signingScheme) {
          if (_.isString(options.signingScheme)) {
            var signingScheme = options.signingScheme.toLowerCase().split("-");
            if (signingScheme.length == 1) {
              if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {
                this.$options.signingSchemeOptions = {
                  hash: signingScheme[0]
                };
                this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;
              } else {
                this.$options.signingScheme = signingScheme[0];
                this.$options.signingSchemeOptions = {
                  hash: null
                };
              }
            } else {
              this.$options.signingSchemeOptions = {
                hash: signingScheme[1]
              };
              this.$options.signingScheme = signingScheme[0];
            }
          } else if (_.isObject(options.signingScheme)) {
            this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;
            this.$options.signingSchemeOptions = _.omit(options.signingScheme, "scheme");
          }
          if (!schemes.isSignature(this.$options.signingScheme)) {
            throw Error("Unsupported signing scheme");
          }
          if (this.$options.signingSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {
            throw Error("Unsupported hashing algorithm for " + this.$options.environment + " environment");
          }
        }
        if (options.encryptionScheme) {
          if (_.isString(options.encryptionScheme)) {
            this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();
            this.$options.encryptionSchemeOptions = {};
          } else if (_.isObject(options.encryptionScheme)) {
            this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;
            this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, "scheme");
          }
          if (!schemes.isEncryption(this.$options.encryptionScheme)) {
            throw Error("Unsupported encryption scheme");
          }
          if (this.$options.encryptionSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {
            throw Error("Unsupported hashing algorithm for " + this.$options.environment + " environment");
          }
        }
        this.keyPair.setOptions(this.$options);
      };
      NodeRSA.prototype.generateKeyPair = function(bits, exp) {
        bits = bits || 2048;
        exp = exp || 65537;
        if (bits % 8 !== 0) {
          throw Error("Key size must be a multiple of 8.");
        }
        this.keyPair.generate(bits, exp.toString(16));
        this.$cache = {};
        return this;
      };
      NodeRSA.prototype.importKey = function(keyData, format) {
        if (!keyData) {
          throw Error("Empty key given");
        }
        if (format) {
          format = EXPORT_FORMAT_ALIASES[format] || format;
        }
        if (!formats.detectAndImport(this.keyPair, keyData, format) && format === void 0) {
          throw Error("Key format must be specified");
        }
        this.$cache = {};
      };
      NodeRSA.prototype.exportKey = function(format) {
        format = format || DEFAULT_EXPORT_FORMAT;
        format = EXPORT_FORMAT_ALIASES[format] || format;
        if (!this.$cache[format]) {
          this.$cache[format] = formats.detectAndExport(this.keyPair, format);
        }
        return this.$cache[format];
      };
      NodeRSA.prototype.isPrivate = function() {
        return this.keyPair.isPrivate();
      };
      NodeRSA.prototype.isPublic = function(strict) {
        return this.keyPair.isPublic(strict);
      };
      NodeRSA.prototype.isEmpty = function(strict) {
        return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);
      };
      NodeRSA.prototype.encrypt = function(buffer, encoding, source_encoding) {
        return this.$$encryptKey(false, buffer, encoding, source_encoding);
      };
      NodeRSA.prototype.decrypt = function(buffer, encoding) {
        return this.$$decryptKey(false, buffer, encoding);
      };
      NodeRSA.prototype.encryptPrivate = function(buffer, encoding, source_encoding) {
        return this.$$encryptKey(true, buffer, encoding, source_encoding);
      };
      NodeRSA.prototype.decryptPublic = function(buffer, encoding) {
        return this.$$decryptKey(true, buffer, encoding);
      };
      NodeRSA.prototype.$$encryptKey = function(usePrivate, buffer, encoding, source_encoding) {
        try {
          var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);
          if (encoding == "buffer" || !encoding) {
            return res;
          } else {
            return res.toString(encoding);
          }
        } catch (e) {
          throw Error("Error during encryption. Original error: " + e);
        }
      };
      NodeRSA.prototype.$$decryptKey = function(usePublic, buffer, encoding) {
        try {
          buffer = _.isString(buffer) ? new Buffer(buffer, "base64") : buffer;
          var res = this.keyPair.decrypt(buffer, usePublic);
          if (res === null) {
            throw Error("Key decrypt method returns null.");
          }
          return this.$getDecryptedData(res, encoding);
        } catch (e) {
          throw Error("Error during decryption (probably incorrect key). Original error: " + e);
        }
      };
      NodeRSA.prototype.sign = function(buffer, encoding, source_encoding) {
        if (!this.isPrivate()) {
          throw Error("This is not private key");
        }
        var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));
        if (encoding && encoding != "buffer") {
          res = res.toString(encoding);
        }
        return res;
      };
      NodeRSA.prototype.verify = function(buffer, signature, source_encoding, signature_encoding) {
        if (!this.isPublic()) {
          throw Error("This is not public key");
        }
        signature_encoding = !signature_encoding || signature_encoding == "buffer" ? null : signature_encoding;
        return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);
      };
      NodeRSA.prototype.getKeySize = function() {
        return this.keyPair.keySize;
      };
      NodeRSA.prototype.getMaxMessageSize = function() {
        return this.keyPair.maxMessageLength;
      };
      NodeRSA.prototype.$getDataForEncrypt = function(buffer, encoding) {
        if (_.isString(buffer) || _.isNumber(buffer)) {
          return new Buffer("" + buffer, encoding || "utf8");
        } else if (Buffer.isBuffer(buffer)) {
          return buffer;
        } else if (_.isObject(buffer)) {
          return new Buffer(JSON.stringify(buffer));
        } else {
          throw Error("Unexpected data type");
        }
      };
      NodeRSA.prototype.$getDecryptedData = function(buffer, encoding) {
        encoding = encoding || "buffer";
        if (encoding == "buffer") {
          return buffer;
        } else if (encoding == "json") {
          return JSON.parse(buffer.toString());
        } else {
          return buffer.toString(encoding);
        }
      };
      return NodeRSA;
    }();
  }
});

// ../node_modules/minecraft-protocol/src/server/handshake.js
var require_handshake = __commonJS({
  "../node_modules/minecraft-protocol/src/server/handshake.js"(exports2, module2) {
    var states = require_states();
    module2.exports = function(client, server, { version, fallbackVersion }) {
      client.once("set_protocol", onHandshake);
      function onHandshake(packet) {
        client.serverHost = packet.serverHost;
        client.serverPort = packet.serverPort;
        client.protocolVersion = packet.protocolVersion;
        if (version === false) {
          if (require_minecraft_data()(client.protocolVersion)) {
            client.version = client.protocolVersion;
          } else {
            let fallback;
            if (fallbackVersion !== void 0) {
              fallback = require_minecraft_data()(fallbackVersion);
            }
            if (fallback) {
              client.version = fallback.version.version;
            } else {
              client.end("Protocol version " + client.protocolVersion + " is not supported");
            }
          }
        } else if (client.protocolVersion !== server.mcversion.version && packet.nextState !== 1) {
          client.end("Wrong protocol version, expected: " + server.mcversion.version + " and you are using: " + client.protocolVersion);
        }
        if (packet.nextState === 1) {
          client.state = states.STATUS;
        } else if (packet.nextState === 2) {
          client.state = states.LOGIN;
        }
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/server/keepalive.js
var require_keepalive2 = __commonJS({
  "../node_modules/minecraft-protocol/src/server/keepalive.js"(exports2, module2) {
    module2.exports = function(client, server, {
      kickTimeout = 30 * 1e3,
      checkTimeoutInterval = 4 * 1e3,
      keepAlive: enableKeepAlive = true
    }) {
      let keepAlive = false;
      let lastKeepAlive = null;
      let keepAliveTimer = null;
      let sendKeepAliveTime;
      function keepAliveLoop() {
        if (!keepAlive) {
          return;
        }
        const elapsed = new Date() - lastKeepAlive;
        if (elapsed > kickTimeout) {
          client.end("KeepAliveTimeout");
          return;
        }
        sendKeepAliveTime = new Date();
        client.write("keep_alive", {
          keepAliveId: Math.floor(Math.random() * 2147483648)
        });
      }
      function onKeepAlive() {
        if (sendKeepAliveTime)
          client.latency = new Date() - sendKeepAliveTime;
        lastKeepAlive = new Date();
      }
      function startKeepAlive() {
        keepAlive = true;
        lastKeepAlive = new Date();
        keepAliveTimer = setInterval(keepAliveLoop, checkTimeoutInterval);
        client.on("keep_alive", onKeepAlive);
      }
      if (enableKeepAlive) {
        client.on("state", (state) => {
          if (state === "play") {
            startKeepAlive();
          }
        });
      }
      client.on("end", () => clearInterval(keepAliveTimer));
    };
  }
});

// ../node_modules/minecraft-protocol/src/server/constants.js
var require_constants = __commonJS({
  "../node_modules/minecraft-protocol/src/server/constants.js"(exports2, module2) {
    module2.exports = {
      mojangPublicKeyPem: "-----BEGIN PUBLIC KEY-----\nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAylB4B6m5lz7jwrcFz6Fd\n/fnfUhcvlxsTSn5kIK/2aGG1C3kMy4VjhwlxF6BFUSnfxhNswPjh3ZitkBxEAFY2\n5uzkJFRwHwVA9mdwjashXILtR6OqdLXXFVyUPIURLOSWqGNBtb08EN5fMnG8iFLg\nEJIBMxs9BvF3s3/FhuHyPKiVTZmXY0WY4ZyYqvoKR+XjaTRPPvBsDa4WI2u1zxXM\neHlodT3lnCzVvyOYBLXL6CJgByuOxccJ8hnXfF9yY4F0aeL080Jz/3+EBNG8RO4B\nyhtBf4Ny8NQ6stWsjfeUIvH7bU/4zCYcYOq4WrInXHqS8qruDmIl7P5XXGcabuzQ\nstPf/h2CRAUpP/PlHXcMlvewjmGU6MfDK+lifScNYwjPxRo4nKTGFZf/0aqHCh/E\nAsQyLKrOIYRE0lDG3bzBh8ogIMLAugsAfBb6M3mqCqKaTMAf/VAjh5FFJnjS+7bE\n+bZEV0qwax1CEoPPJL1fIQjOS8zj086gjpGRCtSy9+bTPTfTR/SJ+VUB5G2IeCIt\nkNHpJX2ygojFZ9n5Fnj7R9ZnOM+L8nyIjPu3aePvtcrXlyLhH/hvOfIOjPxOlqW+\nO5QwSFP4OEcyLAUgDdUgyW36Z5mB285uKW/ighzZsOTevVUG2QwDItObIV6i8RCx\nFbN2oDHyPaO5j1tTaBNyVt8CAwEAAQ==\n-----END PUBLIC KEY-----"
    };
  }
});

// ../node_modules/minecraft-protocol/src/server/login.js
var require_login = __commonJS({
  "../node_modules/minecraft-protocol/src/server/login.js"(exports2, module2) {
    var UUID = require_uuid_1345();
    var crypto = require("crypto");
    var pluginChannels = require_pluginChannels();
    var states = require_states();
    var yggdrasil = require_src3();
    var { concat } = require_binaryStream();
    var { mojangPublicKeyPem } = require_constants();
    module2.exports = function(client, server, options) {
      const mojangPubKey = crypto.createPublicKey(mojangPublicKeyPem);
      const raise = (translatableError) => client.end(translatableError, JSON.stringify({ translate: translatableError }));
      const yggdrasilServer = yggdrasil.server({ agent: options.agent });
      const {
        "online-mode": onlineMode = true,
        kickTimeout = 30 * 1e3,
        errorHandler: clientErrorHandler = (client2, err) => client2.end(err)
      } = options;
      let serverId;
      client.on("error", function(err) {
        clientErrorHandler(client, err);
      });
      client.on("end", () => {
        clearTimeout(loginKickTimer);
      });
      client.once("login_start", onLogin);
      function kickForNotLoggingIn() {
        client.end("LoginTimeout");
      }
      let loginKickTimer = setTimeout(kickForNotLoggingIn, kickTimeout);
      function onLogin(packet) {
        const mcData = require_minecraft_data()(client.version);
        client.username = packet.username;
        const isException = !!server.onlineModeExceptions[client.username.toLowerCase()];
        const needToVerify = onlineMode && !isException || !onlineMode && isException;
        if (mcData.supportFeature("signatureEncryption")) {
          if (options.enforceSecureProfile && !packet.signature) {
            raise("multiplayer.disconnect.missing_public_key");
            return;
          }
        }
        if (packet.signature) {
          if (packet.signature.timestamp < BigInt(Date.now())) {
            raise("multiplayer.disconnect.invalid_public_key_signature");
            return;
          }
          try {
            const publicKey = crypto.createPublicKey({ key: packet.signature.publicKey, format: "der", type: "spki" });
            const publicPEM = mcPubKeyToPem(packet.signature.publicKey);
            const signable = packet.signature.timestamp + publicPEM;
            if (!crypto.verify("RSA-SHA1", Buffer.from(signable, "utf8"), mojangPubKey, packet.signature.signature)) {
              raise("multiplayer.disconnect.invalid_public_key_signature");
              return;
            }
            client.profileKeys = { public: publicKey, publicPEM };
          } catch (err) {
            raise("multiplayer.disconnect.invalid_public_key");
            return;
          }
        }
        if (needToVerify) {
          serverId = crypto.randomBytes(4).toString("hex");
          client.verifyToken = crypto.randomBytes(4);
          const publicKeyStrArr = server.serverKey.exportKey("pkcs8-public-pem").split("\n");
          let publicKeyStr = "";
          for (let i = 1; i < publicKeyStrArr.length - 1; i++) {
            publicKeyStr += publicKeyStrArr[i];
          }
          client.publicKey = Buffer.from(publicKeyStr, "base64");
          client.once("encryption_begin", onEncryptionKeyResponse);
          client.write("encryption_begin", {
            serverId,
            publicKey: client.publicKey,
            verifyToken: client.verifyToken
          });
        } else {
          loginClient();
        }
      }
      function onEncryptionKeyResponse(packet) {
        if (client.profileKeys) {
          if (options.enforceSecureProfile && packet.hasVerifyToken) {
            raise("multiplayer.disconnect.missing_public_key");
            return;
          }
        }
        if (packet.hasVerifyToken === false) {
          const signable = concat("buffer", client.verifyToken, "i64", packet.crypto.salt);
          if (!crypto.verify("sha256WithRSAEncryption", signable, client.profileKeys.public, packet.crypto.messageSignature)) {
            raise("multiplayer.disconnect.invalid_public_key_signature");
            return;
          }
        } else {
          const encryptedToken = packet.hasVerifyToken ? packet.crypto.verifyToken : packet.verifyToken;
          try {
            const decryptedToken = crypto.privateDecrypt({
              key: server.serverKey.exportKey(),
              padding: crypto.constants.RSA_PKCS1_PADDING
            }, encryptedToken);
            if (!client.verifyToken.equals(decryptedToken)) {
              client.end("DidNotEncryptVerifyTokenProperly");
              return;
            }
          } catch {
            client.end("DidNotEncryptVerifyTokenProperly");
            return;
          }
        }
        let sharedSecret;
        try {
          sharedSecret = crypto.privateDecrypt({
            key: server.serverKey.exportKey(),
            padding: crypto.constants.RSA_PKCS1_PADDING
          }, packet.sharedSecret);
        } catch (e) {
          client.end("DidNotEncryptVerifyTokenProperly");
          return;
        }
        client.setEncryption(sharedSecret);
        const isException = !!server.onlineModeExceptions[client.username.toLowerCase()];
        const needToVerify = onlineMode && !isException || !onlineMode && isException;
        const nextStep = needToVerify ? verifyUsername : loginClient;
        nextStep();
        function verifyUsername() {
          yggdrasilServer.hasJoined(client.username, serverId, sharedSecret, client.publicKey, function(err, profile) {
            if (err) {
              client.end("Failed to verify username!");
              return;
            }
            client.uuid = profile.id.replace(/(\w{8})(\w{4})(\w{4})(\w{4})(\w{12})/, "$1-$2-$3-$4-$5");
            client.username = profile.name;
            client.profile = profile;
            loginClient();
          });
        }
      }
      function javaUUID(s) {
        const hash = crypto.createHash("md5");
        hash.update(s, "utf8");
        const buffer = hash.digest();
        buffer[6] = buffer[6] & 15 | 48;
        buffer[8] = buffer[8] & 63 | 128;
        return buffer;
      }
      function nameToMcOfflineUUID(name) {
        return new UUID(javaUUID("OfflinePlayer:" + name)).toString();
      }
      function loginClient() {
        const isException = !!server.onlineModeExceptions[client.username.toLowerCase()];
        if (onlineMode === false || isException) {
          client.uuid = nameToMcOfflineUUID(client.username);
        }
        options.beforeLogin?.(client);
        if (client.protocolVersion >= 27) {
          client.write("compress", { threshold: 256 });
          client.compressionThreshold = 256;
        }
        client.write("success", {
          uuid: client.uuid,
          username: client.username,
          properties: []
        });
        client.state = states.PLAY;
        clearTimeout(loginKickTimer);
        loginKickTimer = null;
        server.playerCount += 1;
        client.once("end", function() {
          server.playerCount -= 1;
        });
        pluginChannels(client, options);
        if (client.profileKeys) {
          client.verifyMessage = (packet) => {
            const signable = concat(
              "i64",
              packet.salt,
              "UUID",
              client.uuid,
              "i64",
              packet.timestamp,
              "pstring",
              packet.message
            );
            return crypto.verify("sha256WithRSAEncryption", signable, client.profileKeys.public, packet.crypto.signature);
          };
        }
        server.emit("login", client);
      }
    };
    function mcPubKeyToPem(mcPubKeyBuffer) {
      let pem = "-----BEGIN RSA PUBLIC KEY-----\n";
      let base64PubKey = mcPubKeyBuffer.toString("base64");
      const maxLineLength = 76;
      while (base64PubKey.length > 0) {
        pem += base64PubKey.substring(0, maxLineLength) + "\n";
        base64PubKey = base64PubKey.substring(maxLineLength);
      }
      pem += "-----END RSA PUBLIC KEY-----\n";
      return pem;
    }
  }
});

// ../node_modules/endian-toggle/index.js
var require_endian_toggle = __commonJS({
  "../node_modules/endian-toggle/index.js"(exports2, module2) {
    module2.exports = function(buf, bits) {
      var output = new Buffer(buf.length);
      if (bits % 8 !== 0) {
        throw new Error("bits must be a multiple of 8");
      }
      var bytes = bits / 8;
      if (buf.length % bytes !== 0) {
        throw new Error(buf.length % bytes + " non-aligned trailing bytes");
      }
      for (var i = 0; i < buf.length; i += bytes) {
        for (var j = 0; j < bytes; j++) {
          output[i + bytes - j - 1] = buf[i + j];
        }
      }
      return output;
    };
  }
});

// ../node_modules/minecraft-protocol/src/server/ping.js
var require_ping2 = __commonJS({
  "../node_modules/minecraft-protocol/src/server/ping.js"(exports2, module2) {
    var endianToggle = require_endian_toggle();
    module2.exports = function(client, server, { beforePing = null, version, fallbackVersion }) {
      client.once("ping_start", onPing);
      client.once("legacy_server_list_ping", onLegacyPing);
      function onPing() {
        let responseVersion = {
          name: server.mcversion.minecraftVersion,
          protocol: server.mcversion.version
        };
        if (version === false) {
          let minecraftData = require_minecraft_data()(client.protocolVersion);
          if (!minecraftData && fallbackVersion !== void 0) {
            minecraftData = require_minecraft_data()(fallbackVersion);
          }
          if (minecraftData) {
            responseVersion = {
              name: minecraftData.version.minecraftVersion,
              protocol: minecraftData.version.version
            };
          } else {
            responseVersion = {
              name: client.version,
              protocol: client.protocolVersion
            };
          }
        }
        const response = {
          version: responseVersion,
          players: {
            max: server.maxPlayers,
            online: server.playerCount,
            sample: []
          },
          description: server.motdMsg ?? { text: server.motd },
          favicon: server.favicon
        };
        function answerToPing(err, response2) {
          if (err)
            return;
          if (response2 === false) {
            client.socket.destroy();
          } else {
            client.write("server_info", { response: JSON.stringify(response2) });
          }
        }
        if (beforePing) {
          if (beforePing.length > 2) {
            beforePing(response, client, answerToPing);
          } else {
            answerToPing(null, beforePing(response, client) || response);
          }
        } else {
          answerToPing(null, response);
        }
        client.once("ping", function(packet) {
          client.write("ping", { time: packet.time });
          client.end();
        });
      }
      function onLegacyPing(packet) {
        if (packet.payload === 1) {
          const pingVersion = 1;
          sendPingResponse("\xA7" + [
            pingVersion,
            server.mcversion.version,
            server.mcversion.minecraftVersion,
            server.motd,
            server.playerCount.toString(),
            server.maxPlayers.toString()
          ].join("\0"));
        } else {
          sendPingResponse([server.motd, server.playerCount.toString(), server.maxPlayers.toString()].join("\xA7"));
        }
        function sendPingResponse(responseString) {
          function utf16be(s) {
            return endianToggle(Buffer.from(s, "utf16le"), 16);
          }
          const responseBuffer = utf16be(responseString);
          const length = responseString.length;
          const lengthBuffer = Buffer.alloc(2);
          lengthBuffer.writeUInt16BE(length);
          const raw = Buffer.concat([Buffer.from("ff", "hex"), lengthBuffer, responseBuffer]);
          client.socket.write(raw);
        }
      }
    };
  }
});

// ../node_modules/minecraft-protocol/src/createServer.js
var require_createServer = __commonJS({
  "../node_modules/minecraft-protocol/src/createServer.js"(exports2, module2) {
    "use strict";
    var Server = require_server();
    var NodeRSA = require_NodeRSA();
    var plugins = [
      require_handshake(),
      require_keepalive2(),
      require_login(),
      require_ping2()
    ];
    module2.exports = createServer;
    function createServer(options = {}) {
      const {
        host = void 0,
        "server-port": serverPort,
        port = serverPort || 25565,
        motd = "A Minecraft server",
        "max-players": maxPlayersOld = 20,
        maxPlayers: maxPlayersNew = 20,
        version,
        favicon,
        customPackets,
        motdMsg
      } = options;
      const maxPlayers = options["max-players"] !== void 0 ? maxPlayersOld : maxPlayersNew;
      const optVersion = version === void 0 || version === false ? require_version3().defaultVersion : version;
      const mcData = require_minecraft_data()(optVersion);
      if (!mcData)
        throw new Error(`unsupported protocol version: ${optVersion}`);
      const mcversion = mcData.version;
      const hideErrors = options.hideErrors || false;
      const server = new Server(mcversion.minecraftVersion, customPackets, hideErrors);
      server.mcversion = mcversion;
      server.motd = motd;
      server.motdMsg = motdMsg;
      server.maxPlayers = maxPlayers;
      server.playerCount = 0;
      server.onlineModeExceptions = /* @__PURE__ */ Object.create(null);
      server.favicon = favicon;
      Object.defineProperty(server, "serverKey", {
        configurable: true,
        get() {
          this.serverKey = new NodeRSA({ b: 1024 });
          return this.serverKey;
        },
        set(value) {
          delete this.serverKey;
          this.serverKey = value;
        }
      });
      server.on("connection", function(client) {
        plugins.forEach((plugin) => plugin(client, server, options));
      });
      server.listen(port, host);
      return server;
    }
  }
});

// ../node_modules/minecraft-protocol/src/index.js
var require_src4 = __commonJS({
  "../node_modules/minecraft-protocol/src/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var Server = require_server();
    var serializer = require_serializer2();
    var createClient = require_createClient();
    var createServer = require_createServer();
    module2.exports = {
      createClient,
      createServer,
      Client,
      Server,
      states: require_states(),
      createSerializer: serializer.createSerializer,
      createDeserializer: serializer.createDeserializer,
      ping: require_ping(),
      supportedVersions: require_version3().supportedVersions,
      defaultVersion: require_version3().defaultVersion
    };
  }
});

// ../index.mjs
var import_minecraft_protocol = __toESM(require_src4(), 1);
var q = require("daskeyboard-applet");
var logger = q.logger;
function removeColorsFromString(text) {
  return text.replace(/§./g, "");
}
var MinecraftStatus = class extends q.DesktopApp {
  constructor() {
    super();
    this.pollingInterval = 1e4;
  }
  async getMinecraftStatus(host, port) {
    logger.info("Running getMinecraftStatus");
    try {
      let res = await import_minecraft_protocol.default.ping({ host, port });
      logger.info(`Response from Minecraft Server: ${JSON.stringify(res)}`);
      return res;
    } catch (err) {
      logger.warn(`Error while getting Minecraft Server details: ${err}`);
      return false;
    }
  }
  generateSignal(serverStatus, onlineColour, offlineColour) {
    if (serverStatus) {
      const max = Math.min(serverStatus.players.online, 11) + 1;
      let pointsList = [];
      for (let a = 0; a < max; a++) {
        pointsList.push(new q.Point(onlineColour));
      }
      for (let a = max; a < 11; a++) {
        pointsList.push(new q.Point(offlineColour));
      }
      return new q.Signal(
        {
          points: [pointsList],
          name: "Minecraft server online!",
          message: `${this.config.serverAddress} is online. | ${JSON.stringify(serverStatus.players.online)}/${JSON.stringify(serverStatus.players.max)} | ${removeColorsFromString(JSON.stringify(serverStatus.description.text))}`
        }
      );
    } else {
      return new q.Signal({
        points: [
          [new q.Point(offlineColour)]
        ],
        name: "Minecraft server offline!",
        message: `${this.config.serverAddress} is offline.`
      });
    }
  }
  async run() {
    const onlineColour = this.config.onlineColour;
    const offlineColour = this.config.offlineColour;
    const serverAddress = this.config.serverAddress;
    const serverPort = this.config.serverPort;
    if (serverAddress) {
      return this.getMinecraftStatus(serverAddress, serverPort).then((serverStatus) => {
        return this.generateSignal(serverStatus, onlineColour, offlineColour);
      }).catch((err) => {
        logger.error(`Error while getting server status: ${err}`);
      });
    } else {
      return null;
    }
  }
};
module.exports = {
  MinecraftStatus
};
var applet = new MinecraftStatus();
/*!
 * RSA library for Node.js
 *
 * Copyright (c) 2014 rzcoder
 * All Rights Reserved.
 *
 * License BSD
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! @azure/msal-common v7.4.0 2022-09-06 */
/*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
